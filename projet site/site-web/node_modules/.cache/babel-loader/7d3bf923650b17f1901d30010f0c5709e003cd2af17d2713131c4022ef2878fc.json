{"ast":null,"code":"\"use strict\";\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __name = (target, value) => __defProp(target, \"name\", {\n  value,\n  configurable: true\n});\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n// If the importer is in node compatibility mode or this is not an ESM\n// file that has been converted to a CommonJS file using a Babel-\n// compatible transform (i.e. \"__esModule\" has not been set), then set\n// \"default\" to the CommonJS \"module.exports\" for node compatibility.\nisNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  CloseCodes: () => CloseCodes,\n  CompressionMethod: () => CompressionMethod,\n  DefaultDeviceProperty: () => DefaultDeviceProperty,\n  DefaultWebSocketManagerOptions: () => DefaultWebSocketManagerOptions,\n  Encoding: () => Encoding,\n  ImportantGatewayOpcodes: () => ImportantGatewayOpcodes,\n  SimpleContextFetchingStrategy: () => SimpleContextFetchingStrategy,\n  SimpleIdentifyThrottler: () => SimpleIdentifyThrottler,\n  SimpleShardingStrategy: () => SimpleShardingStrategy,\n  WebSocketManager: () => WebSocketManager,\n  WebSocketShard: () => WebSocketShard,\n  WebSocketShardDestroyRecovery: () => WebSocketShardDestroyRecovery,\n  WebSocketShardEvents: () => WebSocketShardEvents,\n  WebSocketShardStatus: () => WebSocketShardStatus,\n  WorkerBootstrapper: () => WorkerBootstrapper,\n  WorkerContextFetchingStrategy: () => WorkerContextFetchingStrategy,\n  WorkerReceivePayloadOp: () => WorkerReceivePayloadOp,\n  WorkerSendPayloadOp: () => WorkerSendPayloadOp,\n  WorkerShardingStrategy: () => WorkerShardingStrategy,\n  getInitialSendRateLimitState: () => getInitialSendRateLimitState,\n  managerToFetchingStrategyOptions: () => managerToFetchingStrategyOptions,\n  version: () => version\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/strategies/context/IContextFetchingStrategy.ts\nasync function managerToFetchingStrategyOptions(manager) {\n  const {\n    buildIdentifyThrottler,\n    buildStrategy,\n    retrieveSessionInfo,\n    updateSessionInfo,\n    shardCount,\n    shardIds,\n    rest,\n    ...managerOptions\n  } = manager.options;\n  return {\n    ...managerOptions,\n    gatewayInformation: await manager.fetchGatewayInformation(),\n    shardCount: await manager.getShardCount()\n  };\n}\n__name(managerToFetchingStrategyOptions, \"managerToFetchingStrategyOptions\");\n\n// src/strategies/context/SimpleContextFetchingStrategy.ts\nvar SimpleContextFetchingStrategy = class _SimpleContextFetchingStrategy {\n  constructor(manager, options) {\n    this.manager = manager;\n    this.options = options;\n  }\n  static {\n    __name(this, \"SimpleContextFetchingStrategy\");\n  }\n  // This strategy assumes every shard is running under the same process - therefore we need a single\n  // IdentifyThrottler per manager.\n  static throttlerCache = /* @__PURE__ */new WeakMap();\n  static async ensureThrottler(manager) {\n    const throttler = _SimpleContextFetchingStrategy.throttlerCache.get(manager);\n    if (throttler) {\n      return throttler;\n    }\n    const newThrottler = await manager.options.buildIdentifyThrottler(manager);\n    _SimpleContextFetchingStrategy.throttlerCache.set(manager, newThrottler);\n    return newThrottler;\n  }\n  async retrieveSessionInfo(shardId) {\n    return this.manager.options.retrieveSessionInfo(shardId);\n  }\n  updateSessionInfo(shardId, sessionInfo) {\n    return this.manager.options.updateSessionInfo(shardId, sessionInfo);\n  }\n  async waitForIdentify(shardId, signal) {\n    const throttler = await _SimpleContextFetchingStrategy.ensureThrottler(this.manager);\n    await throttler.waitForIdentify(shardId, signal);\n  }\n};\n\n// src/strategies/context/WorkerContextFetchingStrategy.ts\nvar import_node_worker_threads2 = require(\"worker_threads\");\nvar import_collection2 = require(\"@discordjs/collection\");\n\n// src/strategies/sharding/WorkerShardingStrategy.ts\nvar import_node_events = require(\"events\");\nvar import_node_path = require(\"path\");\nvar import_node_worker_threads = require(\"worker_threads\");\nvar import_collection = require(\"@discordjs/collection\");\nvar WorkerSendPayloadOp = /* @__PURE__ */(WorkerSendPayloadOp2 => {\n  WorkerSendPayloadOp2[WorkerSendPayloadOp2[\"Connect\"] = 0] = \"Connect\";\n  WorkerSendPayloadOp2[WorkerSendPayloadOp2[\"Destroy\"] = 1] = \"Destroy\";\n  WorkerSendPayloadOp2[WorkerSendPayloadOp2[\"Send\"] = 2] = \"Send\";\n  WorkerSendPayloadOp2[WorkerSendPayloadOp2[\"SessionInfoResponse\"] = 3] = \"SessionInfoResponse\";\n  WorkerSendPayloadOp2[WorkerSendPayloadOp2[\"ShardIdentifyResponse\"] = 4] = \"ShardIdentifyResponse\";\n  WorkerSendPayloadOp2[WorkerSendPayloadOp2[\"FetchStatus\"] = 5] = \"FetchStatus\";\n  return WorkerSendPayloadOp2;\n})(WorkerSendPayloadOp || {});\nvar WorkerReceivePayloadOp = /* @__PURE__ */(WorkerReceivePayloadOp2 => {\n  WorkerReceivePayloadOp2[WorkerReceivePayloadOp2[\"Connected\"] = 0] = \"Connected\";\n  WorkerReceivePayloadOp2[WorkerReceivePayloadOp2[\"Destroyed\"] = 1] = \"Destroyed\";\n  WorkerReceivePayloadOp2[WorkerReceivePayloadOp2[\"Event\"] = 2] = \"Event\";\n  WorkerReceivePayloadOp2[WorkerReceivePayloadOp2[\"RetrieveSessionInfo\"] = 3] = \"RetrieveSessionInfo\";\n  WorkerReceivePayloadOp2[WorkerReceivePayloadOp2[\"UpdateSessionInfo\"] = 4] = \"UpdateSessionInfo\";\n  WorkerReceivePayloadOp2[WorkerReceivePayloadOp2[\"WaitForIdentify\"] = 5] = \"WaitForIdentify\";\n  WorkerReceivePayloadOp2[WorkerReceivePayloadOp2[\"FetchStatusResponse\"] = 6] = \"FetchStatusResponse\";\n  WorkerReceivePayloadOp2[WorkerReceivePayloadOp2[\"WorkerReady\"] = 7] = \"WorkerReady\";\n  WorkerReceivePayloadOp2[WorkerReceivePayloadOp2[\"CancelIdentify\"] = 8] = \"CancelIdentify\";\n  return WorkerReceivePayloadOp2;\n})(WorkerReceivePayloadOp || {});\nvar WorkerShardingStrategy = class {\n  static {\n    __name(this, \"WorkerShardingStrategy\");\n  }\n  manager;\n  options;\n  #workers = [];\n  #workerByShardId = new import_collection.Collection();\n  connectPromises = new import_collection.Collection();\n  destroyPromises = new import_collection.Collection();\n  fetchStatusPromises = new import_collection.Collection();\n  waitForIdentifyControllers = new import_collection.Collection();\n  throttler;\n  constructor(manager, options) {\n    this.manager = manager;\n    this.options = options;\n  }\n  /**\n   * {@inheritDoc IShardingStrategy.spawn}\n   */\n  async spawn(shardIds) {\n    const shardsPerWorker = this.options.shardsPerWorker === \"all\" ? shardIds.length : this.options.shardsPerWorker;\n    const strategyOptions = await managerToFetchingStrategyOptions(this.manager);\n    const loops = Math.ceil(shardIds.length / shardsPerWorker);\n    const promises = [];\n    for (let idx = 0; idx < loops; idx++) {\n      const slice = shardIds.slice(idx * shardsPerWorker, (idx + 1) * shardsPerWorker);\n      const workerData2 = {\n        ...strategyOptions,\n        shardIds: slice\n      };\n      promises.push(this.setupWorker(workerData2));\n    }\n    await Promise.all(promises);\n  }\n  /**\n   * {@inheritDoc IShardingStrategy.connect}\n   */\n  async connect() {\n    const promises = [];\n    for (const [shardId, worker] of this.#workerByShardId.entries()) {\n      const payload = {\n        op: 0 /* Connect */,\n        shardId\n      };\n      const promise = new Promise(resolve2 => this.connectPromises.set(shardId, resolve2));\n      worker.postMessage(payload);\n      promises.push(promise);\n    }\n    await Promise.all(promises);\n  }\n  /**\n   * {@inheritDoc IShardingStrategy.destroy}\n   */\n  async destroy(options = {}) {\n    const promises = [];\n    for (const [shardId, worker] of this.#workerByShardId.entries()) {\n      const payload = {\n        op: 1 /* Destroy */,\n        shardId,\n        options\n      };\n      promises.push(\n      // eslint-disable-next-line no-promise-executor-return, promise/prefer-await-to-then\n      new Promise(resolve2 => this.destroyPromises.set(shardId, resolve2)).then(async () => worker.terminate()));\n      worker.postMessage(payload);\n    }\n    this.#workers = [];\n    this.#workerByShardId.clear();\n    await Promise.all(promises);\n  }\n  /**\n   * {@inheritDoc IShardingStrategy.send}\n   */\n  send(shardId, data) {\n    const worker = this.#workerByShardId.get(shardId);\n    if (!worker) {\n      throw new Error(`No worker found for shard ${shardId}`);\n    }\n    const payload = {\n      op: 2 /* Send */,\n      shardId,\n      payload: data\n    };\n    worker.postMessage(payload);\n  }\n  /**\n   * {@inheritDoc IShardingStrategy.fetchStatus}\n   */\n  async fetchStatus() {\n    const statuses = new import_collection.Collection();\n    for (const [shardId, worker] of this.#workerByShardId.entries()) {\n      const nonce = Math.random();\n      const payload = {\n        op: 5 /* FetchStatus */,\n        shardId,\n        nonce\n      };\n      const promise = new Promise(resolve2 => this.fetchStatusPromises.set(nonce, resolve2));\n      worker.postMessage(payload);\n      const status = await promise;\n      statuses.set(shardId, status);\n    }\n    return statuses;\n  }\n  async setupWorker(workerData2) {\n    const worker = new import_node_worker_threads.Worker(this.resolveWorkerPath(), {\n      workerData: workerData2\n    });\n    await (0, import_node_events.once)(worker, \"online\");\n    await this.waitForWorkerReady(worker);\n    worker.on(\"error\", err => {\n      throw err;\n    }).on(\"messageerror\", err => {\n      throw err;\n    }).on(\"message\", async payload => this.onMessage(worker, payload));\n    this.#workers.push(worker);\n    for (const shardId of workerData2.shardIds) {\n      this.#workerByShardId.set(shardId, worker);\n    }\n  }\n  resolveWorkerPath() {\n    const path = this.options.workerPath;\n    if (!path) {\n      return (0, import_node_path.join)(__dirname, \"defaultWorker.js\");\n    }\n    if ((0, import_node_path.isAbsolute)(path)) {\n      return path;\n    }\n    if (/^\\.\\.?[/\\\\]/.test(path)) {\n      return (0, import_node_path.resolve)(path);\n    }\n    try {\n      return require.resolve(path);\n    } catch {\n      return (0, import_node_path.resolve)(path);\n    }\n  }\n  async waitForWorkerReady(worker) {\n    return new Promise(resolve2 => {\n      const handler = /* @__PURE__ */__name(payload => {\n        if (payload.op === 7 /* WorkerReady */) {\n          resolve2();\n          worker.off(\"message\", handler);\n        }\n      }, \"handler\");\n      worker.on(\"message\", handler);\n    });\n  }\n  async onMessage(worker, payload) {\n    switch (payload.op) {\n      case 0 /* Connected */:\n        {\n          this.connectPromises.get(payload.shardId)?.();\n          this.connectPromises.delete(payload.shardId);\n          break;\n        }\n      case 1 /* Destroyed */:\n        {\n          this.destroyPromises.get(payload.shardId)?.();\n          this.destroyPromises.delete(payload.shardId);\n          break;\n        }\n      case 2 /* Event */:\n        {\n          this.manager.emit(payload.event, {\n            ...payload.data,\n            shardId: payload.shardId\n          });\n          break;\n        }\n      case 3 /* RetrieveSessionInfo */:\n        {\n          const session = await this.manager.options.retrieveSessionInfo(payload.shardId);\n          const response = {\n            op: 3 /* SessionInfoResponse */,\n            nonce: payload.nonce,\n            session\n          };\n          worker.postMessage(response);\n          break;\n        }\n      case 4 /* UpdateSessionInfo */:\n        {\n          await this.manager.options.updateSessionInfo(payload.shardId, payload.session);\n          break;\n        }\n      case 5 /* WaitForIdentify */:\n        {\n          const throttler = await this.ensureThrottler();\n          try {\n            const controller = new AbortController();\n            this.waitForIdentifyControllers.set(payload.nonce, controller);\n            await throttler.waitForIdentify(payload.shardId, controller.signal);\n          } catch {\n            return;\n          }\n          const response = {\n            op: 4 /* ShardIdentifyResponse */,\n            nonce: payload.nonce,\n            ok: true\n          };\n          worker.postMessage(response);\n          break;\n        }\n      case 6 /* FetchStatusResponse */:\n        {\n          this.fetchStatusPromises.get(payload.nonce)?.(payload.status);\n          this.fetchStatusPromises.delete(payload.nonce);\n          break;\n        }\n      case 7 /* WorkerReady */:\n        {\n          break;\n        }\n      case 8 /* CancelIdentify */:\n        {\n          this.waitForIdentifyControllers.get(payload.nonce)?.abort();\n          this.waitForIdentifyControllers.delete(payload.nonce);\n          const response = {\n            op: 4 /* ShardIdentifyResponse */,\n            nonce: payload.nonce,\n            ok: false\n          };\n          worker.postMessage(response);\n          break;\n        }\n    }\n  }\n  async ensureThrottler() {\n    this.throttler ??= await this.manager.options.buildIdentifyThrottler(this.manager);\n    return this.throttler;\n  }\n};\n\n// src/strategies/context/WorkerContextFetchingStrategy.ts\nvar WorkerContextFetchingStrategy = class {\n  constructor(options) {\n    this.options = options;\n    if (import_node_worker_threads2.isMainThread) {\n      throw new Error(\"Cannot instantiate WorkerContextFetchingStrategy on the main thread\");\n    }\n    import_node_worker_threads2.parentPort.on(\"message\", payload => {\n      if (payload.op === 3 /* SessionInfoResponse */) {\n        this.sessionPromises.get(payload.nonce)?.(payload.session);\n        this.sessionPromises.delete(payload.nonce);\n      }\n      if (payload.op === 4 /* ShardIdentifyResponse */) {\n        const promise = this.waitForIdentifyPromises.get(payload.nonce);\n        if (payload.ok) {\n          promise?.resolve();\n        } else {\n          promise?.reject(promise.signal.reason);\n        }\n        this.waitForIdentifyPromises.delete(payload.nonce);\n      }\n    });\n  }\n  static {\n    __name(this, \"WorkerContextFetchingStrategy\");\n  }\n  sessionPromises = new import_collection2.Collection();\n  waitForIdentifyPromises = new import_collection2.Collection();\n  async retrieveSessionInfo(shardId) {\n    const nonce = Math.random();\n    const payload = {\n      op: 3 /* RetrieveSessionInfo */,\n      shardId,\n      nonce\n    };\n    const promise = new Promise(resolve2 => this.sessionPromises.set(nonce, resolve2));\n    import_node_worker_threads2.parentPort.postMessage(payload);\n    return promise;\n  }\n  updateSessionInfo(shardId, sessionInfo) {\n    const payload = {\n      op: 4 /* UpdateSessionInfo */,\n      shardId,\n      session: sessionInfo\n    };\n    import_node_worker_threads2.parentPort.postMessage(payload);\n  }\n  async waitForIdentify(shardId, signal) {\n    const nonce = Math.random();\n    const payload = {\n      op: 5 /* WaitForIdentify */,\n      nonce,\n      shardId\n    };\n    const promise = new Promise((resolve2, reject) =>\n    // eslint-disable-next-line no-promise-executor-return\n    this.waitForIdentifyPromises.set(nonce, {\n      signal,\n      resolve: resolve2,\n      reject\n    }));\n    import_node_worker_threads2.parentPort.postMessage(payload);\n    const listener = /* @__PURE__ */__name(() => {\n      const payload2 = {\n        op: 8 /* CancelIdentify */,\n        nonce\n      };\n      import_node_worker_threads2.parentPort.postMessage(payload2);\n    }, \"listener\");\n    signal.addEventListener(\"abort\", listener);\n    try {\n      await promise;\n    } finally {\n      signal.removeEventListener(\"abort\", listener);\n    }\n  }\n};\n\n// src/strategies/sharding/SimpleShardingStrategy.ts\nvar import_collection6 = require(\"@discordjs/collection\");\n\n// src/ws/WebSocketShard.ts\nvar import_node_buffer = require(\"buffer\");\nvar import_node_events2 = require(\"events\");\nvar import_node_timers = require(\"timers\");\nvar import_promises2 = require(\"timers/promises\");\nvar import_node_url = require(\"url\");\nvar import_node_util = require(\"util\");\nvar import_node_zlib = require(\"zlib\");\nvar import_collection5 = require(\"@discordjs/collection\");\nvar import_util2 = require(\"@discordjs/util\");\nvar import_async_queue2 = require(\"@sapphire/async-queue\");\nvar import_async_event_emitter = require(\"@vladfrangu/async_event_emitter\");\nvar import_v102 = require(\"discord-api-types/v10\");\nvar import_ws = require(\"ws\");\n\n// src/utils/constants.ts\nvar import_node_process = __toESM(require(\"process\"));\nvar import_collection4 = require(\"@discordjs/collection\");\nvar import_util = require(\"@discordjs/util\");\nvar import_v10 = require(\"discord-api-types/v10\");\n\n// src/throttling/SimpleIdentifyThrottler.ts\nvar import_promises = require(\"timers/promises\");\nvar import_collection3 = require(\"@discordjs/collection\");\nvar import_async_queue = require(\"@sapphire/async-queue\");\nvar SimpleIdentifyThrottler = class {\n  constructor(maxConcurrency) {\n    this.maxConcurrency = maxConcurrency;\n  }\n  static {\n    __name(this, \"SimpleIdentifyThrottler\");\n  }\n  states = new import_collection3.Collection();\n  /**\n   * {@inheritDoc IIdentifyThrottler.waitForIdentify}\n   */\n  async waitForIdentify(shardId, signal) {\n    const key = shardId % this.maxConcurrency;\n    const state = this.states.ensure(key, () => {\n      return {\n        queue: new import_async_queue.AsyncQueue(),\n        resetsAt: Number.POSITIVE_INFINITY\n      };\n    });\n    await state.queue.wait({\n      signal\n    });\n    try {\n      const diff = state.resetsAt - Date.now();\n      if (diff <= 5e3) {\n        const time = diff + Math.random() * 1500;\n        await (0, import_promises.setTimeout)(time);\n      }\n      state.resetsAt = Date.now() + 5e3;\n    } finally {\n      state.queue.shift();\n    }\n  }\n};\n\n// src/utils/constants.ts\nvar Encoding = /* @__PURE__ */(Encoding2 => {\n  Encoding2[\"JSON\"] = \"json\";\n  return Encoding2;\n})(Encoding || {});\nvar CompressionMethod = /* @__PURE__ */(CompressionMethod2 => {\n  CompressionMethod2[\"ZlibStream\"] = \"zlib-stream\";\n  return CompressionMethod2;\n})(CompressionMethod || {});\nvar DefaultDeviceProperty = `@discordjs/ws 1.0.1`;\nvar getDefaultSessionStore = (0, import_util.lazy)(() => new import_collection4.Collection());\nvar DefaultWebSocketManagerOptions = {\n  async buildIdentifyThrottler(manager) {\n    const info = await manager.fetchGatewayInformation();\n    return new SimpleIdentifyThrottler(info.session_start_limit.max_concurrency);\n  },\n  buildStrategy: manager => new SimpleShardingStrategy(manager),\n  shardCount: null,\n  shardIds: null,\n  largeThreshold: null,\n  initialPresence: null,\n  identifyProperties: {\n    browser: DefaultDeviceProperty,\n    device: DefaultDeviceProperty,\n    os: import_node_process.default.platform\n  },\n  version: import_v10.APIVersion,\n  encoding: \"json\" /* JSON */,\n  compression: null,\n  retrieveSessionInfo(shardId) {\n    const store = getDefaultSessionStore();\n    return store.get(shardId) ?? null;\n  },\n  updateSessionInfo(shardId, info) {\n    const store = getDefaultSessionStore();\n    if (info) {\n      store.set(shardId, info);\n    } else {\n      store.delete(shardId);\n    }\n  },\n  handshakeTimeout: 3e4,\n  helloTimeout: 6e4,\n  readyTimeout: 15e3\n};\nvar ImportantGatewayOpcodes = /* @__PURE__ */new Set([import_v10.GatewayOpcodes.Heartbeat, import_v10.GatewayOpcodes.Identify, import_v10.GatewayOpcodes.Resume]);\nfunction getInitialSendRateLimitState() {\n  return {\n    remaining: 120,\n    resetAt: Date.now() + 6e4\n  };\n}\n__name(getInitialSendRateLimitState, \"getInitialSendRateLimitState\");\n\n// src/ws/WebSocketShard.ts\nvar getZlibSync = (0, import_util2.lazy)(async () => import(\"zlib-sync\").then(mod => mod.default).catch(() => null));\nvar WebSocketShardEvents = /* @__PURE__ */(WebSocketShardEvents2 => {\n  WebSocketShardEvents2[\"Closed\"] = \"closed\";\n  WebSocketShardEvents2[\"Debug\"] = \"debug\";\n  WebSocketShardEvents2[\"Dispatch\"] = \"dispatch\";\n  WebSocketShardEvents2[\"Error\"] = \"error\";\n  WebSocketShardEvents2[\"HeartbeatComplete\"] = \"heartbeat\";\n  WebSocketShardEvents2[\"Hello\"] = \"hello\";\n  WebSocketShardEvents2[\"Ready\"] = \"ready\";\n  WebSocketShardEvents2[\"Resumed\"] = \"resumed\";\n  return WebSocketShardEvents2;\n})(WebSocketShardEvents || {});\nvar WebSocketShardStatus = /* @__PURE__ */(WebSocketShardStatus2 => {\n  WebSocketShardStatus2[WebSocketShardStatus2[\"Idle\"] = 0] = \"Idle\";\n  WebSocketShardStatus2[WebSocketShardStatus2[\"Connecting\"] = 1] = \"Connecting\";\n  WebSocketShardStatus2[WebSocketShardStatus2[\"Resuming\"] = 2] = \"Resuming\";\n  WebSocketShardStatus2[WebSocketShardStatus2[\"Ready\"] = 3] = \"Ready\";\n  return WebSocketShardStatus2;\n})(WebSocketShardStatus || {});\nvar WebSocketShardDestroyRecovery = /* @__PURE__ */(WebSocketShardDestroyRecovery2 => {\n  WebSocketShardDestroyRecovery2[WebSocketShardDestroyRecovery2[\"Reconnect\"] = 0] = \"Reconnect\";\n  WebSocketShardDestroyRecovery2[WebSocketShardDestroyRecovery2[\"Resume\"] = 1] = \"Resume\";\n  return WebSocketShardDestroyRecovery2;\n})(WebSocketShardDestroyRecovery || {});\nvar CloseCodes = /* @__PURE__ */(CloseCodes2 => {\n  CloseCodes2[CloseCodes2[\"Normal\"] = 1e3] = \"Normal\";\n  CloseCodes2[CloseCodes2[\"Resuming\"] = 4200] = \"Resuming\";\n  return CloseCodes2;\n})(CloseCodes || {});\nvar WebSocketConstructor = import_ws.WebSocket;\nvar WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter {\n  static {\n    __name(this, \"WebSocketShard\");\n  }\n  connection = null;\n  useIdentifyCompress = false;\n  inflate = null;\n  textDecoder = new import_node_util.TextDecoder();\n  replayedEvents = 0;\n  isAck = true;\n  sendRateLimitState = getInitialSendRateLimitState();\n  initialHeartbeatTimeoutController = null;\n  heartbeatInterval = null;\n  lastHeartbeatAt = -1;\n  // Indicates whether the shard has already resolved its original connect() call\n  initialConnectResolved = false;\n  // Indicates if we failed to connect to the ws url (ECONNREFUSED/ECONNRESET)\n  failedToConnectDueToNetworkError = false;\n  sendQueue = new import_async_queue2.AsyncQueue();\n  timeoutAbortControllers = new import_collection5.Collection();\n  strategy;\n  id;\n  #status = 0 /* Idle */;\n  get status() {\n    return this.#status;\n  }\n  constructor(strategy, id) {\n    super();\n    this.strategy = strategy;\n    this.id = id;\n  }\n  async connect() {\n    const controller = new AbortController();\n    let promise;\n    if (!this.initialConnectResolved) {\n      promise = Promise.race([(0, import_node_events2.once)(this, \"ready\" /* Ready */, {\n        signal: controller.signal\n      }), (0, import_node_events2.once)(this, \"resumed\" /* Resumed */, {\n        signal: controller.signal\n      })]);\n    }\n    void this.internalConnect();\n    try {\n      await promise;\n    } catch ({\n      error\n    }) {\n      throw error;\n    } finally {\n      controller.abort();\n    }\n    this.initialConnectResolved = true;\n  }\n  async internalConnect() {\n    if (this.#status !== 0 /* Idle */) {\n      throw new Error(\"Tried to connect a shard that wasn't idle\");\n    }\n    const {\n      version: version2,\n      encoding,\n      compression\n    } = this.strategy.options;\n    const params = new import_node_url.URLSearchParams({\n      v: version2,\n      encoding\n    });\n    if (compression) {\n      const zlib = await getZlibSync();\n      if (zlib) {\n        params.append(\"compress\", compression);\n        this.inflate = new zlib.Inflate({\n          chunkSize: 65535,\n          to: \"string\"\n        });\n      } else if (!this.useIdentifyCompress) {\n        this.useIdentifyCompress = true;\n        console.warn(\"WebSocketShard: Compression is enabled but zlib-sync is not installed, falling back to identify compress\");\n      }\n    }\n    const session = await this.strategy.retrieveSessionInfo(this.id);\n    const url = `${session?.resumeURL ?? this.strategy.options.gatewayInformation.url}?${params.toString()}`;\n    this.debug([`Connecting to ${url}`]);\n    const connection = new WebSocketConstructor(url, {\n      handshakeTimeout: this.strategy.options.handshakeTimeout ?? void 0\n    });\n    connection.binaryType = \"arraybuffer\";\n    connection.onmessage = event => {\n      void this.onMessage(event.data, event.data instanceof ArrayBuffer);\n    };\n    connection.onerror = event => {\n      this.onError(event.error);\n    };\n    connection.onclose = event => {\n      void this.onClose(event.code);\n    };\n    this.connection = connection;\n    this.#status = 1 /* Connecting */;\n    this.sendRateLimitState = getInitialSendRateLimitState();\n    const {\n      ok\n    } = await this.waitForEvent(\"hello\" /* Hello */, this.strategy.options.helloTimeout);\n    if (!ok) {\n      return;\n    }\n    if (session?.shardCount === this.strategy.options.shardCount) {\n      await this.resume(session);\n    } else {\n      await this.identify();\n    }\n  }\n  async destroy(options = {}) {\n    if (this.#status === 0 /* Idle */) {\n      this.debug([\"Tried to destroy a shard that was idle\"]);\n      return;\n    }\n    if (!options.code) {\n      options.code = options.recover === 1 /* Resume */ ? 4200 /* Resuming */ : 1e3 /* Normal */;\n    }\n    this.debug([\"Destroying shard\", `Reason: ${options.reason ?? \"none\"}`, `Code: ${options.code}`, `Recover: ${options.recover === void 0 ? \"none\" : WebSocketShardDestroyRecovery[options.recover]}`]);\n    this.isAck = true;\n    if (this.heartbeatInterval) {\n      (0, import_node_timers.clearInterval)(this.heartbeatInterval);\n    }\n    if (this.initialHeartbeatTimeoutController) {\n      this.initialHeartbeatTimeoutController.abort();\n      this.initialHeartbeatTimeoutController = null;\n    }\n    this.lastHeartbeatAt = -1;\n    for (const controller of this.timeoutAbortControllers.values()) {\n      controller.abort();\n    }\n    this.timeoutAbortControllers.clear();\n    this.failedToConnectDueToNetworkError = false;\n    if (options.recover !== 1 /* Resume */) {\n      await this.strategy.updateSessionInfo(this.id, null);\n    }\n    if (this.connection) {\n      this.connection.onmessage = null;\n      this.connection.onclose = null;\n      const shouldClose = this.connection.readyState === import_ws.WebSocket.OPEN;\n      this.debug([\"Connection status during destroy\", `Needs closing: ${shouldClose}`, `Ready state: ${this.connection.readyState}`]);\n      if (shouldClose) {\n        let outerResolve;\n        const promise = new Promise(resolve2 => {\n          outerResolve = resolve2;\n        });\n        this.connection.onclose = outerResolve;\n        this.connection.close(options.code, options.reason);\n        await promise;\n        this.emit(\"closed\" /* Closed */, {\n          code: options.code\n        });\n      }\n      this.connection.onerror = null;\n    } else {\n      this.debug([\"Destroying a shard that has no connection; please open an issue on GitHub\"]);\n    }\n    this.#status = 0 /* Idle */;\n    if (options.recover !== void 0) {\n      await (0, import_promises2.setTimeout)(500);\n      return this.internalConnect();\n    }\n  }\n  async waitForEvent(event, timeoutDuration) {\n    this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : \"indefinitely\"}`]);\n    const timeoutController = new AbortController();\n    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => timeoutController.abort(), timeoutDuration).unref() : null;\n    this.timeoutAbortControllers.set(event, timeoutController);\n    const closeController = new AbortController();\n    try {\n      const closed = await Promise.race([(0, import_node_events2.once)(this, event, {\n        signal: timeoutController.signal\n      }).then(() => false), (0, import_node_events2.once)(this, \"closed\" /* Closed */, {\n        signal: closeController.signal\n      }).then(() => true)]);\n      return {\n        ok: !closed\n      };\n    } catch {\n      void this.destroy({\n        code: 1e3 /* Normal */,\n        reason: \"Something timed out or went wrong while waiting for an event\",\n        recover: 0 /* Reconnect */\n      });\n      return {\n        ok: false\n      };\n    } finally {\n      if (timeout) {\n        (0, import_node_timers.clearTimeout)(timeout);\n      }\n      this.timeoutAbortControllers.delete(event);\n      if (!closeController.signal.aborted) {\n        closeController.abort();\n      }\n    }\n  }\n  async send(payload) {\n    if (!this.connection) {\n      throw new Error(\"WebSocketShard wasn't connected\");\n    }\n    if (this.#status !== 3 /* Ready */ && !ImportantGatewayOpcodes.has(payload.op)) {\n      this.debug([\"Tried to send a non-crucial payload before the shard was ready, waiting\"]);\n      try {\n        await (0, import_node_events2.once)(this, \"ready\" /* Ready */);\n      } catch {\n        return this.send(payload);\n      }\n    }\n    await this.sendQueue.wait();\n    if (--this.sendRateLimitState.remaining <= 0) {\n      const now = Date.now();\n      if (this.sendRateLimitState.resetAt > now) {\n        const sleepFor = this.sendRateLimitState.resetAt - now;\n        this.debug([`Was about to hit the send rate limit, sleeping for ${sleepFor}ms`]);\n        const controller = new AbortController();\n        const interrupted = await Promise.race([(0, import_promises2.setTimeout)(sleepFor).then(() => false), (0, import_node_events2.once)(this, \"closed\" /* Closed */, {\n          signal: controller.signal\n        }).then(() => true)]);\n        if (interrupted) {\n          this.debug([\"Connection closed while waiting for the send rate limit to reset, re-queueing payload\"]);\n          this.sendQueue.shift();\n          return this.send(payload);\n        }\n        controller.abort();\n      }\n      this.sendRateLimitState = getInitialSendRateLimitState();\n    }\n    this.sendQueue.shift();\n    this.connection.send(JSON.stringify(payload));\n  }\n  async identify() {\n    this.debug([\"Waiting for identify throttle\"]);\n    const controller = new AbortController();\n    const closeHandler = /* @__PURE__ */__name(() => {\n      controller.abort();\n    }, \"closeHandler\");\n    this.on(\"closed\" /* Closed */, closeHandler);\n    try {\n      await this.strategy.waitForIdentify(this.id, controller.signal);\n    } catch {\n      if (controller.signal.aborted) {\n        this.debug([\"Was waiting for an identify, but the shard closed in the meantime\"]);\n        return;\n      }\n      this.debug([\"IContextFetchingStrategy#waitForIdentify threw an unknown error.\", \"If you're using a custom strategy, this is probably nothing to worry about.\", \"If you're not, please open an issue on GitHub.\"]);\n      await this.destroy({\n        reason: \"Identify throttling logic failed\",\n        recover: 1 /* Resume */\n      });\n    } finally {\n      this.off(\"closed\" /* Closed */, closeHandler);\n    }\n    this.debug([\"Identifying\", `shard id: ${this.id.toString()}`, `shard count: ${this.strategy.options.shardCount}`, `intents: ${this.strategy.options.intents}`, `compression: ${this.inflate ? \"zlib-stream\" : this.useIdentifyCompress ? \"identify\" : \"none\"}`]);\n    const d = {\n      token: this.strategy.options.token,\n      properties: this.strategy.options.identifyProperties,\n      intents: this.strategy.options.intents,\n      compress: this.useIdentifyCompress,\n      shard: [this.id, this.strategy.options.shardCount]\n    };\n    if (this.strategy.options.largeThreshold) {\n      d.large_threshold = this.strategy.options.largeThreshold;\n    }\n    if (this.strategy.options.initialPresence) {\n      d.presence = this.strategy.options.initialPresence;\n    }\n    await this.send({\n      op: import_v102.GatewayOpcodes.Identify,\n      d\n    });\n    await this.waitForEvent(\"ready\" /* Ready */, this.strategy.options.readyTimeout);\n  }\n  async resume(session) {\n    this.debug([\"Resuming session\", `resume url: ${session.resumeURL}`, `sequence: ${session.sequence}`, `shard id: ${this.id.toString()}`]);\n    this.#status = 2 /* Resuming */;\n    this.replayedEvents = 0;\n    return this.send({\n      op: import_v102.GatewayOpcodes.Resume,\n      d: {\n        token: this.strategy.options.token,\n        seq: session.sequence,\n        session_id: session.sessionId\n      }\n    });\n  }\n  async heartbeat(requested = false) {\n    if (!this.isAck && !requested) {\n      return this.destroy({\n        reason: \"Zombie connection\",\n        recover: 1 /* Resume */\n      });\n    }\n    const session = await this.strategy.retrieveSessionInfo(this.id);\n    await this.send({\n      op: import_v102.GatewayOpcodes.Heartbeat,\n      d: session?.sequence ?? null\n    });\n    this.lastHeartbeatAt = Date.now();\n    this.isAck = false;\n  }\n  async unpackMessage(data, isBinary) {\n    if (!isBinary) {\n      try {\n        return JSON.parse(data);\n      } catch {\n        return null;\n      }\n    }\n    const decompressable = new Uint8Array(data);\n    if (this.useIdentifyCompress) {\n      return new Promise((resolve2, reject) => {\n        (0, import_node_zlib.inflate)(decompressable, {\n          chunkSize: 65535\n        }, (err, result) => {\n          if (err) {\n            reject(err);\n            return;\n          }\n          resolve2(JSON.parse(this.textDecoder.decode(result)));\n        });\n      });\n    }\n    if (this.inflate) {\n      const l = decompressable.length;\n      const flush = l >= 4 && decompressable[l - 4] === 0 && decompressable[l - 3] === 0 && decompressable[l - 2] === 255 && decompressable[l - 1] === 255;\n      const zlib = await getZlibSync();\n      this.inflate.push(import_node_buffer.Buffer.from(decompressable), flush ? zlib.Z_SYNC_FLUSH : zlib.Z_NO_FLUSH);\n      if (this.inflate.err) {\n        this.emit(\"error\" /* Error */, {\n          error: new Error(`${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : \"\"}`)\n        });\n      }\n      if (!flush) {\n        return null;\n      }\n      const {\n        result\n      } = this.inflate;\n      if (!result) {\n        return null;\n      }\n      return JSON.parse(typeof result === \"string\" ? result : this.textDecoder.decode(result));\n    }\n    this.debug([\"Received a message we were unable to decompress\", `isBinary: ${isBinary.toString()}`, `useIdentifyCompress: ${this.useIdentifyCompress.toString()}`, `inflate: ${Boolean(this.inflate).toString()}`]);\n    return null;\n  }\n  async onMessage(data, isBinary) {\n    const payload = await this.unpackMessage(data, isBinary);\n    if (!payload) {\n      return;\n    }\n    switch (payload.op) {\n      case import_v102.GatewayOpcodes.Dispatch:\n        {\n          if (this.#status === 2 /* Resuming */) {\n            this.replayedEvents++;\n          }\n          switch (payload.t) {\n            case import_v102.GatewayDispatchEvents.Ready:\n              {\n                this.#status = 3 /* Ready */;\n                const session2 = {\n                  sequence: payload.s,\n                  sessionId: payload.d.session_id,\n                  shardId: this.id,\n                  shardCount: this.strategy.options.shardCount,\n                  resumeURL: payload.d.resume_gateway_url\n                };\n                await this.strategy.updateSessionInfo(this.id, session2);\n                this.emit(\"ready\" /* Ready */, {\n                  data: payload.d\n                });\n                break;\n              }\n            case import_v102.GatewayDispatchEvents.Resumed:\n              {\n                this.#status = 3 /* Ready */;\n                this.debug([`Resumed and replayed ${this.replayedEvents} events`]);\n                this.emit(\"resumed\" /* Resumed */);\n                break;\n              }\n            default:\n              {\n                break;\n              }\n          }\n          const session = await this.strategy.retrieveSessionInfo(this.id);\n          if (session) {\n            if (payload.s > session.sequence) {\n              await this.strategy.updateSessionInfo(this.id, {\n                ...session,\n                sequence: payload.s\n              });\n            }\n          } else {\n            this.debug([`Received a ${payload.t} event but no session is available. Session information cannot be re-constructed in this state without a full reconnect`]);\n          }\n          this.emit(\"dispatch\" /* Dispatch */, {\n            data: payload\n          });\n          break;\n        }\n      case import_v102.GatewayOpcodes.Heartbeat:\n        {\n          await this.heartbeat(true);\n          break;\n        }\n      case import_v102.GatewayOpcodes.Reconnect:\n        {\n          await this.destroy({\n            reason: \"Told to reconnect by Discord\",\n            recover: 1 /* Resume */\n          });\n          break;\n        }\n      case import_v102.GatewayOpcodes.InvalidSession:\n        {\n          this.debug([`Invalid session; will attempt to resume: ${payload.d.toString()}`]);\n          const session = await this.strategy.retrieveSessionInfo(this.id);\n          if (payload.d && session) {\n            await this.resume(session);\n          } else {\n            await this.destroy({\n              reason: \"Invalid session\",\n              recover: 0 /* Reconnect */\n            });\n          }\n          break;\n        }\n      case import_v102.GatewayOpcodes.Hello:\n        {\n          this.emit(\"hello\" /* Hello */);\n          const jitter = Math.random();\n          const firstWait = Math.floor(payload.d.heartbeat_interval * jitter);\n          this.debug([`Preparing first heartbeat of the connection with a jitter of ${jitter}; waiting ${firstWait}ms`]);\n          try {\n            const controller = new AbortController();\n            this.initialHeartbeatTimeoutController = controller;\n            await (0, import_promises2.setTimeout)(firstWait, void 0, {\n              signal: controller.signal\n            });\n          } catch {\n            this.debug([\"Cancelled initial heartbeat due to #destroy being called\"]);\n            return;\n          } finally {\n            this.initialHeartbeatTimeoutController = null;\n          }\n          await this.heartbeat();\n          this.debug([`First heartbeat sent, starting to beat every ${payload.d.heartbeat_interval}ms`]);\n          this.heartbeatInterval = (0, import_node_timers.setInterval)(() => void this.heartbeat(), payload.d.heartbeat_interval);\n          break;\n        }\n      case import_v102.GatewayOpcodes.HeartbeatAck:\n        {\n          this.isAck = true;\n          const ackAt = Date.now();\n          this.emit(\"heartbeat\" /* HeartbeatComplete */, {\n            ackAt,\n            heartbeatAt: this.lastHeartbeatAt,\n            latency: ackAt - this.lastHeartbeatAt\n          });\n          break;\n        }\n    }\n  }\n  onError(error) {\n    if (\"code\" in error && [\"ECONNRESET\", \"ECONNREFUSED\"].includes(error.code)) {\n      this.debug([\"Failed to connect to the gateway URL specified due to a network error\"]);\n      this.failedToConnectDueToNetworkError = true;\n      return;\n    }\n    this.emit(\"error\" /* Error */, {\n      error\n    });\n  }\n  async onClose(code) {\n    this.emit(\"closed\" /* Closed */, {\n      code\n    });\n    switch (code) {\n      case 1e3 /* Normal */:\n        {\n          return this.destroy({\n            code,\n            reason: \"Got disconnected by Discord\",\n            recover: 0 /* Reconnect */\n          });\n        }\n      case 4200 /* Resuming */:\n        {\n          break;\n        }\n      case import_v102.GatewayCloseCodes.UnknownError:\n        {\n          this.debug([`An unknown error occurred: ${code}`]);\n          return this.destroy({\n            code,\n            recover: 1 /* Resume */\n          });\n        }\n      case import_v102.GatewayCloseCodes.UnknownOpcode:\n        {\n          this.debug([\"An invalid opcode was sent to Discord.\"]);\n          return this.destroy({\n            code,\n            recover: 1 /* Resume */\n          });\n        }\n      case import_v102.GatewayCloseCodes.DecodeError:\n        {\n          this.debug([\"An invalid payload was sent to Discord.\"]);\n          return this.destroy({\n            code,\n            recover: 1 /* Resume */\n          });\n        }\n      case import_v102.GatewayCloseCodes.NotAuthenticated:\n        {\n          this.debug([\"A request was somehow sent before the identify/resume payload.\"]);\n          return this.destroy({\n            code,\n            recover: 0 /* Reconnect */\n          });\n        }\n      case import_v102.GatewayCloseCodes.AuthenticationFailed:\n        {\n          this.emit(\"error\" /* Error */, {\n            error: new Error(\"Authentication failed\")\n          });\n          return this.destroy({\n            code\n          });\n        }\n      case import_v102.GatewayCloseCodes.AlreadyAuthenticated:\n        {\n          this.debug([\"More than one auth payload was sent.\"]);\n          return this.destroy({\n            code,\n            recover: 0 /* Reconnect */\n          });\n        }\n      case import_v102.GatewayCloseCodes.InvalidSeq:\n        {\n          this.debug([\"An invalid sequence was sent.\"]);\n          return this.destroy({\n            code,\n            recover: 0 /* Reconnect */\n          });\n        }\n      case import_v102.GatewayCloseCodes.RateLimited:\n        {\n          this.debug([\"The WebSocket rate limit has been hit, this should never happen\"]);\n          return this.destroy({\n            code,\n            recover: 0 /* Reconnect */\n          });\n        }\n      case import_v102.GatewayCloseCodes.SessionTimedOut:\n        {\n          this.debug([\"Session timed out.\"]);\n          return this.destroy({\n            code,\n            recover: 1 /* Resume */\n          });\n        }\n      case import_v102.GatewayCloseCodes.InvalidShard:\n        {\n          this.emit(\"error\" /* Error */, {\n            error: new Error(\"Invalid shard\")\n          });\n          return this.destroy({\n            code\n          });\n        }\n      case import_v102.GatewayCloseCodes.ShardingRequired:\n        {\n          this.emit(\"error\" /* Error */, {\n            error: new Error(\"Sharding is required\")\n          });\n          return this.destroy({\n            code\n          });\n        }\n      case import_v102.GatewayCloseCodes.InvalidAPIVersion:\n        {\n          this.emit(\"error\" /* Error */, {\n            error: new Error(\"Used an invalid API version\")\n          });\n          return this.destroy({\n            code\n          });\n        }\n      case import_v102.GatewayCloseCodes.InvalidIntents:\n        {\n          this.emit(\"error\" /* Error */, {\n            error: new Error(\"Used invalid intents\")\n          });\n          return this.destroy({\n            code\n          });\n        }\n      case import_v102.GatewayCloseCodes.DisallowedIntents:\n        {\n          this.emit(\"error\" /* Error */, {\n            error: new Error(\"Used disallowed intents\")\n          });\n          return this.destroy({\n            code\n          });\n        }\n      default:\n        {\n          this.debug([`The gateway closed with an unexpected code ${code}, attempting to ${this.failedToConnectDueToNetworkError ? \"reconnect\" : \"resume\"}.`]);\n          return this.destroy({\n            code,\n            recover: this.failedToConnectDueToNetworkError ? 0 /* Reconnect */ : 1 /* Resume */\n          });\n        }\n    }\n  }\n  debug(messages) {\n    const message = `${messages[0]}${messages.length > 1 ? `\n${messages.slice(1).map(m => `\t${m}`).join(\"\\n\")}` : \"\"}`;\n    this.emit(\"debug\" /* Debug */, {\n      message\n    });\n  }\n};\n\n// src/strategies/sharding/SimpleShardingStrategy.ts\nvar SimpleShardingStrategy = class {\n  static {\n    __name(this, \"SimpleShardingStrategy\");\n  }\n  manager;\n  shards = new import_collection6.Collection();\n  constructor(manager) {\n    this.manager = manager;\n  }\n  /**\n   * {@inheritDoc IShardingStrategy.spawn}\n   */\n  async spawn(shardIds) {\n    const strategyOptions = await managerToFetchingStrategyOptions(this.manager);\n    for (const shardId of shardIds) {\n      const strategy = new SimpleContextFetchingStrategy(this.manager, strategyOptions);\n      const shard = new WebSocketShard(strategy, shardId);\n      for (const event of Object.values(WebSocketShardEvents)) {\n        shard.on(event, payload => this.manager.emit(event, {\n          ...payload,\n          shardId\n        }));\n      }\n      this.shards.set(shardId, shard);\n    }\n  }\n  /**\n   * {@inheritDoc IShardingStrategy.connect}\n   */\n  async connect() {\n    const promises = [];\n    for (const shard of this.shards.values()) {\n      promises.push(shard.connect());\n    }\n    await Promise.all(promises);\n  }\n  /**\n   * {@inheritDoc IShardingStrategy.destroy}\n   */\n  async destroy(options) {\n    const promises = [];\n    for (const shard of this.shards.values()) {\n      promises.push(shard.destroy(options));\n    }\n    await Promise.all(promises);\n    this.shards.clear();\n  }\n  /**\n   * {@inheritDoc IShardingStrategy.send}\n   */\n  async send(shardId, payload) {\n    const shard = this.shards.get(shardId);\n    if (!shard) {\n      throw new RangeError(`Shard ${shardId} not found`);\n    }\n    return shard.send(payload);\n  }\n  /**\n   * {@inheritDoc IShardingStrategy.fetchStatus}\n   */\n  async fetchStatus() {\n    return this.shards.mapValues(shard => shard.status);\n  }\n};\n\n// src/utils/WorkerBootstrapper.ts\nvar import_node_worker_threads3 = require(\"worker_threads\");\nvar import_collection7 = require(\"@discordjs/collection\");\nvar WorkerBootstrapper = class {\n  static {\n    __name(this, \"WorkerBootstrapper\");\n  }\n  /**\n   * The data passed to the worker thread\n   */\n  data = import_node_worker_threads3.workerData;\n  /**\n   * The shards that are managed by this worker\n   */\n  shards = new import_collection7.Collection();\n  constructor() {\n    if (import_node_worker_threads3.isMainThread) {\n      throw new Error(\"Expected WorkerBootstrap to not be used within the main thread\");\n    }\n  }\n  /**\n   * Helper method to initiate a shard's connection process\n   */\n  async connect(shardId) {\n    const shard = this.shards.get(shardId);\n    if (!shard) {\n      throw new RangeError(`Shard ${shardId} does not exist`);\n    }\n    await shard.connect();\n  }\n  /**\n   * Helper method to destroy a shard\n   */\n  async destroy(shardId, options) {\n    const shard = this.shards.get(shardId);\n    if (!shard) {\n      throw new RangeError(`Shard ${shardId} does not exist`);\n    }\n    await shard.destroy(options);\n  }\n  /**\n   * Helper method to attach event listeners to the parentPort\n   */\n  setupThreadEvents() {\n    import_node_worker_threads3.parentPort.on(\"messageerror\", err => {\n      throw err;\n    }).on(\"message\", async payload => {\n      switch (payload.op) {\n        case 0 /* Connect */:\n          {\n            await this.connect(payload.shardId);\n            const response = {\n              op: 0 /* Connected */,\n              shardId: payload.shardId\n            };\n            import_node_worker_threads3.parentPort.postMessage(response);\n            break;\n          }\n        case 1 /* Destroy */:\n          {\n            await this.destroy(payload.shardId, payload.options);\n            const response = {\n              op: 1 /* Destroyed */,\n              shardId: payload.shardId\n            };\n            import_node_worker_threads3.parentPort.postMessage(response);\n            break;\n          }\n        case 2 /* Send */:\n          {\n            const shard = this.shards.get(payload.shardId);\n            if (!shard) {\n              throw new RangeError(`Shard ${payload.shardId} does not exist`);\n            }\n            await shard.send(payload.payload);\n            break;\n          }\n        case 3 /* SessionInfoResponse */:\n          {\n            break;\n          }\n        case 4 /* ShardIdentifyResponse */:\n          {\n            break;\n          }\n        case 5 /* FetchStatus */:\n          {\n            const shard = this.shards.get(payload.shardId);\n            if (!shard) {\n              throw new Error(`Shard ${payload.shardId} does not exist`);\n            }\n            const response = {\n              op: 6 /* FetchStatusResponse */,\n              status: shard.status,\n              nonce: payload.nonce\n            };\n            import_node_worker_threads3.parentPort.postMessage(response);\n            break;\n          }\n      }\n    });\n  }\n  /**\n   * Bootstraps the worker thread with the provided options\n   */\n  async bootstrap(options = {}) {\n    for (const shardId of this.data.shardIds) {\n      const shard = new WebSocketShard(new WorkerContextFetchingStrategy(this.data), shardId);\n      for (const event of options.forwardEvents ?? Object.values(WebSocketShardEvents)) {\n        shard.on(event, data => {\n          const payload = {\n            op: 2 /* Event */,\n            event,\n            data,\n            shardId\n          };\n          import_node_worker_threads3.parentPort.postMessage(payload);\n        });\n      }\n      await options.shardCallback?.(shard);\n      this.shards.set(shardId, shard);\n    }\n    this.setupThreadEvents();\n    const message = {\n      op: 7 /* WorkerReady */\n    };\n    import_node_worker_threads3.parentPort.postMessage(message);\n  }\n};\n\n// src/ws/WebSocketManager.ts\nvar import_util3 = require(\"@discordjs/util\");\nvar import_async_event_emitter2 = require(\"@vladfrangu/async_event_emitter\");\nvar import_v103 = require(\"discord-api-types/v10\");\nvar WebSocketManager = class extends import_async_event_emitter2.AsyncEventEmitter {\n  static {\n    __name(this, \"WebSocketManager\");\n  }\n  /**\n   * The options being used by this manager\n   */\n  options;\n  /**\n   * Internal cache for a GET /gateway/bot result\n   */\n  gatewayInformation = null;\n  /**\n   * Internal cache for the shard ids\n   */\n  shardIds = null;\n  /**\n   * Strategy used to manage shards\n   *\n   * @defaultValue `SimpleShardingStrategy`\n   */\n  strategy;\n  constructor(options) {\n    super();\n    this.options = {\n      ...DefaultWebSocketManagerOptions,\n      ...options\n    };\n    this.strategy = this.options.buildStrategy(this);\n  }\n  /**\n   * Fetches the gateway information from Discord - or returns it from cache if available\n   *\n   * @param force - Whether to ignore the cache and force a fresh fetch\n   */\n  async fetchGatewayInformation(force = false) {\n    if (this.gatewayInformation) {\n      if (this.gatewayInformation.expiresAt <= Date.now()) {\n        this.gatewayInformation = null;\n      } else if (!force) {\n        return this.gatewayInformation.data;\n      }\n    }\n    const data = await this.options.rest.get(import_v103.Routes.gatewayBot());\n    this.gatewayInformation = {\n      data,\n      expiresAt: Date.now() + (data.session_start_limit.reset_after || 5e3)\n    };\n    return this.gatewayInformation.data;\n  }\n  /**\n   * Updates your total shard count on-the-fly, spawning shards as needed\n   *\n   * @param shardCount - The new shard count to use\n   */\n  async updateShardCount(shardCount) {\n    await this.strategy.destroy({\n      reason: \"User is adjusting their shards\"\n    });\n    this.options.shardCount = shardCount;\n    const shardIds = await this.getShardIds(true);\n    await this.strategy.spawn(shardIds);\n    return this;\n  }\n  /**\n   * Yields the total number of shards across for your bot, accounting for Discord recommendations\n   */\n  async getShardCount() {\n    if (this.options.shardCount) {\n      return this.options.shardCount;\n    }\n    const shardIds = await this.getShardIds();\n    return Math.max(...shardIds) + 1;\n  }\n  /**\n   * Yields the ids of the shards this manager should manage\n   */\n  async getShardIds(force = false) {\n    if (this.shardIds && !force) {\n      return this.shardIds;\n    }\n    let shardIds;\n    if (this.options.shardIds) {\n      if (Array.isArray(this.options.shardIds)) {\n        shardIds = this.options.shardIds;\n      } else {\n        const {\n          start,\n          end\n        } = this.options.shardIds;\n        shardIds = [...(0, import_util3.range)({\n          start,\n          end: end + 1\n        })];\n      }\n    } else {\n      const data = await this.fetchGatewayInformation();\n      shardIds = [...(0, import_util3.range)(this.options.shardCount ?? data.shards)];\n    }\n    this.shardIds = shardIds;\n    return shardIds;\n  }\n  async connect() {\n    const shardCount = await this.getShardCount();\n    const data = await this.fetchGatewayInformation();\n    if (data.session_start_limit.remaining < shardCount) {\n      throw new Error(`Not enough sessions remaining to spawn ${shardCount} shards; only ${data.session_start_limit.remaining} remaining; resets at ${new Date(Date.now() + data.session_start_limit.reset_after).toISOString()}`);\n    }\n    await this.updateShardCount(shardCount);\n    await this.strategy.connect();\n  }\n  destroy(options) {\n    return this.strategy.destroy(options);\n  }\n  send(shardId, payload) {\n    return this.strategy.send(shardId, payload);\n  }\n  fetchStatus() {\n    return this.strategy.fetchStatus();\n  }\n};\n\n// src/index.ts\nvar version = \"1.0.1\";\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  CloseCodes,\n  CompressionMethod,\n  DefaultDeviceProperty,\n  DefaultWebSocketManagerOptions,\n  Encoding,\n  ImportantGatewayOpcodes,\n  SimpleContextFetchingStrategy,\n  SimpleIdentifyThrottler,\n  SimpleShardingStrategy,\n  WebSocketManager,\n  WebSocketShard,\n  WebSocketShardDestroyRecovery,\n  WebSocketShardEvents,\n  WebSocketShardStatus,\n  WorkerBootstrapper,\n  WorkerContextFetchingStrategy,\n  WorkerReceivePayloadOp,\n  WorkerSendPayloadOp,\n  WorkerShardingStrategy,\n  getInitialSendRateLimitState,\n  managerToFetchingStrategyOptions,\n  version\n});","map":{"version":3,"names":["src_exports","__export","CloseCodes","CompressionMethod","DefaultDeviceProperty","DefaultWebSocketManagerOptions","Encoding","ImportantGatewayOpcodes","SimpleContextFetchingStrategy","SimpleIdentifyThrottler","SimpleShardingStrategy","WebSocketManager","WebSocketShard","WebSocketShardDestroyRecovery","WebSocketShardEvents","WebSocketShardStatus","WorkerBootstrapper","WorkerContextFetchingStrategy","WorkerReceivePayloadOp","WorkerSendPayloadOp","WorkerShardingStrategy","getInitialSendRateLimitState","managerToFetchingStrategyOptions","version","module","exports","__toCommonJS","manager","buildIdentifyThrottler","buildStrategy","retrieveSessionInfo","updateSessionInfo","shardCount","shardIds","rest","managerOptions","options","gatewayInformation","fetchGatewayInformation","getShardCount","__name","_SimpleContextFetchingStrategy","constructor","throttlerCache","WeakMap","ensureThrottler","throttler","get","newThrottler","set","shardId","sessionInfo","waitForIdentify","signal","import_node_worker_threads2","require","import_collection2","import_node_events","import_node_path","import_node_worker_threads","import_collection","WorkerSendPayloadOp2","WorkerReceivePayloadOp2","workers","workerByShardId","Collection","connectPromises","destroyPromises","fetchStatusPromises","waitForIdentifyControllers","spawn","shardsPerWorker","length","strategyOptions","loops","Math","ceil","promises","idx","slice","workerData2","push","setupWorker","Promise","all","connect","worker","entries","payload","op","promise","resolve2","postMessage","destroy","then","terminate","clear","send","data","Error","fetchStatus","statuses","nonce","random","status","Worker","resolveWorkerPath","workerData","once","waitForWorkerReady","on","err","onMessage","path","workerPath","join","__dirname","isAbsolute","test","resolve","handler","off","delete","emit","event","session","response","controller","AbortController","ok","abort","isMainThread","parentPort","sessionPromises","waitForIdentifyPromises","reject","reason","listener","payload2","addEventListener","removeEventListener","import_collection6","import_node_buffer","import_node_events2","import_node_timers","import_promises2","import_node_url","import_node_util","import_node_zlib","import_collection5","import_util2","import_async_queue2","import_async_event_emitter","import_v102","import_ws","import_node_process","__toESM","import_collection4","import_util","import_v10","import_promises","import_collection3","import_async_queue","maxConcurrency","states","key","state","ensure","queue","AsyncQueue","resetsAt","Number","POSITIVE_INFINITY","wait","diff","Date","now","time","setTimeout","shift","Encoding2","CompressionMethod2","getDefaultSessionStore","lazy","info","session_start_limit","max_concurrency","largeThreshold","initialPresence","identifyProperties","browser","device","os","default","platform","APIVersion","encoding","compression","store","handshakeTimeout","helloTimeout","readyTimeout","Set","GatewayOpcodes","Heartbeat","Identify","Resume","remaining","resetAt","getZlibSync","mod","catch","WebSocketShardEvents2","WebSocketShardStatus2","WebSocketShardDestroyRecovery2","CloseCodes2","WebSocketConstructor","WebSocket","AsyncEventEmitter","connection","useIdentifyCompress","inflate","textDecoder","TextDecoder","replayedEvents","isAck","sendRateLimitState","initialHeartbeatTimeoutController","heartbeatInterval","lastHeartbeatAt","initialConnectResolved","failedToConnectDueToNetworkError","sendQueue","timeoutAbortControllers","strategy","id","race","internalConnect","error","version2","params","URLSearchParams","v","zlib","append","Inflate","chunkSize","to","console","warn","url","resumeURL","toString","debug","binaryType","onmessage","ArrayBuffer","onerror","onError","onclose","onClose","code","waitForEvent","resume","identify","recover","clearInterval","values","shouldClose","readyState","OPEN","outerResolve","close","timeoutDuration","timeoutController","timeout","unref","closeController","closed","clearTimeout","aborted","has","sleepFor","interrupted","JSON","stringify","closeHandler","intents","d","token","properties","compress","shard","large_threshold","presence","sequence","seq","session_id","sessionId","heartbeat","requested","unpackMessage","isBinary","parse","decompressable","Uint8Array","result","decode","l","flush","Buffer","from","Z_SYNC_FLUSH","Z_NO_FLUSH","msg","Boolean","Dispatch","t","GatewayDispatchEvents","Ready","session2","s","resume_gateway_url","Resumed","Reconnect","InvalidSession","Hello","jitter","firstWait","floor","heartbeat_interval","setInterval","HeartbeatAck","ackAt","heartbeatAt","latency","includes","GatewayCloseCodes","UnknownError","UnknownOpcode","DecodeError","NotAuthenticated","AuthenticationFailed","AlreadyAuthenticated","InvalidSeq","RateLimited","SessionTimedOut","InvalidShard","ShardingRequired","InvalidAPIVersion","InvalidIntents","DisallowedIntents","messages","message","map","m","shards","Object","RangeError","mapValues","import_node_worker_threads3","import_collection7","setupThreadEvents","bootstrap","forwardEvents","shardCallback","import_util3","import_async_event_emitter2","import_v103","force","expiresAt","Routes","gatewayBot","reset_after","updateShardCount","getShardIds","max","Array","isArray","start","end","range","toISOString"],"sources":["C:\\Users\\hetit\\node_modules\\@discordjs\\ws\\src\\index.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\ws\\src\\strategies\\context\\IContextFetchingStrategy.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\ws\\src\\strategies\\context\\SimpleContextFetchingStrategy.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\ws\\src\\strategies\\context\\WorkerContextFetchingStrategy.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\ws\\src\\strategies\\sharding\\WorkerShardingStrategy.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\ws\\src\\strategies\\sharding\\SimpleShardingStrategy.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\ws\\src\\ws\\WebSocketShard.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\ws\\src\\utils\\constants.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\ws\\src\\throttling\\SimpleIdentifyThrottler.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\ws\\src\\utils\\WorkerBootstrapper.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\ws\\src\\ws\\WebSocketManager.ts"],"sourcesContent":["export * from './strategies/context/IContextFetchingStrategy.js';\nexport * from './strategies/context/SimpleContextFetchingStrategy.js';\nexport * from './strategies/context/WorkerContextFetchingStrategy.js';\n\nexport * from './strategies/sharding/IShardingStrategy.js';\nexport * from './strategies/sharding/SimpleShardingStrategy.js';\nexport * from './strategies/sharding/WorkerShardingStrategy.js';\n\nexport * from './throttling/IIdentifyThrottler.js';\nexport * from './throttling/SimpleIdentifyThrottler.js';\n\nexport * from './utils/constants.js';\nexport * from './utils/WorkerBootstrapper.js';\n\nexport * from './ws/WebSocketManager.js';\nexport * from './ws/WebSocketShard.js';\n\n/**\n * The {@link https://github.com/discordjs/discord.js/blob/main/packages/ws/#readme | @discordjs/ws} version\n * that you are currently using.\n */\n// This needs to explicitly be `string` so it is not typed as a \"const string\" that gets injected by esbuild\nexport const version = '1.0.1' as string;\n","import type { Awaitable } from '@discordjs/util';\nimport type { APIGatewayBotInfo } from 'discord-api-types/v10';\nimport type { SessionInfo, WebSocketManager, WebSocketManagerOptions } from '../../ws/WebSocketManager.js';\n\nexport interface FetchingStrategyOptions\n\textends Omit<\n\t\tWebSocketManagerOptions,\n\t\t| 'buildIdentifyThrottler'\n\t\t| 'buildStrategy'\n\t\t| 'rest'\n\t\t| 'retrieveSessionInfo'\n\t\t| 'shardCount'\n\t\t| 'shardIds'\n\t\t| 'updateSessionInfo'\n\t> {\n\treadonly gatewayInformation: APIGatewayBotInfo;\n\treadonly shardCount: number;\n}\n\n/**\n * Strategies responsible solely for making manager information accessible\n */\nexport interface IContextFetchingStrategy {\n\treadonly options: FetchingStrategyOptions;\n\tretrieveSessionInfo(shardId: number): Awaitable<SessionInfo | null>;\n\tupdateSessionInfo(shardId: number, sessionInfo: SessionInfo | null): Awaitable<void>;\n\t/**\n\t * Resolves once the given shard should be allowed to identify\n\t * This should correctly handle the signal and reject with an abort error if the operation is aborted.\n\t * Other errors will cause the shard to reconnect.\n\t */\n\twaitForIdentify(shardId: number, signal: AbortSignal): Promise<void>;\n}\n\nexport async function managerToFetchingStrategyOptions(manager: WebSocketManager): Promise<FetchingStrategyOptions> {\n\t/* eslint-disable @typescript-eslint/unbound-method */\n\tconst {\n\t\tbuildIdentifyThrottler,\n\t\tbuildStrategy,\n\t\tretrieveSessionInfo,\n\t\tupdateSessionInfo,\n\t\tshardCount,\n\t\tshardIds,\n\t\trest,\n\t\t...managerOptions\n\t} = manager.options;\n\t/* eslint-enable @typescript-eslint/unbound-method */\n\n\treturn {\n\t\t...managerOptions,\n\t\tgatewayInformation: await manager.fetchGatewayInformation(),\n\t\tshardCount: await manager.getShardCount(),\n\t};\n}\n","import type { IIdentifyThrottler } from '../../throttling/IIdentifyThrottler.js';\nimport type { SessionInfo, WebSocketManager } from '../../ws/WebSocketManager.js';\nimport type { FetchingStrategyOptions, IContextFetchingStrategy } from './IContextFetchingStrategy.js';\n\nexport class SimpleContextFetchingStrategy implements IContextFetchingStrategy {\n\t// This strategy assumes every shard is running under the same process - therefore we need a single\n\t// IdentifyThrottler per manager.\n\tprivate static throttlerCache = new WeakMap<WebSocketManager, IIdentifyThrottler>();\n\n\tprivate static async ensureThrottler(manager: WebSocketManager): Promise<IIdentifyThrottler> {\n\t\tconst throttler = SimpleContextFetchingStrategy.throttlerCache.get(manager);\n\t\tif (throttler) {\n\t\t\treturn throttler;\n\t\t}\n\n\t\tconst newThrottler = await manager.options.buildIdentifyThrottler(manager);\n\t\tSimpleContextFetchingStrategy.throttlerCache.set(manager, newThrottler);\n\n\t\treturn newThrottler;\n\t}\n\n\tpublic constructor(private readonly manager: WebSocketManager, public readonly options: FetchingStrategyOptions) {}\n\n\tpublic async retrieveSessionInfo(shardId: number): Promise<SessionInfo | null> {\n\t\treturn this.manager.options.retrieveSessionInfo(shardId);\n\t}\n\n\tpublic updateSessionInfo(shardId: number, sessionInfo: SessionInfo | null) {\n\t\treturn this.manager.options.updateSessionInfo(shardId, sessionInfo);\n\t}\n\n\tpublic async waitForIdentify(shardId: number, signal: AbortSignal): Promise<void> {\n\t\tconst throttler = await SimpleContextFetchingStrategy.ensureThrottler(this.manager);\n\t\tawait throttler.waitForIdentify(shardId, signal);\n\t}\n}\n","import { isMainThread, parentPort } from 'node:worker_threads';\nimport { Collection } from '@discordjs/collection';\nimport type { SessionInfo } from '../../ws/WebSocketManager.js';\nimport {\n\tWorkerReceivePayloadOp,\n\tWorkerSendPayloadOp,\n\ttype WorkerReceivePayload,\n\ttype WorkerSendPayload,\n} from '../sharding/WorkerShardingStrategy.js';\nimport type { FetchingStrategyOptions, IContextFetchingStrategy } from './IContextFetchingStrategy.js';\n\nexport class WorkerContextFetchingStrategy implements IContextFetchingStrategy {\n\tprivate readonly sessionPromises = new Collection<number, (session: SessionInfo | null) => void>();\n\n\tprivate readonly waitForIdentifyPromises = new Collection<\n\t\tnumber,\n\t\t{ reject(error: unknown): void; resolve(): void; signal: AbortSignal }\n\t>();\n\n\tpublic constructor(public readonly options: FetchingStrategyOptions) {\n\t\tif (isMainThread) {\n\t\t\tthrow new Error('Cannot instantiate WorkerContextFetchingStrategy on the main thread');\n\t\t}\n\n\t\tparentPort!.on('message', (payload: WorkerSendPayload) => {\n\t\t\tif (payload.op === WorkerSendPayloadOp.SessionInfoResponse) {\n\t\t\t\tthis.sessionPromises.get(payload.nonce)?.(payload.session);\n\t\t\t\tthis.sessionPromises.delete(payload.nonce);\n\t\t\t}\n\n\t\t\tif (payload.op === WorkerSendPayloadOp.ShardIdentifyResponse) {\n\t\t\t\tconst promise = this.waitForIdentifyPromises.get(payload.nonce);\n\t\t\t\tif (payload.ok) {\n\t\t\t\t\tpromise?.resolve();\n\t\t\t\t} else {\n\t\t\t\t\t// We need to make sure we reject with an abort error\n\t\t\t\t\tpromise?.reject(promise.signal.reason);\n\t\t\t\t}\n\n\t\t\t\tthis.waitForIdentifyPromises.delete(payload.nonce);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic async retrieveSessionInfo(shardId: number): Promise<SessionInfo | null> {\n\t\tconst nonce = Math.random();\n\t\tconst payload: WorkerReceivePayload = {\n\t\t\top: WorkerReceivePayloadOp.RetrieveSessionInfo,\n\t\t\tshardId,\n\t\t\tnonce,\n\t\t};\n\t\t// eslint-disable-next-line no-promise-executor-return\n\t\tconst promise = new Promise<SessionInfo | null>((resolve) => this.sessionPromises.set(nonce, resolve));\n\t\tparentPort!.postMessage(payload);\n\t\treturn promise;\n\t}\n\n\tpublic updateSessionInfo(shardId: number, sessionInfo: SessionInfo | null) {\n\t\tconst payload: WorkerReceivePayload = {\n\t\t\top: WorkerReceivePayloadOp.UpdateSessionInfo,\n\t\t\tshardId,\n\t\t\tsession: sessionInfo,\n\t\t};\n\t\tparentPort!.postMessage(payload);\n\t}\n\n\tpublic async waitForIdentify(shardId: number, signal: AbortSignal): Promise<void> {\n\t\tconst nonce = Math.random();\n\n\t\tconst payload: WorkerReceivePayload = {\n\t\t\top: WorkerReceivePayloadOp.WaitForIdentify,\n\t\t\tnonce,\n\t\t\tshardId,\n\t\t};\n\t\tconst promise = new Promise<void>((resolve, reject) =>\n\t\t\t// eslint-disable-next-line no-promise-executor-return\n\t\t\tthis.waitForIdentifyPromises.set(nonce, { signal, resolve, reject }),\n\t\t);\n\n\t\tparentPort!.postMessage(payload);\n\n\t\tconst listener = () => {\n\t\t\tconst payload: WorkerReceivePayload = {\n\t\t\t\top: WorkerReceivePayloadOp.CancelIdentify,\n\t\t\t\tnonce,\n\t\t\t};\n\n\t\t\tparentPort!.postMessage(payload);\n\t\t};\n\n\t\tsignal.addEventListener('abort', listener);\n\n\t\ttry {\n\t\t\tawait promise;\n\t\t} finally {\n\t\t\tsignal.removeEventListener('abort', listener);\n\t\t}\n\t}\n}\n","import { once } from 'node:events';\nimport { join, isAbsolute, resolve } from 'node:path';\nimport { Worker } from 'node:worker_threads';\nimport { Collection } from '@discordjs/collection';\nimport type { GatewaySendPayload } from 'discord-api-types/v10';\nimport type { IIdentifyThrottler } from '../../throttling/IIdentifyThrottler.js';\nimport type { SessionInfo, WebSocketManager } from '../../ws/WebSocketManager.js';\nimport type {\n\tWebSocketShardDestroyOptions,\n\tWebSocketShardEvents,\n\tWebSocketShardStatus,\n} from '../../ws/WebSocketShard.js';\nimport { managerToFetchingStrategyOptions, type FetchingStrategyOptions } from '../context/IContextFetchingStrategy.js';\nimport type { IShardingStrategy } from './IShardingStrategy.js';\n\nexport interface WorkerData extends FetchingStrategyOptions {\n\tshardIds: number[];\n}\n\nexport enum WorkerSendPayloadOp {\n\tConnect,\n\tDestroy,\n\tSend,\n\tSessionInfoResponse,\n\tShardIdentifyResponse,\n\tFetchStatus,\n}\n\nexport type WorkerSendPayload =\n\t| { nonce: number; ok: boolean; op: WorkerSendPayloadOp.ShardIdentifyResponse }\n\t| { nonce: number; op: WorkerSendPayloadOp.FetchStatus; shardId: number }\n\t| { nonce: number; op: WorkerSendPayloadOp.SessionInfoResponse; session: SessionInfo | null }\n\t| { op: WorkerSendPayloadOp.Connect; shardId: number }\n\t| { op: WorkerSendPayloadOp.Destroy; options?: WebSocketShardDestroyOptions; shardId: number }\n\t| { op: WorkerSendPayloadOp.Send; payload: GatewaySendPayload; shardId: number };\n\nexport enum WorkerReceivePayloadOp {\n\tConnected,\n\tDestroyed,\n\tEvent,\n\tRetrieveSessionInfo,\n\tUpdateSessionInfo,\n\tWaitForIdentify,\n\tFetchStatusResponse,\n\tWorkerReady,\n\tCancelIdentify,\n}\n\nexport type WorkerReceivePayload =\n\t// Can't seem to get a type-safe union based off of the event, so I'm sadly leaving data as any for now\n\t| { data: any; event: WebSocketShardEvents; op: WorkerReceivePayloadOp.Event; shardId: number }\n\t| { nonce: number; op: WorkerReceivePayloadOp.CancelIdentify }\n\t| { nonce: number; op: WorkerReceivePayloadOp.FetchStatusResponse; status: WebSocketShardStatus }\n\t| { nonce: number; op: WorkerReceivePayloadOp.RetrieveSessionInfo; shardId: number }\n\t| { nonce: number; op: WorkerReceivePayloadOp.WaitForIdentify; shardId: number }\n\t| { op: WorkerReceivePayloadOp.Connected; shardId: number }\n\t| { op: WorkerReceivePayloadOp.Destroyed; shardId: number }\n\t| { op: WorkerReceivePayloadOp.UpdateSessionInfo; session: SessionInfo | null; shardId: number }\n\t| { op: WorkerReceivePayloadOp.WorkerReady };\n\n/**\n * Options for a {@link WorkerShardingStrategy}\n */\nexport interface WorkerShardingStrategyOptions {\n\t/**\n\t * Dictates how many shards should be spawned per worker thread.\n\t */\n\tshardsPerWorker: number | 'all';\n\t/**\n\t * Path to the worker file to use. The worker requires quite a bit of setup, it is recommended you leverage the {@link WorkerBootstrapper} class.\n\t */\n\tworkerPath?: string;\n}\n\n/**\n * Strategy used to spawn threads in worker_threads\n */\nexport class WorkerShardingStrategy implements IShardingStrategy {\n\tprivate readonly manager: WebSocketManager;\n\n\tprivate readonly options: WorkerShardingStrategyOptions;\n\n\t#workers: Worker[] = [];\n\n\treadonly #workerByShardId = new Collection<number, Worker>();\n\n\tprivate readonly connectPromises = new Collection<number, () => void>();\n\n\tprivate readonly destroyPromises = new Collection<number, () => void>();\n\n\tprivate readonly fetchStatusPromises = new Collection<number, (status: WebSocketShardStatus) => void>();\n\n\tprivate readonly waitForIdentifyControllers = new Collection<number, AbortController>();\n\n\tprivate throttler?: IIdentifyThrottler;\n\n\tpublic constructor(manager: WebSocketManager, options: WorkerShardingStrategyOptions) {\n\t\tthis.manager = manager;\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.spawn}\n\t */\n\tpublic async spawn(shardIds: number[]) {\n\t\tconst shardsPerWorker = this.options.shardsPerWorker === 'all' ? shardIds.length : this.options.shardsPerWorker;\n\t\tconst strategyOptions = await managerToFetchingStrategyOptions(this.manager);\n\n\t\tconst loops = Math.ceil(shardIds.length / shardsPerWorker);\n\t\tconst promises: Promise<void>[] = [];\n\n\t\tfor (let idx = 0; idx < loops; idx++) {\n\t\t\tconst slice = shardIds.slice(idx * shardsPerWorker, (idx + 1) * shardsPerWorker);\n\t\t\tconst workerData: WorkerData = {\n\t\t\t\t...strategyOptions,\n\t\t\t\tshardIds: slice,\n\t\t\t};\n\n\t\t\tpromises.push(this.setupWorker(workerData));\n\t\t}\n\n\t\tawait Promise.all(promises);\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.connect}\n\t */\n\tpublic async connect() {\n\t\tconst promises = [];\n\n\t\tfor (const [shardId, worker] of this.#workerByShardId.entries()) {\n\t\t\tconst payload: WorkerSendPayload = {\n\t\t\t\top: WorkerSendPayloadOp.Connect,\n\t\t\t\tshardId,\n\t\t\t};\n\n\t\t\t// eslint-disable-next-line no-promise-executor-return\n\t\t\tconst promise = new Promise<void>((resolve) => this.connectPromises.set(shardId, resolve));\n\t\t\tworker.postMessage(payload);\n\t\t\tpromises.push(promise);\n\t\t}\n\n\t\tawait Promise.all(promises);\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.destroy}\n\t */\n\tpublic async destroy(options: Omit<WebSocketShardDestroyOptions, 'recover'> = {}) {\n\t\tconst promises = [];\n\n\t\tfor (const [shardId, worker] of this.#workerByShardId.entries()) {\n\t\t\tconst payload: WorkerSendPayload = {\n\t\t\t\top: WorkerSendPayloadOp.Destroy,\n\t\t\t\tshardId,\n\t\t\t\toptions,\n\t\t\t};\n\n\t\t\tpromises.push(\n\t\t\t\t// eslint-disable-next-line no-promise-executor-return, promise/prefer-await-to-then\n\t\t\t\tnew Promise<void>((resolve) => this.destroyPromises.set(shardId, resolve)).then(async () => worker.terminate()),\n\t\t\t);\n\t\t\tworker.postMessage(payload);\n\t\t}\n\n\t\tthis.#workers = [];\n\t\tthis.#workerByShardId.clear();\n\n\t\tawait Promise.all(promises);\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.send}\n\t */\n\tpublic send(shardId: number, data: GatewaySendPayload) {\n\t\tconst worker = this.#workerByShardId.get(shardId);\n\t\tif (!worker) {\n\t\t\tthrow new Error(`No worker found for shard ${shardId}`);\n\t\t}\n\n\t\tconst payload: WorkerSendPayload = {\n\t\t\top: WorkerSendPayloadOp.Send,\n\t\t\tshardId,\n\t\t\tpayload: data,\n\t\t};\n\t\tworker.postMessage(payload);\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.fetchStatus}\n\t */\n\tpublic async fetchStatus() {\n\t\tconst statuses = new Collection<number, WebSocketShardStatus>();\n\n\t\tfor (const [shardId, worker] of this.#workerByShardId.entries()) {\n\t\t\tconst nonce = Math.random();\n\t\t\tconst payload: WorkerSendPayload = {\n\t\t\t\top: WorkerSendPayloadOp.FetchStatus,\n\t\t\t\tshardId,\n\t\t\t\tnonce,\n\t\t\t};\n\n\t\t\t// eslint-disable-next-line no-promise-executor-return\n\t\t\tconst promise = new Promise<WebSocketShardStatus>((resolve) => this.fetchStatusPromises.set(nonce, resolve));\n\t\t\tworker.postMessage(payload);\n\n\t\t\tconst status = await promise;\n\t\t\tstatuses.set(shardId, status);\n\t\t}\n\n\t\treturn statuses;\n\t}\n\n\tprivate async setupWorker(workerData: WorkerData) {\n\t\tconst worker = new Worker(this.resolveWorkerPath(), { workerData });\n\n\t\tawait once(worker, 'online');\n\t\t// We do this in case the user has any potentially long running code in their worker\n\t\tawait this.waitForWorkerReady(worker);\n\n\t\tworker\n\t\t\t.on('error', (err) => {\n\t\t\t\tthrow err;\n\t\t\t})\n\t\t\t.on('messageerror', (err) => {\n\t\t\t\tthrow err;\n\t\t\t})\n\t\t\t.on('message', async (payload: WorkerReceivePayload) => this.onMessage(worker, payload));\n\n\t\tthis.#workers.push(worker);\n\t\tfor (const shardId of workerData.shardIds) {\n\t\t\tthis.#workerByShardId.set(shardId, worker);\n\t\t}\n\t}\n\n\tprivate resolveWorkerPath(): string {\n\t\tconst path = this.options.workerPath;\n\n\t\tif (!path) {\n\t\t\treturn join(__dirname, 'defaultWorker.js');\n\t\t}\n\n\t\tif (isAbsolute(path)) {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (/^\\.\\.?[/\\\\]/.test(path)) {\n\t\t\treturn resolve(path);\n\t\t}\n\n\t\ttry {\n\t\t\treturn require.resolve(path);\n\t\t} catch {\n\t\t\treturn resolve(path);\n\t\t}\n\t}\n\n\tprivate async waitForWorkerReady(worker: Worker): Promise<void> {\n\t\treturn new Promise((resolve) => {\n\t\t\tconst handler = (payload: WorkerReceivePayload) => {\n\t\t\t\tif (payload.op === WorkerReceivePayloadOp.WorkerReady) {\n\t\t\t\t\tresolve();\n\t\t\t\t\tworker.off('message', handler);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tworker.on('message', handler);\n\t\t});\n\t}\n\n\tprivate async onMessage(worker: Worker, payload: WorkerReceivePayload) {\n\t\tswitch (payload.op) {\n\t\t\tcase WorkerReceivePayloadOp.Connected: {\n\t\t\t\tthis.connectPromises.get(payload.shardId)?.();\n\t\t\t\tthis.connectPromises.delete(payload.shardId);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerReceivePayloadOp.Destroyed: {\n\t\t\t\tthis.destroyPromises.get(payload.shardId)?.();\n\t\t\t\tthis.destroyPromises.delete(payload.shardId);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerReceivePayloadOp.Event: {\n\t\t\t\tthis.manager.emit(payload.event, { ...payload.data, shardId: payload.shardId });\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerReceivePayloadOp.RetrieveSessionInfo: {\n\t\t\t\tconst session = await this.manager.options.retrieveSessionInfo(payload.shardId);\n\t\t\t\tconst response: WorkerSendPayload = {\n\t\t\t\t\top: WorkerSendPayloadOp.SessionInfoResponse,\n\t\t\t\t\tnonce: payload.nonce,\n\t\t\t\t\tsession,\n\t\t\t\t};\n\t\t\t\tworker.postMessage(response);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerReceivePayloadOp.UpdateSessionInfo: {\n\t\t\t\tawait this.manager.options.updateSessionInfo(payload.shardId, payload.session);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerReceivePayloadOp.WaitForIdentify: {\n\t\t\t\tconst throttler = await this.ensureThrottler();\n\n\t\t\t\t// If this rejects it means we aborted, in which case we reply elsewhere.\n\t\t\t\ttry {\n\t\t\t\t\tconst controller = new AbortController();\n\t\t\t\t\tthis.waitForIdentifyControllers.set(payload.nonce, controller);\n\t\t\t\t\tawait throttler.waitForIdentify(payload.shardId, controller.signal);\n\t\t\t\t} catch {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst response: WorkerSendPayload = {\n\t\t\t\t\top: WorkerSendPayloadOp.ShardIdentifyResponse,\n\t\t\t\t\tnonce: payload.nonce,\n\t\t\t\t\tok: true,\n\t\t\t\t};\n\t\t\t\tworker.postMessage(response);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerReceivePayloadOp.FetchStatusResponse: {\n\t\t\t\tthis.fetchStatusPromises.get(payload.nonce)?.(payload.status);\n\t\t\t\tthis.fetchStatusPromises.delete(payload.nonce);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerReceivePayloadOp.WorkerReady: {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerReceivePayloadOp.CancelIdentify: {\n\t\t\t\tthis.waitForIdentifyControllers.get(payload.nonce)?.abort();\n\t\t\t\tthis.waitForIdentifyControllers.delete(payload.nonce);\n\n\t\t\t\tconst response: WorkerSendPayload = {\n\t\t\t\t\top: WorkerSendPayloadOp.ShardIdentifyResponse,\n\t\t\t\t\tnonce: payload.nonce,\n\t\t\t\t\tok: false,\n\t\t\t\t};\n\t\t\t\tworker.postMessage(response);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async ensureThrottler(): Promise<IIdentifyThrottler> {\n\t\tthis.throttler ??= await this.manager.options.buildIdentifyThrottler(this.manager);\n\t\treturn this.throttler;\n\t}\n}\n","import { Collection } from '@discordjs/collection';\nimport type { GatewaySendPayload } from 'discord-api-types/v10';\nimport type { WebSocketManager } from '../../ws/WebSocketManager.js';\nimport { WebSocketShard, WebSocketShardEvents, type WebSocketShardDestroyOptions } from '../../ws/WebSocketShard.js';\nimport { managerToFetchingStrategyOptions } from '../context/IContextFetchingStrategy.js';\nimport { SimpleContextFetchingStrategy } from '../context/SimpleContextFetchingStrategy.js';\nimport type { IShardingStrategy } from './IShardingStrategy.js';\n\n/**\n * Simple strategy that just spawns shards in the current process\n */\nexport class SimpleShardingStrategy implements IShardingStrategy {\n\tprivate readonly manager: WebSocketManager;\n\n\tprivate readonly shards = new Collection<number, WebSocketShard>();\n\n\tpublic constructor(manager: WebSocketManager) {\n\t\tthis.manager = manager;\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.spawn}\n\t */\n\tpublic async spawn(shardIds: number[]) {\n\t\tconst strategyOptions = await managerToFetchingStrategyOptions(this.manager);\n\n\t\tfor (const shardId of shardIds) {\n\t\t\tconst strategy = new SimpleContextFetchingStrategy(this.manager, strategyOptions);\n\t\t\tconst shard = new WebSocketShard(strategy, shardId);\n\t\t\tfor (const event of Object.values(WebSocketShardEvents)) {\n\t\t\t\t// @ts-expect-error: Intentional\n\t\t\t\tshard.on(event, (payload) => this.manager.emit(event, { ...payload, shardId }));\n\t\t\t}\n\n\t\t\tthis.shards.set(shardId, shard);\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.connect}\n\t */\n\tpublic async connect() {\n\t\tconst promises = [];\n\n\t\tfor (const shard of this.shards.values()) {\n\t\t\tpromises.push(shard.connect());\n\t\t}\n\n\t\tawait Promise.all(promises);\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.destroy}\n\t */\n\tpublic async destroy(options?: Omit<WebSocketShardDestroyOptions, 'recover'>) {\n\t\tconst promises = [];\n\n\t\tfor (const shard of this.shards.values()) {\n\t\t\tpromises.push(shard.destroy(options));\n\t\t}\n\n\t\tawait Promise.all(promises);\n\t\tthis.shards.clear();\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.send}\n\t */\n\tpublic async send(shardId: number, payload: GatewaySendPayload) {\n\t\tconst shard = this.shards.get(shardId);\n\t\tif (!shard) {\n\t\t\tthrow new RangeError(`Shard ${shardId} not found`);\n\t\t}\n\n\t\treturn shard.send(payload);\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.fetchStatus}\n\t */\n\tpublic async fetchStatus() {\n\t\treturn this.shards.mapValues((shard) => shard.status);\n\t}\n}\n","/* eslint-disable id-length */\nimport { Buffer } from 'node:buffer';\nimport { once } from 'node:events';\nimport { clearInterval, clearTimeout, setInterval, setTimeout } from 'node:timers';\nimport { setTimeout as sleep } from 'node:timers/promises';\nimport { URLSearchParams } from 'node:url';\nimport { TextDecoder } from 'node:util';\nimport { inflate } from 'node:zlib';\nimport { Collection } from '@discordjs/collection';\nimport { lazy } from '@discordjs/util';\nimport { AsyncQueue } from '@sapphire/async-queue';\nimport { AsyncEventEmitter } from '@vladfrangu/async_event_emitter';\nimport {\n\tGatewayCloseCodes,\n\tGatewayDispatchEvents,\n\tGatewayOpcodes,\n\ttype GatewayDispatchPayload,\n\ttype GatewayIdentifyData,\n\ttype GatewayReadyDispatchData,\n\ttype GatewayReceivePayload,\n\ttype GatewaySendPayload,\n} from 'discord-api-types/v10';\nimport { WebSocket, type Data } from 'ws';\nimport type { Inflate } from 'zlib-sync';\nimport type { IContextFetchingStrategy } from '../strategies/context/IContextFetchingStrategy.js';\nimport { ImportantGatewayOpcodes, getInitialSendRateLimitState } from '../utils/constants.js';\nimport type { SessionInfo } from './WebSocketManager.js';\n\n// eslint-disable-next-line promise/prefer-await-to-then\nconst getZlibSync = lazy(async () => import('zlib-sync').then((mod) => mod.default).catch(() => null));\n\nexport enum WebSocketShardEvents {\n\tClosed = 'closed',\n\tDebug = 'debug',\n\tDispatch = 'dispatch',\n\tError = 'error',\n\tHeartbeatComplete = 'heartbeat',\n\tHello = 'hello',\n\tReady = 'ready',\n\tResumed = 'resumed',\n}\n\nexport enum WebSocketShardStatus {\n\tIdle,\n\tConnecting,\n\tResuming,\n\tReady,\n}\n\nexport enum WebSocketShardDestroyRecovery {\n\tReconnect,\n\tResume,\n}\n\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport type WebSocketShardEventsMap = {\n\t[WebSocketShardEvents.Closed]: [{ code: number }];\n\t[WebSocketShardEvents.Debug]: [payload: { message: string }];\n\t[WebSocketShardEvents.Dispatch]: [payload: { data: GatewayDispatchPayload }];\n\t[WebSocketShardEvents.Error]: [payload: { error: Error }];\n\t[WebSocketShardEvents.Hello]: [];\n\t[WebSocketShardEvents.Ready]: [payload: { data: GatewayReadyDispatchData }];\n\t[WebSocketShardEvents.Resumed]: [];\n\t[WebSocketShardEvents.HeartbeatComplete]: [payload: { ackAt: number; heartbeatAt: number; latency: number }];\n};\n\nexport interface WebSocketShardDestroyOptions {\n\tcode?: number;\n\treason?: string;\n\trecover?: WebSocketShardDestroyRecovery;\n}\n\nexport enum CloseCodes {\n\tNormal = 1_000,\n\tResuming = 4_200,\n}\n\nexport interface SendRateLimitState {\n\tremaining: number;\n\tresetAt: number;\n}\n\n// TODO(vladfrangu): enable this once https://github.com/oven-sh/bun/issues/3392 is solved\n// const WebSocketConstructor: typeof WebSocket = shouldUseGlobalFetchAndWebSocket()\n// \t? (globalThis as any).WebSocket\n// \t: WebSocket;\nconst WebSocketConstructor: typeof WebSocket = WebSocket;\n\nexport class WebSocketShard extends AsyncEventEmitter<WebSocketShardEventsMap> {\n\tprivate connection: WebSocket | null = null;\n\n\tprivate useIdentifyCompress = false;\n\n\tprivate inflate: Inflate | null = null;\n\n\tprivate readonly textDecoder = new TextDecoder();\n\n\tprivate replayedEvents = 0;\n\n\tprivate isAck = true;\n\n\tprivate sendRateLimitState: SendRateLimitState = getInitialSendRateLimitState();\n\n\tprivate initialHeartbeatTimeoutController: AbortController | null = null;\n\n\tprivate heartbeatInterval: NodeJS.Timer | null = null;\n\n\tprivate lastHeartbeatAt = -1;\n\n\t// Indicates whether the shard has already resolved its original connect() call\n\tprivate initialConnectResolved = false;\n\n\t// Indicates if we failed to connect to the ws url (ECONNREFUSED/ECONNRESET)\n\tprivate failedToConnectDueToNetworkError = false;\n\n\tprivate readonly sendQueue = new AsyncQueue();\n\n\tprivate readonly timeoutAbortControllers = new Collection<WebSocketShardEvents, AbortController>();\n\n\tprivate readonly strategy: IContextFetchingStrategy;\n\n\tpublic readonly id: number;\n\n\t#status: WebSocketShardStatus = WebSocketShardStatus.Idle;\n\n\tpublic get status(): WebSocketShardStatus {\n\t\treturn this.#status;\n\t}\n\n\tpublic constructor(strategy: IContextFetchingStrategy, id: number) {\n\t\tsuper();\n\t\tthis.strategy = strategy;\n\t\tthis.id = id;\n\t}\n\n\tpublic async connect() {\n\t\tconst controller = new AbortController();\n\t\tlet promise;\n\n\t\tif (!this.initialConnectResolved) {\n\t\t\t// Sleep for the remaining time, but if the connection closes in the meantime, we shouldn't wait the remainder to avoid blocking the new conn\n\t\t\tpromise = Promise.race([\n\t\t\t\tonce(this, WebSocketShardEvents.Ready, { signal: controller.signal }),\n\t\t\t\tonce(this, WebSocketShardEvents.Resumed, { signal: controller.signal }),\n\t\t\t]);\n\t\t}\n\n\t\tvoid this.internalConnect();\n\n\t\ttry {\n\t\t\tawait promise;\n\t\t} catch ({ error }: any) {\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\t// cleanup hanging listeners\n\t\t\tcontroller.abort();\n\t\t}\n\n\t\tthis.initialConnectResolved = true;\n\t}\n\n\tprivate async internalConnect() {\n\t\tif (this.#status !== WebSocketShardStatus.Idle) {\n\t\t\tthrow new Error(\"Tried to connect a shard that wasn't idle\");\n\t\t}\n\n\t\tconst { version, encoding, compression } = this.strategy.options;\n\t\tconst params = new URLSearchParams({ v: version, encoding });\n\t\tif (compression) {\n\t\t\tconst zlib = await getZlibSync();\n\t\t\tif (zlib) {\n\t\t\t\tparams.append('compress', compression);\n\t\t\t\tthis.inflate = new zlib.Inflate({\n\t\t\t\t\tchunkSize: 65_535,\n\t\t\t\t\tto: 'string',\n\t\t\t\t});\n\t\t\t} else if (!this.useIdentifyCompress) {\n\t\t\t\tthis.useIdentifyCompress = true;\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'WebSocketShard: Compression is enabled but zlib-sync is not installed, falling back to identify compress',\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst session = await this.strategy.retrieveSessionInfo(this.id);\n\n\t\tconst url = `${session?.resumeURL ?? this.strategy.options.gatewayInformation.url}?${params.toString()}`;\n\n\t\tthis.debug([`Connecting to ${url}`]);\n\n\t\tconst connection = new WebSocketConstructor(url, {\n\t\t\thandshakeTimeout: this.strategy.options.handshakeTimeout ?? undefined,\n\t\t});\n\n\t\tconnection.binaryType = 'arraybuffer';\n\n\t\tconnection.onmessage = (event) => {\n\t\t\tvoid this.onMessage(event.data, event.data instanceof ArrayBuffer);\n\t\t};\n\n\t\tconnection.onerror = (event) => {\n\t\t\tthis.onError(event.error);\n\t\t};\n\n\t\tconnection.onclose = (event) => {\n\t\t\tvoid this.onClose(event.code);\n\t\t};\n\n\t\tthis.connection = connection;\n\n\t\tthis.#status = WebSocketShardStatus.Connecting;\n\n\t\tthis.sendRateLimitState = getInitialSendRateLimitState();\n\n\t\tconst { ok } = await this.waitForEvent(WebSocketShardEvents.Hello, this.strategy.options.helloTimeout);\n\t\tif (!ok) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (session?.shardCount === this.strategy.options.shardCount) {\n\t\t\tawait this.resume(session);\n\t\t} else {\n\t\t\tawait this.identify();\n\t\t}\n\t}\n\n\tpublic async destroy(options: WebSocketShardDestroyOptions = {}) {\n\t\tif (this.#status === WebSocketShardStatus.Idle) {\n\t\t\tthis.debug(['Tried to destroy a shard that was idle']);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!options.code) {\n\t\t\toptions.code = options.recover === WebSocketShardDestroyRecovery.Resume ? CloseCodes.Resuming : CloseCodes.Normal;\n\t\t}\n\n\t\tthis.debug([\n\t\t\t'Destroying shard',\n\t\t\t`Reason: ${options.reason ?? 'none'}`,\n\t\t\t`Code: ${options.code}`,\n\t\t\t`Recover: ${options.recover === undefined ? 'none' : WebSocketShardDestroyRecovery[options.recover]!}`,\n\t\t]);\n\n\t\t// Reset state\n\t\tthis.isAck = true;\n\t\tif (this.heartbeatInterval) {\n\t\t\tclearInterval(this.heartbeatInterval);\n\t\t}\n\n\t\tif (this.initialHeartbeatTimeoutController) {\n\t\t\tthis.initialHeartbeatTimeoutController.abort();\n\t\t\tthis.initialHeartbeatTimeoutController = null;\n\t\t}\n\n\t\tthis.lastHeartbeatAt = -1;\n\n\t\tfor (const controller of this.timeoutAbortControllers.values()) {\n\t\t\tcontroller.abort();\n\t\t}\n\n\t\tthis.timeoutAbortControllers.clear();\n\n\t\tthis.failedToConnectDueToNetworkError = false;\n\n\t\t// Clear session state if applicable\n\t\tif (options.recover !== WebSocketShardDestroyRecovery.Resume) {\n\t\t\tawait this.strategy.updateSessionInfo(this.id, null);\n\t\t}\n\n\t\tif (this.connection) {\n\t\t\t// No longer need to listen to messages\n\t\t\tthis.connection.onmessage = null;\n\t\t\t// Prevent a reconnection loop by unbinding the main close event\n\t\t\tthis.connection.onclose = null;\n\n\t\t\tconst shouldClose = this.connection.readyState === WebSocket.OPEN;\n\n\t\t\tthis.debug([\n\t\t\t\t'Connection status during destroy',\n\t\t\t\t`Needs closing: ${shouldClose}`,\n\t\t\t\t`Ready state: ${this.connection.readyState}`,\n\t\t\t]);\n\n\t\t\tif (shouldClose) {\n\t\t\t\tlet outerResolve: () => void;\n\t\t\t\tconst promise = new Promise<void>((resolve) => {\n\t\t\t\t\touterResolve = resolve;\n\t\t\t\t});\n\n\t\t\t\tthis.connection.onclose = outerResolve!;\n\n\t\t\t\tthis.connection.close(options.code, options.reason);\n\n\t\t\t\tawait promise;\n\t\t\t\tthis.emit(WebSocketShardEvents.Closed, { code: options.code });\n\t\t\t}\n\n\t\t\t// Lastly, remove the error event.\n\t\t\t// Doing this earlier would cause a hard crash in case an error event fired on our `close` call\n\t\t\tthis.connection.onerror = null;\n\t\t} else {\n\t\t\tthis.debug(['Destroying a shard that has no connection; please open an issue on GitHub']);\n\t\t}\n\n\t\tthis.#status = WebSocketShardStatus.Idle;\n\n\t\tif (options.recover !== undefined) {\n\t\t\t// There's cases (like no internet connection) where we immediately fail to connect,\n\t\t\t// causing a very fast and draining reconnection loop.\n\t\t\tawait sleep(500);\n\t\t\treturn this.internalConnect();\n\t\t}\n\t}\n\n\tprivate async waitForEvent(event: WebSocketShardEvents, timeoutDuration?: number | null): Promise<{ ok: boolean }> {\n\t\tthis.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : 'indefinitely'}`]);\n\t\tconst timeoutController = new AbortController();\n\t\tconst timeout = timeoutDuration ? setTimeout(() => timeoutController.abort(), timeoutDuration).unref() : null;\n\n\t\tthis.timeoutAbortControllers.set(event, timeoutController);\n\n\t\tconst closeController = new AbortController();\n\n\t\ttry {\n\t\t\t// If the first promise resolves, all is well. If the 2nd promise resolves,\n\t\t\t// the shard has meanwhile closed. In that case, a destroy is already ongoing, so we just need to\n\t\t\t// return false. Meanwhile, if something rejects (error event) or the first controller is aborted,\n\t\t\t// we enter the catch block and trigger a destroy there.\n\t\t\tconst closed = await Promise.race<boolean>([\n\t\t\t\tonce(this, event, { signal: timeoutController.signal }).then(() => false),\n\t\t\t\tonce(this, WebSocketShardEvents.Closed, { signal: closeController.signal }).then(() => true),\n\t\t\t]);\n\n\t\t\treturn { ok: !closed };\n\t\t} catch {\n\t\t\t// If we're here because of other reasons, we need to destroy the shard\n\t\t\tvoid this.destroy({\n\t\t\t\tcode: CloseCodes.Normal,\n\t\t\t\treason: 'Something timed out or went wrong while waiting for an event',\n\t\t\t\trecover: WebSocketShardDestroyRecovery.Reconnect,\n\t\t\t});\n\n\t\t\treturn { ok: false };\n\t\t} finally {\n\t\t\tif (timeout) {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t}\n\n\t\t\tthis.timeoutAbortControllers.delete(event);\n\n\t\t\t// Clean up the close listener to not leak memory\n\t\t\tif (!closeController.signal.aborted) {\n\t\t\t\tcloseController.abort();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic async send(payload: GatewaySendPayload): Promise<void> {\n\t\tif (!this.connection) {\n\t\t\tthrow new Error(\"WebSocketShard wasn't connected\");\n\t\t}\n\n\t\tif (this.#status !== WebSocketShardStatus.Ready && !ImportantGatewayOpcodes.has(payload.op)) {\n\t\t\tthis.debug(['Tried to send a non-crucial payload before the shard was ready, waiting']);\n\t\t\t// This will throw if the shard throws an error event in the meantime, just requeue the payload\n\t\t\ttry {\n\t\t\t\tawait once(this, WebSocketShardEvents.Ready);\n\t\t\t} catch {\n\t\t\t\treturn this.send(payload);\n\t\t\t}\n\t\t}\n\n\t\tawait this.sendQueue.wait();\n\n\t\tif (--this.sendRateLimitState.remaining <= 0) {\n\t\t\tconst now = Date.now();\n\n\t\t\tif (this.sendRateLimitState.resetAt > now) {\n\t\t\t\tconst sleepFor = this.sendRateLimitState.resetAt - now;\n\n\t\t\t\tthis.debug([`Was about to hit the send rate limit, sleeping for ${sleepFor}ms`]);\n\t\t\t\tconst controller = new AbortController();\n\n\t\t\t\t// Sleep for the remaining time, but if the connection closes in the meantime, we shouldn't wait the remainder to avoid blocking the new conn\n\t\t\t\tconst interrupted = await Promise.race([\n\t\t\t\t\tsleep(sleepFor).then(() => false),\n\t\t\t\t\tonce(this, WebSocketShardEvents.Closed, { signal: controller.signal }).then(() => true),\n\t\t\t\t]);\n\n\t\t\t\tif (interrupted) {\n\t\t\t\t\tthis.debug(['Connection closed while waiting for the send rate limit to reset, re-queueing payload']);\n\t\t\t\t\tthis.sendQueue.shift();\n\t\t\t\t\treturn this.send(payload);\n\t\t\t\t}\n\n\t\t\t\t// This is so the listener from the `once` call is removed\n\t\t\t\tcontroller.abort();\n\t\t\t}\n\n\t\t\tthis.sendRateLimitState = getInitialSendRateLimitState();\n\t\t}\n\n\t\tthis.sendQueue.shift();\n\t\tthis.connection.send(JSON.stringify(payload));\n\t}\n\n\tprivate async identify() {\n\t\tthis.debug(['Waiting for identify throttle']);\n\n\t\tconst controller = new AbortController();\n\t\tconst closeHandler = () => {\n\t\t\tcontroller.abort();\n\t\t};\n\n\t\tthis.on(WebSocketShardEvents.Closed, closeHandler);\n\n\t\ttry {\n\t\t\tawait this.strategy.waitForIdentify(this.id, controller.signal);\n\t\t} catch {\n\t\t\tif (controller.signal.aborted) {\n\t\t\t\tthis.debug(['Was waiting for an identify, but the shard closed in the meantime']);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.debug([\n\t\t\t\t'IContextFetchingStrategy#waitForIdentify threw an unknown error.',\n\t\t\t\t\"If you're using a custom strategy, this is probably nothing to worry about.\",\n\t\t\t\t\"If you're not, please open an issue on GitHub.\",\n\t\t\t]);\n\n\t\t\tawait this.destroy({\n\t\t\t\treason: 'Identify throttling logic failed',\n\t\t\t\trecover: WebSocketShardDestroyRecovery.Resume,\n\t\t\t});\n\t\t} finally {\n\t\t\tthis.off(WebSocketShardEvents.Closed, closeHandler);\n\t\t}\n\n\t\tthis.debug([\n\t\t\t'Identifying',\n\t\t\t`shard id: ${this.id.toString()}`,\n\t\t\t`shard count: ${this.strategy.options.shardCount}`,\n\t\t\t`intents: ${this.strategy.options.intents}`,\n\t\t\t`compression: ${this.inflate ? 'zlib-stream' : this.useIdentifyCompress ? 'identify' : 'none'}`,\n\t\t]);\n\n\t\tconst d: GatewayIdentifyData = {\n\t\t\ttoken: this.strategy.options.token,\n\t\t\tproperties: this.strategy.options.identifyProperties,\n\t\t\tintents: this.strategy.options.intents,\n\t\t\tcompress: this.useIdentifyCompress,\n\t\t\tshard: [this.id, this.strategy.options.shardCount],\n\t\t};\n\n\t\tif (this.strategy.options.largeThreshold) {\n\t\t\td.large_threshold = this.strategy.options.largeThreshold;\n\t\t}\n\n\t\tif (this.strategy.options.initialPresence) {\n\t\t\td.presence = this.strategy.options.initialPresence;\n\t\t}\n\n\t\tawait this.send({\n\t\t\top: GatewayOpcodes.Identify,\n\t\t\td,\n\t\t});\n\n\t\tawait this.waitForEvent(WebSocketShardEvents.Ready, this.strategy.options.readyTimeout);\n\t}\n\n\tprivate async resume(session: SessionInfo) {\n\t\tthis.debug([\n\t\t\t'Resuming session',\n\t\t\t`resume url: ${session.resumeURL}`,\n\t\t\t`sequence: ${session.sequence}`,\n\t\t\t`shard id: ${this.id.toString()}`,\n\t\t]);\n\n\t\tthis.#status = WebSocketShardStatus.Resuming;\n\t\tthis.replayedEvents = 0;\n\t\treturn this.send({\n\t\t\top: GatewayOpcodes.Resume,\n\t\t\td: {\n\t\t\t\ttoken: this.strategy.options.token,\n\t\t\t\tseq: session.sequence,\n\t\t\t\tsession_id: session.sessionId,\n\t\t\t},\n\t\t});\n\t}\n\n\tprivate async heartbeat(requested = false) {\n\t\tif (!this.isAck && !requested) {\n\t\t\treturn this.destroy({ reason: 'Zombie connection', recover: WebSocketShardDestroyRecovery.Resume });\n\t\t}\n\n\t\tconst session = await this.strategy.retrieveSessionInfo(this.id);\n\n\t\tawait this.send({\n\t\t\top: GatewayOpcodes.Heartbeat,\n\t\t\td: session?.sequence ?? null,\n\t\t});\n\n\t\tthis.lastHeartbeatAt = Date.now();\n\t\tthis.isAck = false;\n\t}\n\n\tprivate async unpackMessage(data: Data, isBinary: boolean): Promise<GatewayReceivePayload | null> {\n\t\t// Deal with no compression\n\t\tif (!isBinary) {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(data as string) as GatewayReceivePayload;\n\t\t\t} catch {\n\t\t\t\t// This is a non-JSON payload / (at the time of writing this comment) emitted by bun wrongly interpreting custom close codes https://github.com/oven-sh/bun/issues/3392\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tconst decompressable = new Uint8Array(data as ArrayBuffer);\n\n\t\t// Deal with identify compress\n\t\tif (this.useIdentifyCompress) {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t// eslint-disable-next-line promise/prefer-await-to-callbacks\n\t\t\t\tinflate(decompressable, { chunkSize: 65_535 }, (err, result) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(JSON.parse(this.textDecoder.decode(result)) as GatewayReceivePayload);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// Deal with gw wide zlib-stream compression\n\t\tif (this.inflate) {\n\t\t\tconst l = decompressable.length;\n\t\t\tconst flush =\n\t\t\t\tl >= 4 &&\n\t\t\t\tdecompressable[l - 4] === 0x00 &&\n\t\t\t\tdecompressable[l - 3] === 0x00 &&\n\t\t\t\tdecompressable[l - 2] === 0xff &&\n\t\t\t\tdecompressable[l - 1] === 0xff;\n\n\t\t\tconst zlib = (await getZlibSync())!;\n\t\t\tthis.inflate.push(Buffer.from(decompressable), flush ? zlib.Z_SYNC_FLUSH : zlib.Z_NO_FLUSH);\n\n\t\t\tif (this.inflate.err) {\n\t\t\t\tthis.emit(WebSocketShardEvents.Error, {\n\t\t\t\t\terror: new Error(`${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ''}`),\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (!flush) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst { result } = this.inflate;\n\t\t\tif (!result) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn JSON.parse(typeof result === 'string' ? result : this.textDecoder.decode(result)) as GatewayReceivePayload;\n\t\t}\n\n\t\tthis.debug([\n\t\t\t'Received a message we were unable to decompress',\n\t\t\t`isBinary: ${isBinary.toString()}`,\n\t\t\t`useIdentifyCompress: ${this.useIdentifyCompress.toString()}`,\n\t\t\t`inflate: ${Boolean(this.inflate).toString()}`,\n\t\t]);\n\n\t\treturn null;\n\t}\n\n\tprivate async onMessage(data: Data, isBinary: boolean) {\n\t\tconst payload = await this.unpackMessage(data, isBinary);\n\t\tif (!payload) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (payload.op) {\n\t\t\tcase GatewayOpcodes.Dispatch: {\n\t\t\t\tif (this.#status === WebSocketShardStatus.Resuming) {\n\t\t\t\t\tthis.replayedEvents++;\n\t\t\t\t}\n\n\t\t\t\t// eslint-disable-next-line sonarjs/no-nested-switch\n\t\t\t\tswitch (payload.t) {\n\t\t\t\t\tcase GatewayDispatchEvents.Ready: {\n\t\t\t\t\t\tthis.#status = WebSocketShardStatus.Ready;\n\n\t\t\t\t\t\tconst session = {\n\t\t\t\t\t\t\tsequence: payload.s,\n\t\t\t\t\t\t\tsessionId: payload.d.session_id,\n\t\t\t\t\t\t\tshardId: this.id,\n\t\t\t\t\t\t\tshardCount: this.strategy.options.shardCount,\n\t\t\t\t\t\t\tresumeURL: payload.d.resume_gateway_url,\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tawait this.strategy.updateSessionInfo(this.id, session);\n\n\t\t\t\t\t\tthis.emit(WebSocketShardEvents.Ready, { data: payload.d });\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase GatewayDispatchEvents.Resumed: {\n\t\t\t\t\t\tthis.#status = WebSocketShardStatus.Ready;\n\t\t\t\t\t\tthis.debug([`Resumed and replayed ${this.replayedEvents} events`]);\n\t\t\t\t\t\tthis.emit(WebSocketShardEvents.Resumed);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst session = await this.strategy.retrieveSessionInfo(this.id);\n\t\t\t\tif (session) {\n\t\t\t\t\tif (payload.s > session.sequence) {\n\t\t\t\t\t\tawait this.strategy.updateSessionInfo(this.id, { ...session, sequence: payload.s });\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.debug([\n\t\t\t\t\t\t`Received a ${payload.t} event but no session is available. Session information cannot be re-constructed in this state without a full reconnect`,\n\t\t\t\t\t]);\n\t\t\t\t}\n\n\t\t\t\tthis.emit(WebSocketShardEvents.Dispatch, { data: payload });\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayOpcodes.Heartbeat: {\n\t\t\t\tawait this.heartbeat(true);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayOpcodes.Reconnect: {\n\t\t\t\tawait this.destroy({\n\t\t\t\t\treason: 'Told to reconnect by Discord',\n\t\t\t\t\trecover: WebSocketShardDestroyRecovery.Resume,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayOpcodes.InvalidSession: {\n\t\t\t\tthis.debug([`Invalid session; will attempt to resume: ${payload.d.toString()}`]);\n\t\t\t\tconst session = await this.strategy.retrieveSessionInfo(this.id);\n\t\t\t\tif (payload.d && session) {\n\t\t\t\t\tawait this.resume(session);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.destroy({\n\t\t\t\t\t\treason: 'Invalid session',\n\t\t\t\t\t\trecover: WebSocketShardDestroyRecovery.Reconnect,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayOpcodes.Hello: {\n\t\t\t\tthis.emit(WebSocketShardEvents.Hello);\n\t\t\t\tconst jitter = Math.random();\n\t\t\t\tconst firstWait = Math.floor(payload.d.heartbeat_interval * jitter);\n\t\t\t\tthis.debug([`Preparing first heartbeat of the connection with a jitter of ${jitter}; waiting ${firstWait}ms`]);\n\n\t\t\t\ttry {\n\t\t\t\t\tconst controller = new AbortController();\n\t\t\t\t\tthis.initialHeartbeatTimeoutController = controller;\n\t\t\t\t\tawait sleep(firstWait, undefined, { signal: controller.signal });\n\t\t\t\t} catch {\n\t\t\t\t\tthis.debug(['Cancelled initial heartbeat due to #destroy being called']);\n\t\t\t\t\treturn;\n\t\t\t\t} finally {\n\t\t\t\t\tthis.initialHeartbeatTimeoutController = null;\n\t\t\t\t}\n\n\t\t\t\tawait this.heartbeat();\n\n\t\t\t\tthis.debug([`First heartbeat sent, starting to beat every ${payload.d.heartbeat_interval}ms`]);\n\t\t\t\tthis.heartbeatInterval = setInterval(() => void this.heartbeat(), payload.d.heartbeat_interval);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayOpcodes.HeartbeatAck: {\n\t\t\t\tthis.isAck = true;\n\n\t\t\t\tconst ackAt = Date.now();\n\t\t\t\tthis.emit(WebSocketShardEvents.HeartbeatComplete, {\n\t\t\t\t\tackAt,\n\t\t\t\t\theartbeatAt: this.lastHeartbeatAt,\n\t\t\t\t\tlatency: ackAt - this.lastHeartbeatAt,\n\t\t\t\t});\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onError(error: Error) {\n\t\tif ('code' in error && ['ECONNRESET', 'ECONNREFUSED'].includes(error.code as string)) {\n\t\t\tthis.debug(['Failed to connect to the gateway URL specified due to a network error']);\n\t\t\tthis.failedToConnectDueToNetworkError = true;\n\t\t\treturn;\n\t\t}\n\n\t\tthis.emit(WebSocketShardEvents.Error, { error });\n\t}\n\n\tprivate async onClose(code: number) {\n\t\tthis.emit(WebSocketShardEvents.Closed, { code });\n\n\t\tswitch (code) {\n\t\t\tcase CloseCodes.Normal: {\n\t\t\t\treturn this.destroy({\n\t\t\t\t\tcode,\n\t\t\t\t\treason: 'Got disconnected by Discord',\n\t\t\t\t\trecover: WebSocketShardDestroyRecovery.Reconnect,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tcase CloseCodes.Resuming: {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.UnknownError: {\n\t\t\t\tthis.debug([`An unknown error occurred: ${code}`]);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Resume });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.UnknownOpcode: {\n\t\t\t\tthis.debug(['An invalid opcode was sent to Discord.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Resume });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.DecodeError: {\n\t\t\t\tthis.debug(['An invalid payload was sent to Discord.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Resume });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.NotAuthenticated: {\n\t\t\t\tthis.debug(['A request was somehow sent before the identify/resume payload.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Reconnect });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.AuthenticationFailed: {\n\t\t\t\tthis.emit(WebSocketShardEvents.Error, {\n\t\t\t\t\terror: new Error('Authentication failed'),\n\t\t\t\t});\n\t\t\t\treturn this.destroy({ code });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.AlreadyAuthenticated: {\n\t\t\t\tthis.debug(['More than one auth payload was sent.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Reconnect });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.InvalidSeq: {\n\t\t\t\tthis.debug(['An invalid sequence was sent.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Reconnect });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.RateLimited: {\n\t\t\t\tthis.debug(['The WebSocket rate limit has been hit, this should never happen']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Reconnect });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.SessionTimedOut: {\n\t\t\t\tthis.debug(['Session timed out.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Resume });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.InvalidShard: {\n\t\t\t\tthis.emit(WebSocketShardEvents.Error, {\n\t\t\t\t\terror: new Error('Invalid shard'),\n\t\t\t\t});\n\t\t\t\treturn this.destroy({ code });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.ShardingRequired: {\n\t\t\t\tthis.emit(WebSocketShardEvents.Error, {\n\t\t\t\t\terror: new Error('Sharding is required'),\n\t\t\t\t});\n\t\t\t\treturn this.destroy({ code });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.InvalidAPIVersion: {\n\t\t\t\tthis.emit(WebSocketShardEvents.Error, {\n\t\t\t\t\terror: new Error('Used an invalid API version'),\n\t\t\t\t});\n\t\t\t\treturn this.destroy({ code });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.InvalidIntents: {\n\t\t\t\tthis.emit(WebSocketShardEvents.Error, {\n\t\t\t\t\terror: new Error('Used invalid intents'),\n\t\t\t\t});\n\t\t\t\treturn this.destroy({ code });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.DisallowedIntents: {\n\t\t\t\tthis.emit(WebSocketShardEvents.Error, {\n\t\t\t\t\terror: new Error('Used disallowed intents'),\n\t\t\t\t});\n\t\t\t\treturn this.destroy({ code });\n\t\t\t}\n\n\t\t\tdefault: {\n\t\t\t\tthis.debug([\n\t\t\t\t\t`The gateway closed with an unexpected code ${code}, attempting to ${\n\t\t\t\t\t\tthis.failedToConnectDueToNetworkError ? 'reconnect' : 'resume'\n\t\t\t\t\t}.`,\n\t\t\t\t]);\n\t\t\t\treturn this.destroy({\n\t\t\t\t\tcode,\n\t\t\t\t\trecover: this.failedToConnectDueToNetworkError\n\t\t\t\t\t\t? WebSocketShardDestroyRecovery.Reconnect\n\t\t\t\t\t\t: WebSocketShardDestroyRecovery.Resume,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate debug(messages: [string, ...string[]]) {\n\t\tconst message = `${messages[0]}${\n\t\t\tmessages.length > 1\n\t\t\t\t? `\\n${messages\n\t\t\t\t\t\t.slice(1)\n\t\t\t\t\t\t.map((m) => `\t${m}`)\n\t\t\t\t\t\t.join('\\n')}`\n\t\t\t\t: ''\n\t\t}`;\n\n\t\tthis.emit(WebSocketShardEvents.Debug, { message });\n\t}\n}\n","import process from 'node:process';\nimport { Collection } from '@discordjs/collection';\nimport { lazy } from '@discordjs/util';\nimport { APIVersion, GatewayOpcodes } from 'discord-api-types/v10';\nimport { SimpleShardingStrategy } from '../strategies/sharding/SimpleShardingStrategy.js';\nimport { SimpleIdentifyThrottler } from '../throttling/SimpleIdentifyThrottler.js';\nimport type { SessionInfo, OptionalWebSocketManagerOptions, WebSocketManager } from '../ws/WebSocketManager.js';\nimport type { SendRateLimitState } from '../ws/WebSocketShard.js';\n\n/**\n * Valid encoding types\n */\nexport enum Encoding {\n\tJSON = 'json',\n}\n\n/**\n * Valid compression methods\n */\nexport enum CompressionMethod {\n\tZlibStream = 'zlib-stream',\n}\n\nexport const DefaultDeviceProperty = `@discordjs/ws 1.0.1` as `@discordjs/ws ${string}`;\n\nconst getDefaultSessionStore = lazy(() => new Collection<number, SessionInfo | null>());\n\n/**\n * Default options used by the manager\n */\nexport const DefaultWebSocketManagerOptions = {\n\tasync buildIdentifyThrottler(manager: WebSocketManager) {\n\t\tconst info = await manager.fetchGatewayInformation();\n\t\treturn new SimpleIdentifyThrottler(info.session_start_limit.max_concurrency);\n\t},\n\tbuildStrategy: (manager) => new SimpleShardingStrategy(manager),\n\tshardCount: null,\n\tshardIds: null,\n\tlargeThreshold: null,\n\tinitialPresence: null,\n\tidentifyProperties: {\n\t\tbrowser: DefaultDeviceProperty,\n\t\tdevice: DefaultDeviceProperty,\n\t\tos: process.platform,\n\t},\n\tversion: APIVersion,\n\tencoding: Encoding.JSON,\n\tcompression: null,\n\tretrieveSessionInfo(shardId) {\n\t\tconst store = getDefaultSessionStore();\n\t\treturn store.get(shardId) ?? null;\n\t},\n\tupdateSessionInfo(shardId: number, info: SessionInfo | null) {\n\t\tconst store = getDefaultSessionStore();\n\t\tif (info) {\n\t\t\tstore.set(shardId, info);\n\t\t} else {\n\t\t\tstore.delete(shardId);\n\t\t}\n\t},\n\thandshakeTimeout: 30_000,\n\thelloTimeout: 60_000,\n\treadyTimeout: 15_000,\n} as const satisfies OptionalWebSocketManagerOptions;\n\nexport const ImportantGatewayOpcodes = new Set([\n\tGatewayOpcodes.Heartbeat,\n\tGatewayOpcodes.Identify,\n\tGatewayOpcodes.Resume,\n]);\n\nexport function getInitialSendRateLimitState(): SendRateLimitState {\n\treturn {\n\t\tremaining: 120,\n\t\tresetAt: Date.now() + 60_000,\n\t};\n}\n","import { setTimeout as sleep } from 'node:timers/promises';\nimport { Collection } from '@discordjs/collection';\nimport { AsyncQueue } from '@sapphire/async-queue';\nimport type { IIdentifyThrottler } from './IIdentifyThrottler.js';\n\n/**\n * The state of a rate limit key's identify queue.\n */\nexport interface IdentifyState {\n\tqueue: AsyncQueue;\n\tresetsAt: number;\n}\n\n/**\n * Local, in-memory identify throttler.\n */\nexport class SimpleIdentifyThrottler implements IIdentifyThrottler {\n\tprivate readonly states = new Collection<number, IdentifyState>();\n\n\tpublic constructor(private readonly maxConcurrency: number) {}\n\n\t/**\n\t * {@inheritDoc IIdentifyThrottler.waitForIdentify}\n\t */\n\tpublic async waitForIdentify(shardId: number, signal: AbortSignal): Promise<void> {\n\t\tconst key = shardId % this.maxConcurrency;\n\n\t\tconst state = this.states.ensure(key, () => {\n\t\t\treturn {\n\t\t\t\tqueue: new AsyncQueue(),\n\t\t\t\tresetsAt: Number.POSITIVE_INFINITY,\n\t\t\t};\n\t\t});\n\n\t\tawait state.queue.wait({ signal });\n\n\t\ttry {\n\t\t\tconst diff = state.resetsAt - Date.now();\n\t\t\tif (diff <= 5_000) {\n\t\t\t\t// To account for the latency the IDENTIFY payload goes through, we add a bit more wait time\n\t\t\t\tconst time = diff + Math.random() * 1_500;\n\t\t\t\tawait sleep(time);\n\t\t\t}\n\n\t\t\tstate.resetsAt = Date.now() + 5_000;\n\t\t} finally {\n\t\t\tstate.queue.shift();\n\t\t}\n\t}\n}\n","import { isMainThread, parentPort, workerData } from 'node:worker_threads';\nimport { Collection } from '@discordjs/collection';\nimport type { Awaitable } from '@discordjs/util';\nimport { WorkerContextFetchingStrategy } from '../strategies/context/WorkerContextFetchingStrategy.js';\nimport {\n\tWorkerReceivePayloadOp,\n\tWorkerSendPayloadOp,\n\ttype WorkerData,\n\ttype WorkerReceivePayload,\n\ttype WorkerSendPayload,\n} from '../strategies/sharding/WorkerShardingStrategy.js';\nimport type { WebSocketShardDestroyOptions } from '../ws/WebSocketShard.js';\nimport { WebSocketShardEvents, WebSocketShard } from '../ws/WebSocketShard.js';\n\n/**\n * Options for bootstrapping the worker\n */\nexport interface BootstrapOptions {\n\t/**\n\t * Shard events to just arbitrarily forward to the parent thread for the manager to emit\n\t * Note: By default, this will include ALL events\n\t * you most likely want to handle dispatch within the worker itself\n\t */\n\tforwardEvents?: WebSocketShardEvents[];\n\t/**\n\t * Function to call when a shard is created for additional setup\n\t */\n\tshardCallback?(shard: WebSocketShard): Awaitable<void>;\n}\n\n/**\n * Utility class for bootstrapping a worker thread to be used for sharding\n */\nexport class WorkerBootstrapper {\n\t/**\n\t * The data passed to the worker thread\n\t */\n\tprotected readonly data = workerData as WorkerData;\n\n\t/**\n\t * The shards that are managed by this worker\n\t */\n\tprotected readonly shards = new Collection<number, WebSocketShard>();\n\n\tpublic constructor() {\n\t\tif (isMainThread) {\n\t\t\tthrow new Error('Expected WorkerBootstrap to not be used within the main thread');\n\t\t}\n\t}\n\n\t/**\n\t * Helper method to initiate a shard's connection process\n\t */\n\tprotected async connect(shardId: number): Promise<void> {\n\t\tconst shard = this.shards.get(shardId);\n\t\tif (!shard) {\n\t\t\tthrow new RangeError(`Shard ${shardId} does not exist`);\n\t\t}\n\n\t\tawait shard.connect();\n\t}\n\n\t/**\n\t * Helper method to destroy a shard\n\t */\n\tprotected async destroy(shardId: number, options?: WebSocketShardDestroyOptions): Promise<void> {\n\t\tconst shard = this.shards.get(shardId);\n\t\tif (!shard) {\n\t\t\tthrow new RangeError(`Shard ${shardId} does not exist`);\n\t\t}\n\n\t\tawait shard.destroy(options);\n\t}\n\n\t/**\n\t * Helper method to attach event listeners to the parentPort\n\t */\n\tprotected setupThreadEvents(): void {\n\t\tparentPort!\n\t\t\t.on('messageerror', (err) => {\n\t\t\t\tthrow err;\n\t\t\t})\n\t\t\t.on('message', async (payload: WorkerSendPayload) => {\n\t\t\t\tswitch (payload.op) {\n\t\t\t\t\tcase WorkerSendPayloadOp.Connect: {\n\t\t\t\t\t\tawait this.connect(payload.shardId);\n\t\t\t\t\t\tconst response: WorkerReceivePayload = {\n\t\t\t\t\t\t\top: WorkerReceivePayloadOp.Connected,\n\t\t\t\t\t\t\tshardId: payload.shardId,\n\t\t\t\t\t\t};\n\t\t\t\t\t\tparentPort!.postMessage(response);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase WorkerSendPayloadOp.Destroy: {\n\t\t\t\t\t\tawait this.destroy(payload.shardId, payload.options);\n\t\t\t\t\t\tconst response: WorkerReceivePayload = {\n\t\t\t\t\t\t\top: WorkerReceivePayloadOp.Destroyed,\n\t\t\t\t\t\t\tshardId: payload.shardId,\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tparentPort!.postMessage(response);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase WorkerSendPayloadOp.Send: {\n\t\t\t\t\t\tconst shard = this.shards.get(payload.shardId);\n\t\t\t\t\t\tif (!shard) {\n\t\t\t\t\t\t\tthrow new RangeError(`Shard ${payload.shardId} does not exist`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tawait shard.send(payload.payload);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase WorkerSendPayloadOp.SessionInfoResponse: {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase WorkerSendPayloadOp.ShardIdentifyResponse: {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase WorkerSendPayloadOp.FetchStatus: {\n\t\t\t\t\t\tconst shard = this.shards.get(payload.shardId);\n\t\t\t\t\t\tif (!shard) {\n\t\t\t\t\t\t\tthrow new Error(`Shard ${payload.shardId} does not exist`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst response: WorkerReceivePayload = {\n\t\t\t\t\t\t\top: WorkerReceivePayloadOp.FetchStatusResponse,\n\t\t\t\t\t\t\tstatus: shard.status,\n\t\t\t\t\t\t\tnonce: payload.nonce,\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tparentPort!.postMessage(response);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\t/**\n\t * Bootstraps the worker thread with the provided options\n\t */\n\tpublic async bootstrap(options: Readonly<BootstrapOptions> = {}): Promise<void> {\n\t\t// Start by initializing the shards\n\t\tfor (const shardId of this.data.shardIds) {\n\t\t\tconst shard = new WebSocketShard(new WorkerContextFetchingStrategy(this.data), shardId);\n\t\t\tfor (const event of options.forwardEvents ?? Object.values(WebSocketShardEvents)) {\n\t\t\t\t// @ts-expect-error: Event types incompatible\n\t\t\t\tshard.on(event, (data) => {\n\t\t\t\t\tconst payload: WorkerReceivePayload = {\n\t\t\t\t\t\top: WorkerReceivePayloadOp.Event,\n\t\t\t\t\t\tevent,\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\tshardId,\n\t\t\t\t\t};\n\t\t\t\t\tparentPort!.postMessage(payload);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Any additional setup the user might want to do\n\t\t\tawait options.shardCallback?.(shard);\n\t\t\tthis.shards.set(shardId, shard);\n\t\t}\n\n\t\t// Lastly, start listening to messages from the parent thread\n\t\tthis.setupThreadEvents();\n\n\t\tconst message: WorkerReceivePayload = {\n\t\t\top: WorkerReceivePayloadOp.WorkerReady,\n\t\t};\n\t\tparentPort!.postMessage(message);\n\t}\n}\n","import type { REST } from '@discordjs/rest';\nimport { range, type Awaitable } from '@discordjs/util';\nimport { AsyncEventEmitter } from '@vladfrangu/async_event_emitter';\nimport {\n\tRoutes,\n\ttype APIGatewayBotInfo,\n\ttype GatewayIdentifyProperties,\n\ttype GatewayPresenceUpdateData,\n\ttype RESTGetAPIGatewayBotResult,\n\ttype GatewayIntentBits,\n\ttype GatewaySendPayload,\n} from 'discord-api-types/v10';\nimport type { IShardingStrategy } from '../strategies/sharding/IShardingStrategy.js';\nimport type { IIdentifyThrottler } from '../throttling/IIdentifyThrottler.js';\nimport { DefaultWebSocketManagerOptions, type CompressionMethod, type Encoding } from '../utils/constants.js';\nimport type { WebSocketShardDestroyOptions, WebSocketShardEventsMap } from './WebSocketShard.js';\n\n/**\n * Represents a range of shard ids\n */\nexport interface ShardRange {\n\tend: number;\n\tstart: number;\n}\n\n/**\n * Session information for a given shard, used to resume a session\n */\nexport interface SessionInfo {\n\t/**\n\t * URL to use when resuming\n\t */\n\tresumeURL: string;\n\t/**\n\t * The sequence number of the last message sent by the shard\n\t */\n\tsequence: number;\n\t/**\n\t * Session id for this shard\n\t */\n\tsessionId: string;\n\t/**\n\t * The total number of shards at the time of this shard identifying\n\t */\n\tshardCount: number;\n\t/**\n\t * The id of the shard\n\t */\n\tshardId: number;\n}\n\n/**\n * Required options for the WebSocketManager\n */\nexport interface RequiredWebSocketManagerOptions {\n\t/**\n\t * The intents to request\n\t */\n\tintents: GatewayIntentBits | 0;\n\t/**\n\t * The REST instance to use for fetching gateway information\n\t */\n\trest: REST;\n\t/**\n\t * The token to use for identifying with the gateway\n\t */\n\ttoken: string;\n}\n\n/**\n * Optional additional configuration for the WebSocketManager\n */\nexport interface OptionalWebSocketManagerOptions {\n\t/**\n\t * Builds an identify throttler to use for this manager's shards\n\t */\n\tbuildIdentifyThrottler(manager: WebSocketManager): Awaitable<IIdentifyThrottler>;\n\t/**\n\t * Builds the strategy to use for sharding\n\t *\n\t * @example\n\t * ```ts\n\t * const manager = new WebSocketManager({\n\t *  token: process.env.DISCORD_TOKEN,\n\t *  intents: 0, // for no intents\n\t *  rest,\n\t *  buildStrategy: (manager) => new WorkerShardingStrategy(manager, { shardsPerWorker: 2 }),\n\t * });\n\t * ```\n\t */\n\tbuildStrategy(manager: WebSocketManager): IShardingStrategy;\n\t/**\n\t * The compression method to use\n\t *\n\t * @defaultValue `null` (no compression)\n\t */\n\tcompression: CompressionMethod | null;\n\t/**\n\t * The encoding to use\n\t *\n\t * @defaultValue `'json'`\n\t */\n\tencoding: Encoding;\n\t/**\n\t * How long to wait for a shard to connect before giving up\n\t */\n\thandshakeTimeout: number | null;\n\t/**\n\t * How long to wait for a shard's HELLO packet before giving up\n\t */\n\thelloTimeout: number | null;\n\t/**\n\t * Properties to send to the gateway when identifying\n\t */\n\tidentifyProperties: GatewayIdentifyProperties;\n\t/**\n\t * Initial presence data to send to the gateway when identifying\n\t */\n\tinitialPresence: GatewayPresenceUpdateData | null;\n\t/**\n\t * Value between 50 and 250, total number of members where the gateway will stop sending offline members in the guild member list\n\t */\n\tlargeThreshold: number | null;\n\t/**\n\t * How long to wait for a shard's READY packet before giving up\n\t */\n\treadyTimeout: number | null;\n\t/**\n\t * Function used to retrieve session information (and attempt to resume) for a given shard\n\t *\n\t * @example\n\t * ```ts\n\t * const manager = new WebSocketManager({\n\t *   async retrieveSessionInfo(shardId): Awaitable<SessionInfo | null> {\n\t *     // Fetch this info from redis or similar\n\t *     return { sessionId: string, sequence: number };\n\t *     // Return null if no information is found\n\t *   },\n\t * });\n\t * ```\n\t */\n\tretrieveSessionInfo(shardId: number): Awaitable<SessionInfo | null>;\n\t/**\n\t * The total number of shards across all WebsocketManagers you intend to instantiate.\n\t * Use `null` to use Discord's recommended shard count\n\t */\n\tshardCount: number | null;\n\t/**\n\t * The ids of the shards this WebSocketManager should manage.\n\t * Use `null` to simply spawn 0 through `shardCount - 1`\n\t *\n\t * @example\n\t * ```ts\n\t * const manager = new WebSocketManager({\n\t *   shardIds: [1, 3, 7], // spawns shard 1, 3, and 7, nothing else\n\t * });\n\t * ```\n\t * @example\n\t * ```ts\n\t * const manager = new WebSocketManager({\n\t *   shardIds: {\n\t *     start: 3,\n\t *     end: 6,\n\t *   }, // spawns shards 3, 4, 5, and 6\n\t * });\n\t * ```\n\t */\n\tshardIds: number[] | ShardRange | null;\n\t/**\n\t * Function used to store session information for a given shard\n\t */\n\tupdateSessionInfo(shardId: number, sessionInfo: SessionInfo | null): Awaitable<void>;\n\t/**\n\t * The gateway version to use\n\t *\n\t * @defaultValue `'10'`\n\t */\n\tversion: string;\n}\n\nexport type WebSocketManagerOptions = OptionalWebSocketManagerOptions & RequiredWebSocketManagerOptions;\n\nexport type ManagerShardEventsMap = {\n\t[K in keyof WebSocketShardEventsMap]: [\n\t\tWebSocketShardEventsMap[K] extends [] ? { shardId: number } : WebSocketShardEventsMap[K][0] & { shardId: number },\n\t];\n};\n\nexport class WebSocketManager extends AsyncEventEmitter<ManagerShardEventsMap> {\n\t/**\n\t * The options being used by this manager\n\t */\n\tpublic readonly options: WebSocketManagerOptions;\n\n\t/**\n\t * Internal cache for a GET /gateway/bot result\n\t */\n\tprivate gatewayInformation: {\n\t\tdata: APIGatewayBotInfo;\n\t\texpiresAt: number;\n\t} | null = null;\n\n\t/**\n\t * Internal cache for the shard ids\n\t */\n\tprivate shardIds: number[] | null = null;\n\n\t/**\n\t * Strategy used to manage shards\n\t *\n\t * @defaultValue `SimpleShardingStrategy`\n\t */\n\tprivate readonly strategy: IShardingStrategy;\n\n\tpublic constructor(options: Partial<OptionalWebSocketManagerOptions> & RequiredWebSocketManagerOptions) {\n\t\tsuper();\n\t\tthis.options = { ...DefaultWebSocketManagerOptions, ...options };\n\t\tthis.strategy = this.options.buildStrategy(this);\n\t}\n\n\t/**\n\t * Fetches the gateway information from Discord - or returns it from cache if available\n\t *\n\t * @param force - Whether to ignore the cache and force a fresh fetch\n\t */\n\tpublic async fetchGatewayInformation(force = false) {\n\t\tif (this.gatewayInformation) {\n\t\t\tif (this.gatewayInformation.expiresAt <= Date.now()) {\n\t\t\t\tthis.gatewayInformation = null;\n\t\t\t} else if (!force) {\n\t\t\t\treturn this.gatewayInformation.data;\n\t\t\t}\n\t\t}\n\n\t\tconst data = (await this.options.rest.get(Routes.gatewayBot())) as RESTGetAPIGatewayBotResult;\n\n\t\t// For single sharded bots session_start_limit.reset_after will be 0, use 5 seconds as a minimum expiration time\n\t\tthis.gatewayInformation = { data, expiresAt: Date.now() + (data.session_start_limit.reset_after || 5_000) };\n\t\treturn this.gatewayInformation.data;\n\t}\n\n\t/**\n\t * Updates your total shard count on-the-fly, spawning shards as needed\n\t *\n\t * @param shardCount - The new shard count to use\n\t */\n\tpublic async updateShardCount(shardCount: number | null) {\n\t\tawait this.strategy.destroy({ reason: 'User is adjusting their shards' });\n\t\tthis.options.shardCount = shardCount;\n\n\t\tconst shardIds = await this.getShardIds(true);\n\t\tawait this.strategy.spawn(shardIds);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Yields the total number of shards across for your bot, accounting for Discord recommendations\n\t */\n\tpublic async getShardCount(): Promise<number> {\n\t\tif (this.options.shardCount) {\n\t\t\treturn this.options.shardCount;\n\t\t}\n\n\t\tconst shardIds = await this.getShardIds();\n\t\treturn Math.max(...shardIds) + 1;\n\t}\n\n\t/**\n\t * Yields the ids of the shards this manager should manage\n\t */\n\tpublic async getShardIds(force = false): Promise<number[]> {\n\t\tif (this.shardIds && !force) {\n\t\t\treturn this.shardIds;\n\t\t}\n\n\t\tlet shardIds: number[];\n\t\tif (this.options.shardIds) {\n\t\t\tif (Array.isArray(this.options.shardIds)) {\n\t\t\t\tshardIds = this.options.shardIds;\n\t\t\t} else {\n\t\t\t\tconst { start, end } = this.options.shardIds;\n\t\t\t\tshardIds = [...range({ start, end: end + 1 })];\n\t\t\t}\n\t\t} else {\n\t\t\tconst data = await this.fetchGatewayInformation();\n\t\t\tshardIds = [...range(this.options.shardCount ?? data.shards)];\n\t\t}\n\n\t\tthis.shardIds = shardIds;\n\t\treturn shardIds;\n\t}\n\n\tpublic async connect() {\n\t\tconst shardCount = await this.getShardCount();\n\n\t\tconst data = await this.fetchGatewayInformation();\n\t\tif (data.session_start_limit.remaining < shardCount) {\n\t\t\tthrow new Error(\n\t\t\t\t`Not enough sessions remaining to spawn ${shardCount} shards; only ${\n\t\t\t\t\tdata.session_start_limit.remaining\n\t\t\t\t} remaining; resets at ${new Date(Date.now() + data.session_start_limit.reset_after).toISOString()}`,\n\t\t\t);\n\t\t}\n\n\t\t// First, make sure all our shards are spawned\n\t\tawait this.updateShardCount(shardCount);\n\t\tawait this.strategy.connect();\n\t}\n\n\tpublic destroy(options?: Omit<WebSocketShardDestroyOptions, 'recover'>) {\n\t\treturn this.strategy.destroy(options);\n\t}\n\n\tpublic send(shardId: number, payload: GatewaySendPayload) {\n\t\treturn this.strategy.send(shardId, payload);\n\t}\n\n\tpublic fetchStatus() {\n\t\treturn this.strategy.fetchStatus();\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAAA,WAAA;AAAAC,QAAA,CAAAD,WAAA;EAAAE,UAAA,EAAAA,CAAA,KAAAA,UAAA;EAAAC,iBAAA,EAAAA,CAAA,KAAAA,iBAAA;EAAAC,qBAAA,EAAAA,CAAA,KAAAA,qBAAA;EAAAC,8BAAA,EAAAA,CAAA,KAAAA,8BAAA;EAAAC,QAAA,EAAAA,CAAA,KAAAA,QAAA;EAAAC,uBAAA,EAAAA,CAAA,KAAAA,uBAAA;EAAAC,6BAAA,EAAAA,CAAA,KAAAA,6BAAA;EAAAC,uBAAA,EAAAA,CAAA,KAAAA,uBAAA;EAAAC,sBAAA,EAAAA,CAAA,KAAAA,sBAAA;EAAAC,gBAAA,EAAAA,CAAA,KAAAA,gBAAA;EAAAC,cAAA,EAAAA,CAAA,KAAAA,cAAA;EAAAC,6BAAA,EAAAA,CAAA,KAAAA,6BAAA;EAAAC,oBAAA,EAAAA,CAAA,KAAAA,oBAAA;EAAAC,oBAAA,EAAAA,CAAA,KAAAA,oBAAA;EAAAC,kBAAA,EAAAA,CAAA,KAAAA,kBAAA;EAAAC,6BAAA,EAAAA,CAAA,KAAAA,6BAAA;EAAAC,sBAAA,EAAAA,CAAA,KAAAA,sBAAA;EAAAC,mBAAA,EAAAA,CAAA,KAAAA,mBAAA;EAAAC,sBAAA,EAAAA,CAAA,KAAAA,sBAAA;EAAAC,4BAAA,EAAAA,CAAA,KAAAA,4BAAA;EAAAC,gCAAA,EAAAA,CAAA,KAAAA,gCAAA;EAAAC,OAAA,EAAAA,CAAA,KAAAA;AAAA;AAAAC,MAAA,CAAAC,OAAA,GAAAC,YAAA,CAAA1B,WAAA;;;ACkCA,eAAsBsB,iCAAiCK,OAAA,EAA6D;EAEnH,MAAM;IACLC,sBAAA;IACAC,aAAA;IACAC,mBAAA;IACAC,iBAAA;IACAC,UAAA;IACAC,QAAA;IACAC,IAAA;IACA,GAAGC;EACJ,IAAIR,OAAA,CAAQS,OAAA;EAGZ,OAAO;IACN,GAAGD,cAAA;IACHE,kBAAA,EAAoB,MAAMV,OAAA,CAAQW,uBAAA,CAAwB;IAC1DN,UAAA,EAAY,MAAML,OAAA,CAAQY,aAAA,CAAc;EACzC;AACD;AAnBsBC,MAAA,CAAAlB,gCAAA;;;AC9Bf,IAAMd,6BAAA,GAAN,MAAMiC,8BAAA,CAAkE;EAiBvEC,YAA6Bf,OAAA,EAA2CS,OAAA,EAAkC;IAA7E,KAAAT,OAAA,GAAAA,OAAA;IAA2C,KAAAS,OAAA,GAAAA,OAAA;EAAmC;EArBnH;IAI+EI,MAAA;EAAA;EAAA;EAAA;EAG9E,OAAeG,cAAA,GAAiB,mBAAIC,OAAA,CAA8C;EAElF,aAAqBC,gBAAgBlB,OAAA,EAAwD;IAC5F,MAAMmB,SAAA,GAAYL,8BAAA,CAA8BE,cAAA,CAAeI,GAAA,CAAIpB,OAAO;IAC1E,IAAImB,SAAA,EAAW;MACd,OAAOA,SAAA;IACR;IAEA,MAAME,YAAA,GAAe,MAAMrB,OAAA,CAAQS,OAAA,CAAQR,sBAAA,CAAuBD,OAAO;IACzEc,8BAAA,CAA8BE,cAAA,CAAeM,GAAA,CAAItB,OAAA,EAASqB,YAAY;IAEtE,OAAOA,YAAA;EACR;EAIA,MAAalB,oBAAoBoB,OAAA,EAA8C;IAC9E,OAAO,KAAKvB,OAAA,CAAQS,OAAA,CAAQN,mBAAA,CAAoBoB,OAAO;EACxD;EAEOnB,kBAAkBmB,OAAA,EAAiBC,WAAA,EAAiC;IAC1E,OAAO,KAAKxB,OAAA,CAAQS,OAAA,CAAQL,iBAAA,CAAkBmB,OAAA,EAASC,WAAW;EACnE;EAEA,MAAaC,gBAAgBF,OAAA,EAAiBG,MAAA,EAAoC;IACjF,MAAMP,SAAA,GAAY,MAAML,8BAAA,CAA8BI,eAAA,CAAgB,KAAKlB,OAAO;IAClF,MAAMmB,SAAA,CAAUM,eAAA,CAAgBF,OAAA,EAASG,MAAM;EAChD;AACD;;;ACnCA,IAAAC,2BAAA,GAAyCC,OAAA;AACzC,IAAAC,kBAAA,GAA2BD,OAAA;;;ACD3B,IAAAE,kBAAA,GAAqBF,OAAA;AACrB,IAAAG,gBAAA,GAA0CH,OAAA;AAC1C,IAAAI,0BAAA,GAAuBJ,OAAA;AACvB,IAAAK,iBAAA,GAA2BL,OAAA;AAgBpB,IAAKpC,mBAAA,GAAL,gBAAK0C,oBAAA,IAAL;EACNA,oBAAA,CAAAA,oBAAA;EACAA,oBAAA,CAAAA,oBAAA;EACAA,oBAAA,CAAAA,oBAAA;EACAA,oBAAA,CAAAA,oBAAA;EACAA,oBAAA,CAAAA,oBAAA;EACAA,oBAAA,CAAAA,oBAAA;EANW,OAAAA,oBAAA;AAAA,GAAA1C,mBAAA;AAiBL,IAAKD,sBAAA,GAAL,gBAAK4C,uBAAA,IAAL;EACNA,uBAAA,CAAAA,uBAAA;EACAA,uBAAA,CAAAA,uBAAA;EACAA,uBAAA,CAAAA,uBAAA;EACAA,uBAAA,CAAAA,uBAAA;EACAA,uBAAA,CAAAA,uBAAA;EACAA,uBAAA,CAAAA,uBAAA;EACAA,uBAAA,CAAAA,uBAAA;EACAA,uBAAA,CAAAA,uBAAA;EACAA,uBAAA,CAAAA,uBAAA;EATW,OAAAA,uBAAA;AAAA,GAAA5C,sBAAA;AAyCL,IAAME,sBAAA,GAAN,MAA0D;EA7EjE;IA6EiEoB,MAAA;EAAA;EAC/Cb,OAAA;EAEAS,OAAA;EAEjB,CAAA2B,OAAA,GAAqB,EAAC;EAEb,CAAAC,eAAA,GAAmB,IAAIJ,iBAAA,CAAAK,UAAA,CAA2B;EAE1CC,eAAA,GAAkB,IAAIN,iBAAA,CAAAK,UAAA,CAA+B;EAErDE,eAAA,GAAkB,IAAIP,iBAAA,CAAAK,UAAA,CAA+B;EAErDG,mBAAA,GAAsB,IAAIR,iBAAA,CAAAK,UAAA,CAA2D;EAErFI,0BAAA,GAA6B,IAAIT,iBAAA,CAAAK,UAAA,CAAoC;EAE9EnB,SAAA;EAEDJ,YAAYf,OAAA,EAA2BS,OAAA,EAAwC;IACrF,KAAKT,OAAA,GAAUA,OAAA;IACf,KAAKS,OAAA,GAAUA,OAAA;EAChB;EAAA;AAAA;AAAA;EAKA,MAAakC,MAAMrC,QAAA,EAAoB;IACtC,MAAMsC,eAAA,GAAkB,KAAKnC,OAAA,CAAQmC,eAAA,KAAoB,QAAQtC,QAAA,CAASuC,MAAA,GAAS,KAAKpC,OAAA,CAAQmC,eAAA;IAChG,MAAME,eAAA,GAAkB,MAAMnD,gCAAA,CAAiC,KAAKK,OAAO;IAE3E,MAAM+C,KAAA,GAAQC,IAAA,CAAKC,IAAA,CAAK3C,QAAA,CAASuC,MAAA,GAASD,eAAe;IACzD,MAAMM,QAAA,GAA4B,EAAC;IAEnC,SAASC,GAAA,GAAM,GAAGA,GAAA,GAAMJ,KAAA,EAAOI,GAAA,IAAO;MACrC,MAAMC,KAAA,GAAQ9C,QAAA,CAAS8C,KAAA,CAAMD,GAAA,GAAMP,eAAA,GAAkBO,GAAA,GAAM,KAAKP,eAAe;MAC/E,MAAMS,WAAA,GAAyB;QAC9B,GAAGP,eAAA;QACHxC,QAAA,EAAU8C;MACX;MAEAF,QAAA,CAASI,IAAA,CAAK,KAAKC,WAAA,CAAYF,WAAU,CAAC;IAC3C;IAEA,MAAMG,OAAA,CAAQC,GAAA,CAAIP,QAAQ;EAC3B;EAAA;AAAA;AAAA;EAKA,MAAaQ,QAAA,EAAU;IACtB,MAAMR,QAAA,GAAW,EAAC;IAElB,WAAW,CAAC3B,OAAA,EAASoC,MAAM,KAAK,KAAK,CAAAtB,eAAA,CAAiBuB,OAAA,CAAQ,GAAG;MAChE,MAAMC,OAAA,GAA6B;QAClCC,EAAA,EAAI;QACJvC;MACD;MAGA,MAAMwC,OAAA,GAAU,IAAIP,OAAA,CAAeQ,QAAA,IAAY,KAAKzB,eAAA,CAAgBjB,GAAA,CAAIC,OAAA,EAASyC,QAAO,CAAC;MACzFL,MAAA,CAAOM,WAAA,CAAYJ,OAAO;MAC1BX,QAAA,CAASI,IAAA,CAAKS,OAAO;IACtB;IAEA,MAAMP,OAAA,CAAQC,GAAA,CAAIP,QAAQ;EAC3B;EAAA;AAAA;AAAA;EAKA,MAAagB,QAAQzD,OAAA,GAAyD,CAAC,GAAG;IACjF,MAAMyC,QAAA,GAAW,EAAC;IAElB,WAAW,CAAC3B,OAAA,EAASoC,MAAM,KAAK,KAAK,CAAAtB,eAAA,CAAiBuB,OAAA,CAAQ,GAAG;MAChE,MAAMC,OAAA,GAA6B;QAClCC,EAAA,EAAI;QACJvC,OAAA;QACAd;MACD;MAEAyC,QAAA,CAASI,IAAA;MAAA;MAER,IAAIE,OAAA,CAAeQ,QAAA,IAAY,KAAKxB,eAAA,CAAgBlB,GAAA,CAAIC,OAAA,EAASyC,QAAO,CAAC,EAAEG,IAAA,CAAK,YAAYR,MAAA,CAAOS,SAAA,CAAU,CAAC,CAC/G;MACAT,MAAA,CAAOM,WAAA,CAAYJ,OAAO;IAC3B;IAEA,KAAK,CAAAzB,OAAA,GAAW,EAAC;IACjB,KAAK,CAAAC,eAAA,CAAiBgC,KAAA,CAAM;IAE5B,MAAMb,OAAA,CAAQC,GAAA,CAAIP,QAAQ;EAC3B;EAAA;AAAA;AAAA;EAKOoB,KAAK/C,OAAA,EAAiBgD,IAAA,EAA0B;IACtD,MAAMZ,MAAA,GAAS,KAAK,CAAAtB,eAAA,CAAiBjB,GAAA,CAAIG,OAAO;IAChD,IAAI,CAACoC,MAAA,EAAQ;MACZ,MAAM,IAAIa,KAAA,CAAM,6BAA6BjD,OAAO,EAAE;IACvD;IAEA,MAAMsC,OAAA,GAA6B;MAClCC,EAAA,EAAI;MACJvC,OAAA;MACAsC,OAAA,EAASU;IACV;IACAZ,MAAA,CAAOM,WAAA,CAAYJ,OAAO;EAC3B;EAAA;AAAA;AAAA;EAKA,MAAaY,YAAA,EAAc;IAC1B,MAAMC,QAAA,GAAW,IAAIzC,iBAAA,CAAAK,UAAA,CAAyC;IAE9D,WAAW,CAACf,OAAA,EAASoC,MAAM,KAAK,KAAK,CAAAtB,eAAA,CAAiBuB,OAAA,CAAQ,GAAG;MAChE,MAAMe,KAAA,GAAQ3B,IAAA,CAAK4B,MAAA,CAAO;MAC1B,MAAMf,OAAA,GAA6B;QAClCC,EAAA,EAAI;QACJvC,OAAA;QACAoD;MACD;MAGA,MAAMZ,OAAA,GAAU,IAAIP,OAAA,CAA+BQ,QAAA,IAAY,KAAKvB,mBAAA,CAAoBnB,GAAA,CAAIqD,KAAA,EAAOX,QAAO,CAAC;MAC3GL,MAAA,CAAOM,WAAA,CAAYJ,OAAO;MAE1B,MAAMgB,MAAA,GAAS,MAAMd,OAAA;MACrBW,QAAA,CAASpD,GAAA,CAAIC,OAAA,EAASsD,MAAM;IAC7B;IAEA,OAAOH,QAAA;EACR;EAEA,MAAcnB,YAAYF,WAAA,EAAwB;IACjD,MAAMM,MAAA,GAAS,IAAI3B,0BAAA,CAAA8C,MAAA,CAAO,KAAKC,iBAAA,CAAkB,GAAG;MAAEC,UAAA,EAAA3B;IAAW,CAAC;IAElE,UAAMvB,kBAAA,CAAAmD,IAAA,EAAKtB,MAAA,EAAQ,QAAQ;IAE3B,MAAM,KAAKuB,kBAAA,CAAmBvB,MAAM;IAEpCA,MAAA,CACEwB,EAAA,CAAG,SAAUC,GAAA,IAAQ;MACrB,MAAMA,GAAA;IACP,CAAC,EACAD,EAAA,CAAG,gBAAiBC,GAAA,IAAQ;MAC5B,MAAMA,GAAA;IACP,CAAC,EACAD,EAAA,CAAG,WAAW,MAAOtB,OAAA,IAAkC,KAAKwB,SAAA,CAAU1B,MAAA,EAAQE,OAAO,CAAC;IAExF,KAAK,CAAAzB,OAAA,CAASkB,IAAA,CAAKK,MAAM;IACzB,WAAWpC,OAAA,IAAW8B,WAAA,CAAW/C,QAAA,EAAU;MAC1C,KAAK,CAAA+B,eAAA,CAAiBf,GAAA,CAAIC,OAAA,EAASoC,MAAM;IAC1C;EACD;EAEQoB,kBAAA,EAA4B;IACnC,MAAMO,IAAA,GAAO,KAAK7E,OAAA,CAAQ8E,UAAA;IAE1B,IAAI,CAACD,IAAA,EAAM;MACV,WAAOvD,gBAAA,CAAAyD,IAAA,EAAKC,SAAA,EAAW,kBAAkB;IAC1C;IAEA,QAAI1D,gBAAA,CAAA2D,UAAA,EAAWJ,IAAI,GAAG;MACrB,OAAOA,IAAA;IACR;IAEA,IAAI,cAAcK,IAAA,CAAKL,IAAI,GAAG;MAC7B,WAAOvD,gBAAA,CAAA6D,OAAA,EAAQN,IAAI;IACpB;IAEA,IAAI;MACH,OAAO1D,OAAA,CAAQgE,OAAA,CAAQN,IAAI;IAC5B,QAAQ;MACP,WAAOvD,gBAAA,CAAA6D,OAAA,EAAQN,IAAI;IACpB;EACD;EAEA,MAAcJ,mBAAmBvB,MAAA,EAA+B;IAC/D,OAAO,IAAIH,OAAA,CAASQ,QAAA,IAAY;MAC/B,MAAM6B,OAAA,GAAU,eAAAhF,MAAA,CAACgD,OAAA,IAAkC;QAClD,IAAIA,OAAA,CAAQC,EAAA,KAAO,qBAAoC;UACtDE,QAAA,CAAQ;UACRL,MAAA,CAAOmC,GAAA,CAAI,WAAWD,OAAO;QAC9B;MACD,GALgB;MAOhBlC,MAAA,CAAOwB,EAAA,CAAG,WAAWU,OAAO;IAC7B,CAAC;EACF;EAEA,MAAcR,UAAU1B,MAAA,EAAgBE,OAAA,EAA+B;IACtE,QAAQA,OAAA,CAAQC,EAAA;MACf,KAAK;QAAkC;UACtC,KAAKvB,eAAA,CAAgBnB,GAAA,CAAIyC,OAAA,CAAQtC,OAAO,IAAI;UAC5C,KAAKgB,eAAA,CAAgBwD,MAAA,CAAOlC,OAAA,CAAQtC,OAAO;UAC3C;QACD;MAEA,KAAK;QAAkC;UACtC,KAAKiB,eAAA,CAAgBpB,GAAA,CAAIyC,OAAA,CAAQtC,OAAO,IAAI;UAC5C,KAAKiB,eAAA,CAAgBuD,MAAA,CAAOlC,OAAA,CAAQtC,OAAO;UAC3C;QACD;MAEA,KAAK;QAA8B;UAClC,KAAKvB,OAAA,CAAQgG,IAAA,CAAKnC,OAAA,CAAQoC,KAAA,EAAO;YAAE,GAAGpC,OAAA,CAAQU,IAAA;YAAMhD,OAAA,EAASsC,OAAA,CAAQtC;UAAQ,CAAC;UAC9E;QACD;MAEA,KAAK;QAA4C;UAChD,MAAM2E,OAAA,GAAU,MAAM,KAAKlG,OAAA,CAAQS,OAAA,CAAQN,mBAAA,CAAoB0D,OAAA,CAAQtC,OAAO;UAC9E,MAAM4E,QAAA,GAA8B;YACnCrC,EAAA,EAAI;YACJa,KAAA,EAAOd,OAAA,CAAQc,KAAA;YACfuB;UACD;UACAvC,MAAA,CAAOM,WAAA,CAAYkC,QAAQ;UAC3B;QACD;MAEA,KAAK;QAA0C;UAC9C,MAAM,KAAKnG,OAAA,CAAQS,OAAA,CAAQL,iBAAA,CAAkByD,OAAA,CAAQtC,OAAA,EAASsC,OAAA,CAAQqC,OAAO;UAC7E;QACD;MAEA,KAAK;QAAwC;UAC5C,MAAM/E,SAAA,GAAY,MAAM,KAAKD,eAAA,CAAgB;UAG7C,IAAI;YACH,MAAMkF,UAAA,GAAa,IAAIC,eAAA,CAAgB;YACvC,KAAK3D,0BAAA,CAA2BpB,GAAA,CAAIuC,OAAA,CAAQc,KAAA,EAAOyB,UAAU;YAC7D,MAAMjF,SAAA,CAAUM,eAAA,CAAgBoC,OAAA,CAAQtC,OAAA,EAAS6E,UAAA,CAAW1E,MAAM;UACnE,QAAQ;YACP;UACD;UAEA,MAAMyE,QAAA,GAA8B;YACnCrC,EAAA,EAAI;YACJa,KAAA,EAAOd,OAAA,CAAQc,KAAA;YACf2B,EAAA,EAAI;UACL;UACA3C,MAAA,CAAOM,WAAA,CAAYkC,QAAQ;UAC3B;QACD;MAEA,KAAK;QAA4C;UAChD,KAAK1D,mBAAA,CAAoBrB,GAAA,CAAIyC,OAAA,CAAQc,KAAK,IAAId,OAAA,CAAQgB,MAAM;UAC5D,KAAKpC,mBAAA,CAAoBsD,MAAA,CAAOlC,OAAA,CAAQc,KAAK;UAC7C;QACD;MAEA,KAAK;QAAoC;UACxC;QACD;MAEA,KAAK;QAAuC;UAC3C,KAAKjC,0BAAA,CAA2BtB,GAAA,CAAIyC,OAAA,CAAQc,KAAK,GAAG4B,KAAA,CAAM;UAC1D,KAAK7D,0BAAA,CAA2BqD,MAAA,CAAOlC,OAAA,CAAQc,KAAK;UAEpD,MAAMwB,QAAA,GAA8B;YACnCrC,EAAA,EAAI;YACJa,KAAA,EAAOd,OAAA,CAAQc,KAAA;YACf2B,EAAA,EAAI;UACL;UACA3C,MAAA,CAAOM,WAAA,CAAYkC,QAAQ;UAE3B;QACD;IACD;EACD;EAEA,MAAcjF,gBAAA,EAA+C;IAC5D,KAAKC,SAAA,KAAc,MAAM,KAAKnB,OAAA,CAAQS,OAAA,CAAQR,sBAAA,CAAuB,KAAKD,OAAO;IACjF,OAAO,KAAKmB,SAAA;EACb;AACD;;;ADzVO,IAAM7B,6BAAA,GAAN,MAAwE;EAQvEyB,YAA4BN,OAAA,EAAkC;IAAlC,KAAAA,OAAA,GAAAA,OAAA;IAClC,IAAIkB,2BAAA,CAAA6E,YAAA,EAAc;MACjB,MAAM,IAAIhC,KAAA,CAAM,qEAAqE;IACtF;IAEA7C,2BAAA,CAAA8E,UAAA,CAAYtB,EAAA,CAAG,WAAYtB,OAAA,IAA+B;MACzD,IAAIA,OAAA,CAAQC,EAAA,kCAAgD;QAC3D,KAAK4C,eAAA,CAAgBtF,GAAA,CAAIyC,OAAA,CAAQc,KAAK,IAAId,OAAA,CAAQqC,OAAO;QACzD,KAAKQ,eAAA,CAAgBX,MAAA,CAAOlC,OAAA,CAAQc,KAAK;MAC1C;MAEA,IAAId,OAAA,CAAQC,EAAA,oCAAkD;QAC7D,MAAMC,OAAA,GAAU,KAAK4C,uBAAA,CAAwBvF,GAAA,CAAIyC,OAAA,CAAQc,KAAK;QAC9D,IAAId,OAAA,CAAQyC,EAAA,EAAI;UACfvC,OAAA,EAAS6B,OAAA,CAAQ;QAClB,OAAO;UAEN7B,OAAA,EAAS6C,MAAA,CAAO7C,OAAA,CAAQrC,MAAA,CAAOmF,MAAM;QACtC;QAEA,KAAKF,uBAAA,CAAwBZ,MAAA,CAAOlC,OAAA,CAAQc,KAAK;MAClD;IACD,CAAC;EACF;EA1CD;IAW+E9D,MAAA;EAAA;EAC7D6F,eAAA,GAAkB,IAAI7E,kBAAA,CAAAS,UAAA,CAA0D;EAEhFqE,uBAAA,GAA0B,IAAI9E,kBAAA,CAAAS,UAAA,CAG7C;EA2BF,MAAanC,oBAAoBoB,OAAA,EAA8C;IAC9E,MAAMoD,KAAA,GAAQ3B,IAAA,CAAK4B,MAAA,CAAO;IAC1B,MAAMf,OAAA,GAAgC;MACrCC,EAAA;MACAvC,OAAA;MACAoD;IACD;IAEA,MAAMZ,OAAA,GAAU,IAAIP,OAAA,CAA6BQ,QAAA,IAAY,KAAK0C,eAAA,CAAgBpF,GAAA,CAAIqD,KAAA,EAAOX,QAAO,CAAC;IACrGrC,2BAAA,CAAA8E,UAAA,CAAYxC,WAAA,CAAYJ,OAAO;IAC/B,OAAOE,OAAA;EACR;EAEO3D,kBAAkBmB,OAAA,EAAiBC,WAAA,EAAiC;IAC1E,MAAMqC,OAAA,GAAgC;MACrCC,EAAA;MACAvC,OAAA;MACA2E,OAAA,EAAS1E;IACV;IACAG,2BAAA,CAAA8E,UAAA,CAAYxC,WAAA,CAAYJ,OAAO;EAChC;EAEA,MAAapC,gBAAgBF,OAAA,EAAiBG,MAAA,EAAoC;IACjF,MAAMiD,KAAA,GAAQ3B,IAAA,CAAK4B,MAAA,CAAO;IAE1B,MAAMf,OAAA,GAAgC;MACrCC,EAAA;MACAa,KAAA;MACApD;IACD;IACA,MAAMwC,OAAA,GAAU,IAAIP,OAAA,CAAc,CAACQ,QAAA,EAAS4C,MAAA;IAAA;IAE3C,KAAKD,uBAAA,CAAwBrF,GAAA,CAAIqD,KAAA,EAAO;MAAEjD,MAAA;MAAQkE,OAAA,EAAA5B,QAAA;MAAS4C;IAAO,CAAC,CACpE;IAEAjF,2BAAA,CAAA8E,UAAA,CAAYxC,WAAA,CAAYJ,OAAO;IAE/B,MAAMiD,QAAA,GAAW,eAAAjG,MAAA,OAAM;MACtB,MAAMkG,QAAA,GAAgC;QACrCjD,EAAA;QACAa;MACD;MAEAhD,2BAAA,CAAA8E,UAAA,CAAYxC,WAAA,CAAY8C,QAAO;IAChC,GAPiB;IASjBrF,MAAA,CAAOsF,gBAAA,CAAiB,SAASF,QAAQ;IAEzC,IAAI;MACH,MAAM/C,OAAA;IACP,UAAE;MACDrC,MAAA,CAAOuF,mBAAA,CAAoB,SAASH,QAAQ;IAC7C;EACD;AACD;;;AElGA,IAAAI,kBAAA,GAA2BtF,OAAA;;;ACC3B,IAAAuF,kBAAA,GAAuBvF,OAAA;AACvB,IAAAwF,mBAAA,GAAqBxF,OAAA;AACrB,IAAAyF,kBAAA,GAAqEzF,OAAA;AACrE,IAAA0F,gBAAA,GAAoC1F,OAAA;AACpC,IAAA2F,eAAA,GAAgC3F,OAAA;AAChC,IAAA4F,gBAAA,GAA4B5F,OAAA;AAC5B,IAAA6F,gBAAA,GAAwB7F,OAAA;AACxB,IAAA8F,kBAAA,GAA2B9F,OAAA;AAC3B,IAAA+F,YAAA,GAAqB/F,OAAA;AACrB,IAAAgG,mBAAA,GAA2BhG,OAAA;AAC3B,IAAAiG,0BAAA,GAAkCjG,OAAA;AAClC,IAAAkG,WAAA,GASOlG,OAAA;AACP,IAAAmG,SAAA,GAAqCnG,OAAA;;;ACtBrC,IAAAoG,mBAAA,GAAoBC,OAAA,CAAArG,OAAA;AACpB,IAAAsG,kBAAA,GAA2BtG,OAAA;AAC3B,IAAAuG,WAAA,GAAqBvG,OAAA;AACrB,IAAAwG,UAAA,GAA2CxG,OAAA;;;ACH3C,IAAAyG,eAAA,GAAoCzG,OAAA;AACpC,IAAA0G,kBAAA,GAA2B1G,OAAA;AAC3B,IAAA2G,kBAAA,GAA2B3G,OAAA;AAcpB,IAAM9C,uBAAA,GAAN,MAA4D;EAG3DiC,YAA6ByH,cAAA,EAAwB;IAAxB,KAAAA,cAAA,GAAAA,cAAA;EAAyB;EAnB9D;IAgBmE3H,MAAA;EAAA;EACjD4H,MAAA,GAAS,IAAIH,kBAAA,CAAAhG,UAAA,CAAkC;EAAA;AAAA;AAAA;EAOhE,MAAab,gBAAgBF,OAAA,EAAiBG,MAAA,EAAoC;IACjF,MAAMgH,GAAA,GAAMnH,OAAA,GAAU,KAAKiH,cAAA;IAE3B,MAAMG,KAAA,GAAQ,KAAKF,MAAA,CAAOG,MAAA,CAAOF,GAAA,EAAK,MAAM;MAC3C,OAAO;QACNG,KAAA,EAAO,IAAIN,kBAAA,CAAAO,UAAA,CAAW;QACtBC,QAAA,EAAUC,MAAA,CAAOC;MAClB;IACD,CAAC;IAED,MAAMN,KAAA,CAAME,KAAA,CAAMK,IAAA,CAAK;MAAExH;IAAO,CAAC;IAEjC,IAAI;MACH,MAAMyH,IAAA,GAAOR,KAAA,CAAMI,QAAA,GAAWK,IAAA,CAAKC,GAAA,CAAI;MACvC,IAAIF,IAAA,IAAQ,KAAO;QAElB,MAAMG,IAAA,GAAOH,IAAA,GAAOnG,IAAA,CAAK4B,MAAA,CAAO,IAAI;QACpC,UAAMyD,eAAA,CAAAkB,UAAA,EAAMD,IAAI;MACjB;MAEAX,KAAA,CAAMI,QAAA,GAAWK,IAAA,CAAKC,GAAA,CAAI,IAAI;IAC/B,UAAE;MACDV,KAAA,CAAME,KAAA,CAAMW,KAAA,CAAM;IACnB;EACD;AACD;;;ADrCO,IAAK7K,QAAA,GAAL,gBAAK8K,SAAA,IAAL;EACNA,SAAA,WAAO;EADI,OAAAA,SAAA;AAAA,GAAA9K,QAAA;AAOL,IAAKH,iBAAA,GAAL,gBAAKkL,kBAAA,IAAL;EACNA,kBAAA,iBAAa;EADF,OAAAA,kBAAA;AAAA,GAAAlL,iBAAA;AAIL,IAAMC,qBAAA,GAAwB;AAErC,IAAMkL,sBAAA,OAAyBxB,WAAA,CAAAyB,IAAA,EAAK,MAAM,IAAI1B,kBAAA,CAAA5F,UAAA,CAAuC,CAAC;AAK/E,IAAM5D,8BAAA,GAAiC;EAC7C,MAAMuB,uBAAuBD,OAAA,EAA2B;IACvD,MAAM6J,IAAA,GAAO,MAAM7J,OAAA,CAAQW,uBAAA,CAAwB;IACnD,OAAO,IAAI7B,uBAAA,CAAwB+K,IAAA,CAAKC,mBAAA,CAAoBC,eAAe;EAC5E;EACA7J,aAAA,EAAgBF,OAAA,IAAY,IAAIjB,sBAAA,CAAuBiB,OAAO;EAC9DK,UAAA,EAAY;EACZC,QAAA,EAAU;EACV0J,cAAA,EAAgB;EAChBC,eAAA,EAAiB;EACjBC,kBAAA,EAAoB;IACnBC,OAAA,EAAS1L,qBAAA;IACT2L,MAAA,EAAQ3L,qBAAA;IACR4L,EAAA,EAAIrC,mBAAA,CAAAsC,OAAA,CAAQC;EACb;EACA3K,OAAA,EAASwI,UAAA,CAAAoC,UAAA;EACTC,QAAA,EAAU;EACVC,WAAA,EAAa;EACbvK,oBAAoBoB,OAAA,EAAS;IAC5B,MAAMoJ,KAAA,GAAQhB,sBAAA,CAAuB;IACrC,OAAOgB,KAAA,CAAMvJ,GAAA,CAAIG,OAAO,KAAK;EAC9B;EACAnB,kBAAkBmB,OAAA,EAAiBsI,IAAA,EAA0B;IAC5D,MAAMc,KAAA,GAAQhB,sBAAA,CAAuB;IACrC,IAAIE,IAAA,EAAM;MACTc,KAAA,CAAMrJ,GAAA,CAAIC,OAAA,EAASsI,IAAI;IACxB,OAAO;MACNc,KAAA,CAAM5E,MAAA,CAAOxE,OAAO;IACrB;EACD;EACAqJ,gBAAA,EAAkB;EAClBC,YAAA,EAAc;EACdC,YAAA,EAAc;AACf;AAEO,IAAMlM,uBAAA,GAA0B,mBAAImM,GAAA,CAAI,CAC9C3C,UAAA,CAAA4C,cAAA,CAAeC,SAAA,EACf7C,UAAA,CAAA4C,cAAA,CAAeE,QAAA,EACf9C,UAAA,CAAA4C,cAAA,CAAeG,MAAA,CACf;AAEM,SAASzL,6BAAA,EAAmD;EAClE,OAAO;IACN0L,SAAA,EAAW;IACXC,OAAA,EAASjC,IAAA,CAAKC,GAAA,CAAI,IAAI;EACvB;AACD;AALgBxI,MAAA,CAAAnB,4BAAA;;;AD1ChB,IAAM4L,WAAA,OAAc3D,YAAA,CAAAiC,IAAA,EAAK,YAAY,OAAO,WAAW,EAAEzF,IAAA,CAAMoH,GAAA,IAAQA,GAAA,CAAIjB,OAAO,EAAEkB,KAAA,CAAM,MAAM,IAAI,CAAC;AAE9F,IAAKrM,oBAAA,GAAL,gBAAKsM,qBAAA,IAAL;EACNA,qBAAA,aAAS;EACTA,qBAAA,YAAQ;EACRA,qBAAA,eAAW;EACXA,qBAAA,YAAQ;EACRA,qBAAA,wBAAoB;EACpBA,qBAAA,YAAQ;EACRA,qBAAA,YAAQ;EACRA,qBAAA,cAAU;EARC,OAAAA,qBAAA;AAAA,GAAAtM,oBAAA;AAWL,IAAKC,oBAAA,GAAL,gBAAKsM,qBAAA,IAAL;EACNA,qBAAA,CAAAA,qBAAA;EACAA,qBAAA,CAAAA,qBAAA;EACAA,qBAAA,CAAAA,qBAAA;EACAA,qBAAA,CAAAA,qBAAA;EAJW,OAAAA,qBAAA;AAAA,GAAAtM,oBAAA;AAOL,IAAKF,6BAAA,GAAL,gBAAKyM,8BAAA,IAAL;EACNA,8BAAA,CAAAA,8BAAA;EACAA,8BAAA,CAAAA,8BAAA;EAFW,OAAAA,8BAAA;AAAA,GAAAzM,6BAAA;AAuBL,IAAKX,UAAA,GAAL,gBAAKqN,WAAA,IAAL;EACNA,WAAA,CAAAA,WAAA,aAAS,OAAT;EACAA,WAAA,CAAAA,WAAA,eAAW,QAAX;EAFW,OAAAA,WAAA;AAAA,GAAArN,UAAA;AAcZ,IAAMsN,oBAAA,GAAyC9D,SAAA,CAAA+D,SAAA;AAExC,IAAM7M,cAAA,GAAN,cAA6B4I,0BAAA,CAAAkE,iBAAA,CAA2C;EAxF/E;IAwF+ElL,MAAA;EAAA;EACtEmL,UAAA,GAA+B;EAE/BC,mBAAA,GAAsB;EAEtBC,OAAA,GAA0B;EAEjBC,WAAA,GAAc,IAAI3E,gBAAA,CAAA4E,WAAA,CAAY;EAEvCC,cAAA,GAAiB;EAEjBC,KAAA,GAAQ;EAERC,kBAAA,GAAyC7M,4BAAA,CAA6B;EAEtE8M,iCAAA,GAA4D;EAE5DC,iBAAA,GAAyC;EAEzCC,eAAA,GAAkB;EAAA;EAGlBC,sBAAA,GAAyB;EAAA;EAGzBC,gCAAA,GAAmC;EAE1BC,SAAA,GAAY,IAAIjF,mBAAA,CAAAkB,UAAA,CAAW;EAE3BgE,uBAAA,GAA0B,IAAIpF,kBAAA,CAAApF,UAAA,CAAkD;EAEhFyK,QAAA;EAEDC,EAAA;EAEhB,CAAAnI,MAAA,GAAgC;EAEhC,IAAWA,OAAA,EAA+B;IACzC,OAAO,KAAK,CAAAA,MAAA;EACb;EAEO9D,YAAYgM,QAAA,EAAoCC,EAAA,EAAY;IAClE,MAAM;IACN,KAAKD,QAAA,GAAWA,QAAA;IAChB,KAAKC,EAAA,GAAKA,EAAA;EACX;EAEA,MAAatJ,QAAA,EAAU;IACtB,MAAM0C,UAAA,GAAa,IAAIC,eAAA,CAAgB;IACvC,IAAItC,OAAA;IAEJ,IAAI,CAAC,KAAK4I,sBAAA,EAAwB;MAEjC5I,OAAA,GAAUP,OAAA,CAAQyJ,IAAA,CAAK,KACtB7F,mBAAA,CAAAnC,IAAA,EAAK,MAAM,qBAA4B;QAAEvD,MAAA,EAAQ0E,UAAA,CAAW1E;MAAO,CAAC,OACpE0F,mBAAA,CAAAnC,IAAA,EAAK,MAAM,yBAA8B;QAAEvD,MAAA,EAAQ0E,UAAA,CAAW1E;MAAO,CAAC,EACtE;IACF;IAEA,KAAK,KAAKwL,eAAA,CAAgB;IAE1B,IAAI;MACH,MAAMnJ,OAAA;IACP,SAAS;MAAEoJ;IAAM,GAAQ;MACxB,MAAMA,KAAA;IACP,UAAE;MAED/G,UAAA,CAAWG,KAAA,CAAM;IAClB;IAEA,KAAKoG,sBAAA,GAAyB;EAC/B;EAEA,MAAcO,gBAAA,EAAkB;IAC/B,IAAI,KAAK,CAAArI,MAAA,KAAY,cAA2B;MAC/C,MAAM,IAAIL,KAAA,CAAM,2CAA2C;IAC5D;IAEA,MAAM;MAAE5E,OAAA,EAAAwN,QAAA;MAAS3C,QAAA;MAAUC;IAAY,IAAI,KAAKqC,QAAA,CAAStM,OAAA;IACzD,MAAM4M,MAAA,GAAS,IAAI9F,eAAA,CAAA+F,eAAA,CAAgB;MAAEC,CAAA,EAAGH,QAAA;MAAS3C;IAAS,CAAC;IAC3D,IAAIC,WAAA,EAAa;MAChB,MAAM8C,IAAA,GAAO,MAAMlC,WAAA,CAAY;MAC/B,IAAIkC,IAAA,EAAM;QACTH,MAAA,CAAOI,MAAA,CAAO,YAAY/C,WAAW;QACrC,KAAKwB,OAAA,GAAU,IAAIsB,IAAA,CAAKE,OAAA,CAAQ;UAC/BC,SAAA,EAAW;UACXC,EAAA,EAAI;QACL,CAAC;MACF,WAAW,CAAC,KAAK3B,mBAAA,EAAqB;QACrC,KAAKA,mBAAA,GAAsB;QAC3B4B,OAAA,CAAQC,IAAA,CACP,0GACD;MACD;IACD;IAEA,MAAM5H,OAAA,GAAU,MAAM,KAAK6G,QAAA,CAAS5M,mBAAA,CAAoB,KAAK6M,EAAE;IAE/D,MAAMe,GAAA,GAAM,GAAG7H,OAAA,EAAS8H,SAAA,IAAa,KAAKjB,QAAA,CAAStM,OAAA,CAAQC,kBAAA,CAAmBqN,GAAG,IAAIV,MAAA,CAAOY,QAAA,CAAS,CAAC;IAEtG,KAAKC,KAAA,CAAM,CAAC,iBAAiBH,GAAG,EAAE,CAAC;IAEnC,MAAM/B,UAAA,GAAa,IAAIH,oBAAA,CAAqBkC,GAAA,EAAK;MAChDnD,gBAAA,EAAkB,KAAKmC,QAAA,CAAStM,OAAA,CAAQmK,gBAAA,IAAoB;IAC7D,CAAC;IAEDoB,UAAA,CAAWmC,UAAA,GAAa;IAExBnC,UAAA,CAAWoC,SAAA,GAAanI,KAAA,IAAU;MACjC,KAAK,KAAKZ,SAAA,CAAUY,KAAA,CAAM1B,IAAA,EAAM0B,KAAA,CAAM1B,IAAA,YAAgB8J,WAAW;IAClE;IAEArC,UAAA,CAAWsC,OAAA,GAAWrI,KAAA,IAAU;MAC/B,KAAKsI,OAAA,CAAQtI,KAAA,CAAMkH,KAAK;IACzB;IAEAnB,UAAA,CAAWwC,OAAA,GAAWvI,KAAA,IAAU;MAC/B,KAAK,KAAKwI,OAAA,CAAQxI,KAAA,CAAMyI,IAAI;IAC7B;IAEA,KAAK1C,UAAA,GAAaA,UAAA;IAElB,KAAK,CAAAnH,MAAA,GAAU;IAEf,KAAK0H,kBAAA,GAAqB7M,4BAAA,CAA6B;IAEvD,MAAM;MAAE4G;IAAG,IAAI,MAAM,KAAKqI,YAAA,CAAa,qBAA4B,KAAK5B,QAAA,CAAStM,OAAA,CAAQoK,YAAY;IACrG,IAAI,CAACvE,EAAA,EAAI;MACR;IACD;IAEA,IAAIJ,OAAA,EAAS7F,UAAA,KAAe,KAAK0M,QAAA,CAAStM,OAAA,CAAQJ,UAAA,EAAY;MAC7D,MAAM,KAAKuO,MAAA,CAAO1I,OAAO;IAC1B,OAAO;MACN,MAAM,KAAK2I,QAAA,CAAS;IACrB;EACD;EAEA,MAAa3K,QAAQzD,OAAA,GAAwC,CAAC,GAAG;IAChE,IAAI,KAAK,CAAAoE,MAAA,KAAY,cAA2B;MAC/C,KAAKqJ,KAAA,CAAM,CAAC,wCAAwC,CAAC;MACrD;IACD;IAEA,IAAI,CAACzN,OAAA,CAAQiO,IAAA,EAAM;MAClBjO,OAAA,CAAQiO,IAAA,GAAOjO,OAAA,CAAQqO,OAAA,KAAY,iBAAuC,sBAAsB;IACjG;IAEA,KAAKZ,KAAA,CAAM,CACV,oBACA,WAAWzN,OAAA,CAAQoG,MAAA,IAAU,MAAM,IACnC,SAASpG,OAAA,CAAQiO,IAAI,IACrB,YAAYjO,OAAA,CAAQqO,OAAA,KAAY,SAAY,SAAS5P,6BAAA,CAA8BuB,OAAA,CAAQqO,OAAO,CAAE,GACpG;IAGD,KAAKxC,KAAA,GAAQ;IACb,IAAI,KAAKG,iBAAA,EAAmB;MAC3B,IAAApF,kBAAA,CAAA0H,aAAA,EAAc,KAAKtC,iBAAiB;IACrC;IAEA,IAAI,KAAKD,iCAAA,EAAmC;MAC3C,KAAKA,iCAAA,CAAkCjG,KAAA,CAAM;MAC7C,KAAKiG,iCAAA,GAAoC;IAC1C;IAEA,KAAKE,eAAA,GAAkB;IAEvB,WAAWtG,UAAA,IAAc,KAAK0G,uBAAA,CAAwBkC,MAAA,CAAO,GAAG;MAC/D5I,UAAA,CAAWG,KAAA,CAAM;IAClB;IAEA,KAAKuG,uBAAA,CAAwBzI,KAAA,CAAM;IAEnC,KAAKuI,gCAAA,GAAmC;IAGxC,IAAInM,OAAA,CAAQqO,OAAA,KAAY,gBAAsC;MAC7D,MAAM,KAAK/B,QAAA,CAAS3M,iBAAA,CAAkB,KAAK4M,EAAA,EAAI,IAAI;IACpD;IAEA,IAAI,KAAKhB,UAAA,EAAY;MAEpB,KAAKA,UAAA,CAAWoC,SAAA,GAAY;MAE5B,KAAKpC,UAAA,CAAWwC,OAAA,GAAU;MAE1B,MAAMS,WAAA,GAAc,KAAKjD,UAAA,CAAWkD,UAAA,KAAenH,SAAA,CAAA+D,SAAA,CAAUqD,IAAA;MAE7D,KAAKjB,KAAA,CAAM,CACV,oCACA,kBAAkBe,WAAW,IAC7B,gBAAgB,KAAKjD,UAAA,CAAWkD,UAAU,GAC1C;MAED,IAAID,WAAA,EAAa;QAChB,IAAIG,YAAA;QACJ,MAAMrL,OAAA,GAAU,IAAIP,OAAA,CAAeQ,QAAA,IAAY;UAC9CoL,YAAA,GAAepL,QAAA;QAChB,CAAC;QAED,KAAKgI,UAAA,CAAWwC,OAAA,GAAUY,YAAA;QAE1B,KAAKpD,UAAA,CAAWqD,KAAA,CAAM5O,OAAA,CAAQiO,IAAA,EAAMjO,OAAA,CAAQoG,MAAM;QAElD,MAAM9C,OAAA;QACN,KAAKiC,IAAA,CAAK,uBAA6B;UAAE0I,IAAA,EAAMjO,OAAA,CAAQiO;QAAK,CAAC;MAC9D;MAIA,KAAK1C,UAAA,CAAWsC,OAAA,GAAU;IAC3B,OAAO;MACN,KAAKJ,KAAA,CAAM,CAAC,2EAA2E,CAAC;IACzF;IAEA,KAAK,CAAArJ,MAAA,GAAU;IAEf,IAAIpE,OAAA,CAAQqO,OAAA,KAAY,QAAW;MAGlC,UAAMxH,gBAAA,CAAAiC,UAAA,EAAM,GAAG;MACf,OAAO,KAAK2D,eAAA,CAAgB;IAC7B;EACD;EAEA,MAAcyB,aAAa1I,KAAA,EAA6BqJ,eAAA,EAA2D;IAClH,KAAKpB,KAAA,CAAM,CAAC,qBAAqBjI,KAAK,IAAIqJ,eAAA,GAAkB,OAAOA,eAAe,OAAO,cAAc,EAAE,CAAC;IAC1G,MAAMC,iBAAA,GAAoB,IAAIlJ,eAAA,CAAgB;IAC9C,MAAMmJ,OAAA,GAAUF,eAAA,OAAkBjI,kBAAA,CAAAkC,UAAA,EAAW,MAAMgG,iBAAA,CAAkBhJ,KAAA,CAAM,GAAG+I,eAAe,EAAEG,KAAA,CAAM,IAAI;IAEzG,KAAK3C,uBAAA,CAAwBxL,GAAA,CAAI2E,KAAA,EAAOsJ,iBAAiB;IAEzD,MAAMG,eAAA,GAAkB,IAAIrJ,eAAA,CAAgB;IAE5C,IAAI;MAKH,MAAMsJ,MAAA,GAAS,MAAMnM,OAAA,CAAQyJ,IAAA,CAAc,KAC1C7F,mBAAA,CAAAnC,IAAA,EAAK,MAAMgB,KAAA,EAAO;QAAEvE,MAAA,EAAQ6N,iBAAA,CAAkB7N;MAAO,CAAC,EAAEyC,IAAA,CAAK,MAAM,KAAK,OACxEiD,mBAAA,CAAAnC,IAAA,EAAK,MAAM,uBAA6B;QAAEvD,MAAA,EAAQgO,eAAA,CAAgBhO;MAAO,CAAC,EAAEyC,IAAA,CAAK,MAAM,IAAI,EAC3F;MAED,OAAO;QAAEmC,EAAA,EAAI,CAACqJ;MAAO;IACtB,QAAQ;MAEP,KAAK,KAAKzL,OAAA,CAAQ;QACjBwK,IAAA,EAAM;QACN7H,MAAA,EAAQ;QACRiI,OAAA,EAAS;MACV,CAAC;MAED,OAAO;QAAExI,EAAA,EAAI;MAAM;IACpB,UAAE;MACD,IAAIkJ,OAAA,EAAS;QACZ,IAAAnI,kBAAA,CAAAuI,YAAA,EAAaJ,OAAO;MACrB;MAEA,KAAK1C,uBAAA,CAAwB/G,MAAA,CAAOE,KAAK;MAGzC,IAAI,CAACyJ,eAAA,CAAgBhO,MAAA,CAAOmO,OAAA,EAAS;QACpCH,eAAA,CAAgBnJ,KAAA,CAAM;MACvB;IACD;EACD;EAEA,MAAajC,KAAKT,OAAA,EAA4C;IAC7D,IAAI,CAAC,KAAKmI,UAAA,EAAY;MACrB,MAAM,IAAIxH,KAAA,CAAM,iCAAiC;IAClD;IAEA,IAAI,KAAK,CAAAK,MAAA,KAAY,iBAA8B,CAACjG,uBAAA,CAAwBkR,GAAA,CAAIjM,OAAA,CAAQC,EAAE,GAAG;MAC5F,KAAKoK,KAAA,CAAM,CAAC,yEAAyE,CAAC;MAEtF,IAAI;QACH,UAAM9G,mBAAA,CAAAnC,IAAA,EAAK,MAAM,mBAA0B;MAC5C,QAAQ;QACP,OAAO,KAAKX,IAAA,CAAKT,OAAO;MACzB;IACD;IAEA,MAAM,KAAKgJ,SAAA,CAAU3D,IAAA,CAAK;IAE1B,IAAI,EAAE,KAAKqD,kBAAA,CAAmBnB,SAAA,IAAa,GAAG;MAC7C,MAAM/B,GAAA,GAAMD,IAAA,CAAKC,GAAA,CAAI;MAErB,IAAI,KAAKkD,kBAAA,CAAmBlB,OAAA,GAAUhC,GAAA,EAAK;QAC1C,MAAM0G,QAAA,GAAW,KAAKxD,kBAAA,CAAmBlB,OAAA,GAAUhC,GAAA;QAEnD,KAAK6E,KAAA,CAAM,CAAC,sDAAsD6B,QAAQ,IAAI,CAAC;QAC/E,MAAM3J,UAAA,GAAa,IAAIC,eAAA,CAAgB;QAGvC,MAAM2J,WAAA,GAAc,MAAMxM,OAAA,CAAQyJ,IAAA,CAAK,KACtC3F,gBAAA,CAAAiC,UAAA,EAAMwG,QAAQ,EAAE5L,IAAA,CAAK,MAAM,KAAK,OAChCiD,mBAAA,CAAAnC,IAAA,EAAK,MAAM,uBAA6B;UAAEvD,MAAA,EAAQ0E,UAAA,CAAW1E;QAAO,CAAC,EAAEyC,IAAA,CAAK,MAAM,IAAI,EACtF;QAED,IAAI6L,WAAA,EAAa;UAChB,KAAK9B,KAAA,CAAM,CAAC,uFAAuF,CAAC;UACpG,KAAKrB,SAAA,CAAUrD,KAAA,CAAM;UACrB,OAAO,KAAKlF,IAAA,CAAKT,OAAO;QACzB;QAGAuC,UAAA,CAAWG,KAAA,CAAM;MAClB;MAEA,KAAKgG,kBAAA,GAAqB7M,4BAAA,CAA6B;IACxD;IAEA,KAAKmN,SAAA,CAAUrD,KAAA,CAAM;IACrB,KAAKwC,UAAA,CAAW1H,IAAA,CAAK2L,IAAA,CAAKC,SAAA,CAAUrM,OAAO,CAAC;EAC7C;EAEA,MAAcgL,SAAA,EAAW;IACxB,KAAKX,KAAA,CAAM,CAAC,+BAA+B,CAAC;IAE5C,MAAM9H,UAAA,GAAa,IAAIC,eAAA,CAAgB;IACvC,MAAM8J,YAAA,GAAe,eAAAtP,MAAA,OAAM;MAC1BuF,UAAA,CAAWG,KAAA,CAAM;IAClB,GAFqB;IAIrB,KAAKpB,EAAA,CAAG,uBAA6BgL,YAAY;IAEjD,IAAI;MACH,MAAM,KAAKpD,QAAA,CAAStL,eAAA,CAAgB,KAAKuL,EAAA,EAAI5G,UAAA,CAAW1E,MAAM;IAC/D,QAAQ;MACP,IAAI0E,UAAA,CAAW1E,MAAA,CAAOmO,OAAA,EAAS;QAC9B,KAAK3B,KAAA,CAAM,CAAC,mEAAmE,CAAC;QAChF;MACD;MAEA,KAAKA,KAAA,CAAM,CACV,oEACA,+EACA,iDACA;MAED,MAAM,KAAKhK,OAAA,CAAQ;QAClB2C,MAAA,EAAQ;QACRiI,OAAA,EAAS;MACV,CAAC;IACF,UAAE;MACD,KAAKhJ,GAAA,CAAI,uBAA6BqK,YAAY;IACnD;IAEA,KAAKjC,KAAA,CAAM,CACV,eACA,aAAa,KAAKlB,EAAA,CAAGiB,QAAA,CAAS,CAAC,IAC/B,gBAAgB,KAAKlB,QAAA,CAAStM,OAAA,CAAQJ,UAAU,IAChD,YAAY,KAAK0M,QAAA,CAAStM,OAAA,CAAQ2P,OAAO,IACzC,gBAAgB,KAAKlE,OAAA,GAAU,gBAAgB,KAAKD,mBAAA,GAAsB,aAAa,MAAM,GAC7F;IAED,MAAMoE,CAAA,GAAyB;MAC9BC,KAAA,EAAO,KAAKvD,QAAA,CAAStM,OAAA,CAAQ6P,KAAA;MAC7BC,UAAA,EAAY,KAAKxD,QAAA,CAAStM,OAAA,CAAQyJ,kBAAA;MAClCkG,OAAA,EAAS,KAAKrD,QAAA,CAAStM,OAAA,CAAQ2P,OAAA;MAC/BI,QAAA,EAAU,KAAKvE,mBAAA;MACfwE,KAAA,EAAO,CAAC,KAAKzD,EAAA,EAAI,KAAKD,QAAA,CAAStM,OAAA,CAAQJ,UAAU;IAClD;IAEA,IAAI,KAAK0M,QAAA,CAAStM,OAAA,CAAQuJ,cAAA,EAAgB;MACzCqG,CAAA,CAAEK,eAAA,GAAkB,KAAK3D,QAAA,CAAStM,OAAA,CAAQuJ,cAAA;IAC3C;IAEA,IAAI,KAAK+C,QAAA,CAAStM,OAAA,CAAQwJ,eAAA,EAAiB;MAC1CoG,CAAA,CAAEM,QAAA,GAAW,KAAK5D,QAAA,CAAStM,OAAA,CAAQwJ,eAAA;IACpC;IAEA,MAAM,KAAK3F,IAAA,CAAK;MACfR,EAAA,EAAIgE,WAAA,CAAAkD,cAAA,CAAeE,QAAA;MACnBmF;IACD,CAAC;IAED,MAAM,KAAK1B,YAAA,CAAa,qBAA4B,KAAK5B,QAAA,CAAStM,OAAA,CAAQqK,YAAY;EACvF;EAEA,MAAc8D,OAAO1I,OAAA,EAAsB;IAC1C,KAAKgI,KAAA,CAAM,CACV,oBACA,eAAehI,OAAA,CAAQ8H,SAAS,IAChC,aAAa9H,OAAA,CAAQ0K,QAAQ,IAC7B,aAAa,KAAK5D,EAAA,CAAGiB,QAAA,CAAS,CAAC,GAC/B;IAED,KAAK,CAAApJ,MAAA,GAAU;IACf,KAAKwH,cAAA,GAAiB;IACtB,OAAO,KAAK/H,IAAA,CAAK;MAChBR,EAAA,EAAIgE,WAAA,CAAAkD,cAAA,CAAeG,MAAA;MACnBkF,CAAA,EAAG;QACFC,KAAA,EAAO,KAAKvD,QAAA,CAAStM,OAAA,CAAQ6P,KAAA;QAC7BO,GAAA,EAAK3K,OAAA,CAAQ0K,QAAA;QACbE,UAAA,EAAY5K,OAAA,CAAQ6K;MACrB;IACD,CAAC;EACF;EAEA,MAAcC,UAAUC,SAAA,GAAY,OAAO;IAC1C,IAAI,CAAC,KAAK3E,KAAA,IAAS,CAAC2E,SAAA,EAAW;MAC9B,OAAO,KAAK/M,OAAA,CAAQ;QAAE2C,MAAA,EAAQ;QAAqBiI,OAAA,EAAS;MAAqC,CAAC;IACnG;IAEA,MAAM5I,OAAA,GAAU,MAAM,KAAK6G,QAAA,CAAS5M,mBAAA,CAAoB,KAAK6M,EAAE;IAE/D,MAAM,KAAK1I,IAAA,CAAK;MACfR,EAAA,EAAIgE,WAAA,CAAAkD,cAAA,CAAeC,SAAA;MACnBoF,CAAA,EAAGnK,OAAA,EAAS0K,QAAA,IAAY;IACzB,CAAC;IAED,KAAKlE,eAAA,GAAkBtD,IAAA,CAAKC,GAAA,CAAI;IAChC,KAAKiD,KAAA,GAAQ;EACd;EAEA,MAAc4E,cAAc3M,IAAA,EAAY4M,QAAA,EAA0D;IAEjG,IAAI,CAACA,QAAA,EAAU;MACd,IAAI;QACH,OAAOlB,IAAA,CAAKmB,KAAA,CAAM7M,IAAc;MACjC,QAAQ;QAEP,OAAO;MACR;IACD;IAEA,MAAM8M,cAAA,GAAiB,IAAIC,UAAA,CAAW/M,IAAmB;IAGzD,IAAI,KAAK0H,mBAAA,EAAqB;MAC7B,OAAO,IAAIzI,OAAA,CAAQ,CAACQ,QAAA,EAAS4C,MAAA,KAAW;QAEvC,IAAAa,gBAAA,CAAAyE,OAAA,EAAQmF,cAAA,EAAgB;UAAE1D,SAAA,EAAW;QAAO,GAAG,CAACvI,GAAA,EAAKmM,MAAA,KAAW;UAC/D,IAAInM,GAAA,EAAK;YACRwB,MAAA,CAAOxB,GAAG;YACV;UACD;UAEApB,QAAA,CAAQiM,IAAA,CAAKmB,KAAA,CAAM,KAAKjF,WAAA,CAAYqF,MAAA,CAAOD,MAAM,CAAC,CAA0B;QAC7E,CAAC;MACF,CAAC;IACF;IAGA,IAAI,KAAKrF,OAAA,EAAS;MACjB,MAAMuF,CAAA,GAAIJ,cAAA,CAAexO,MAAA;MACzB,MAAM6O,KAAA,GACLD,CAAA,IAAK,KACLJ,cAAA,CAAeI,CAAA,GAAI,CAAC,MAAM,KAC1BJ,cAAA,CAAeI,CAAA,GAAI,CAAC,MAAM,KAC1BJ,cAAA,CAAeI,CAAA,GAAI,CAAC,MAAM,OAC1BJ,cAAA,CAAeI,CAAA,GAAI,CAAC,MAAM;MAE3B,MAAMjE,IAAA,GAAQ,MAAMlC,WAAA,CAAY;MAChC,KAAKY,OAAA,CAAQ5I,IAAA,CAAK6D,kBAAA,CAAAwK,MAAA,CAAOC,IAAA,CAAKP,cAAc,GAAGK,KAAA,GAAQlE,IAAA,CAAKqE,YAAA,GAAerE,IAAA,CAAKsE,UAAU;MAE1F,IAAI,KAAK5F,OAAA,CAAQ9G,GAAA,EAAK;QACrB,KAAKY,IAAA,CAAK,qBAA4B;UACrCmH,KAAA,EAAO,IAAI3I,KAAA,CAAM,GAAG,KAAK0H,OAAA,CAAQ9G,GAAG,GAAG,KAAK8G,OAAA,CAAQ6F,GAAA,GAAM,KAAK,KAAK7F,OAAA,CAAQ6F,GAAG,KAAK,EAAE,EAAE;QACzF,CAAC;MACF;MAEA,IAAI,CAACL,KAAA,EAAO;QACX,OAAO;MACR;MAEA,MAAM;QAAEH;MAAO,IAAI,KAAKrF,OAAA;MACxB,IAAI,CAACqF,MAAA,EAAQ;QACZ,OAAO;MACR;MAEA,OAAOtB,IAAA,CAAKmB,KAAA,CAAM,OAAOG,MAAA,KAAW,WAAWA,MAAA,GAAS,KAAKpF,WAAA,CAAYqF,MAAA,CAAOD,MAAM,CAAC;IACxF;IAEA,KAAKrD,KAAA,CAAM,CACV,mDACA,aAAaiD,QAAA,CAASlD,QAAA,CAAS,CAAC,IAChC,wBAAwB,KAAKhC,mBAAA,CAAoBgC,QAAA,CAAS,CAAC,IAC3D,YAAY+D,OAAA,CAAQ,KAAK9F,OAAO,EAAE+B,QAAA,CAAS,CAAC,GAC5C;IAED,OAAO;EACR;EAEA,MAAc5I,UAAUd,IAAA,EAAY4M,QAAA,EAAmB;IACtD,MAAMtN,OAAA,GAAU,MAAM,KAAKqN,aAAA,CAAc3M,IAAA,EAAM4M,QAAQ;IACvD,IAAI,CAACtN,OAAA,EAAS;MACb;IACD;IAEA,QAAQA,OAAA,CAAQC,EAAA;MACf,KAAKgE,WAAA,CAAAkD,cAAA,CAAeiH,QAAA;QAAU;UAC7B,IAAI,KAAK,CAAApN,MAAA,KAAY,kBAA+B;YACnD,KAAKwH,cAAA;UACN;UAGA,QAAQxI,OAAA,CAAQqO,CAAA;YACf,KAAKpK,WAAA,CAAAqK,qBAAA,CAAsBC,KAAA;cAAO;gBACjC,KAAK,CAAAvN,MAAA,GAAU;gBAEf,MAAMwN,QAAA,GAAU;kBACfzB,QAAA,EAAU/M,OAAA,CAAQyO,CAAA;kBAClBvB,SAAA,EAAWlN,OAAA,CAAQwM,CAAA,CAAES,UAAA;kBACrBvP,OAAA,EAAS,KAAKyL,EAAA;kBACd3M,UAAA,EAAY,KAAK0M,QAAA,CAAStM,OAAA,CAAQJ,UAAA;kBAClC2N,SAAA,EAAWnK,OAAA,CAAQwM,CAAA,CAAEkC;gBACtB;gBAEA,MAAM,KAAKxF,QAAA,CAAS3M,iBAAA,CAAkB,KAAK4M,EAAA,EAAIqF,QAAO;gBAEtD,KAAKrM,IAAA,CAAK,qBAA4B;kBAAEzB,IAAA,EAAMV,OAAA,CAAQwM;gBAAE,CAAC;gBACzD;cACD;YAEA,KAAKvI,WAAA,CAAAqK,qBAAA,CAAsBK,OAAA;cAAS;gBACnC,KAAK,CAAA3N,MAAA,GAAU;gBACf,KAAKqJ,KAAA,CAAM,CAAC,wBAAwB,KAAK7B,cAAc,SAAS,CAAC;gBACjE,KAAKrG,IAAA,CAAK,uBAA4B;gBACtC;cACD;YAEA;cAAS;gBACR;cACD;UACD;UAEA,MAAME,OAAA,GAAU,MAAM,KAAK6G,QAAA,CAAS5M,mBAAA,CAAoB,KAAK6M,EAAE;UAC/D,IAAI9G,OAAA,EAAS;YACZ,IAAIrC,OAAA,CAAQyO,CAAA,GAAIpM,OAAA,CAAQ0K,QAAA,EAAU;cACjC,MAAM,KAAK7D,QAAA,CAAS3M,iBAAA,CAAkB,KAAK4M,EAAA,EAAI;gBAAE,GAAG9G,OAAA;gBAAS0K,QAAA,EAAU/M,OAAA,CAAQyO;cAAE,CAAC;YACnF;UACD,OAAO;YACN,KAAKpE,KAAA,CAAM,CACV,cAAcrK,OAAA,CAAQqO,CAAC,0HACvB;UACF;UAEA,KAAKlM,IAAA,CAAK,2BAA+B;YAAEzB,IAAA,EAAMV;UAAQ,CAAC;UAE1D;QACD;MAEA,KAAKiE,WAAA,CAAAkD,cAAA,CAAeC,SAAA;QAAW;UAC9B,MAAM,KAAK+F,SAAA,CAAU,IAAI;UACzB;QACD;MAEA,KAAKlJ,WAAA,CAAAkD,cAAA,CAAeyH,SAAA;QAAW;UAC9B,MAAM,KAAKvO,OAAA,CAAQ;YAClB2C,MAAA,EAAQ;YACRiI,OAAA,EAAS;UACV,CAAC;UACD;QACD;MAEA,KAAKhH,WAAA,CAAAkD,cAAA,CAAe0H,cAAA;QAAgB;UACnC,KAAKxE,KAAA,CAAM,CAAC,4CAA4CrK,OAAA,CAAQwM,CAAA,CAAEpC,QAAA,CAAS,CAAC,EAAE,CAAC;UAC/E,MAAM/H,OAAA,GAAU,MAAM,KAAK6G,QAAA,CAAS5M,mBAAA,CAAoB,KAAK6M,EAAE;UAC/D,IAAInJ,OAAA,CAAQwM,CAAA,IAAKnK,OAAA,EAAS;YACzB,MAAM,KAAK0I,MAAA,CAAO1I,OAAO;UAC1B,OAAO;YACN,MAAM,KAAKhC,OAAA,CAAQ;cAClB2C,MAAA,EAAQ;cACRiI,OAAA,EAAS;YACV,CAAC;UACF;UAEA;QACD;MAEA,KAAKhH,WAAA,CAAAkD,cAAA,CAAe2H,KAAA;QAAO;UAC1B,KAAK3M,IAAA,CAAK,mBAA0B;UACpC,MAAM4M,MAAA,GAAS5P,IAAA,CAAK4B,MAAA,CAAO;UAC3B,MAAMiO,SAAA,GAAY7P,IAAA,CAAK8P,KAAA,CAAMjP,OAAA,CAAQwM,CAAA,CAAE0C,kBAAA,GAAqBH,MAAM;UAClE,KAAK1E,KAAA,CAAM,CAAC,gEAAgE0E,MAAM,aAAaC,SAAS,IAAI,CAAC;UAE7G,IAAI;YACH,MAAMzM,UAAA,GAAa,IAAIC,eAAA,CAAgB;YACvC,KAAKmG,iCAAA,GAAoCpG,UAAA;YACzC,UAAMkB,gBAAA,CAAAiC,UAAA,EAAMsJ,SAAA,EAAW,QAAW;cAAEnR,MAAA,EAAQ0E,UAAA,CAAW1E;YAAO,CAAC;UAChE,QAAQ;YACP,KAAKwM,KAAA,CAAM,CAAC,0DAA0D,CAAC;YACvE;UACD,UAAE;YACD,KAAK1B,iCAAA,GAAoC;UAC1C;UAEA,MAAM,KAAKwE,SAAA,CAAU;UAErB,KAAK9C,KAAA,CAAM,CAAC,gDAAgDrK,OAAA,CAAQwM,CAAA,CAAE0C,kBAAkB,IAAI,CAAC;UAC7F,KAAKtG,iBAAA,OAAoBpF,kBAAA,CAAA2L,WAAA,EAAY,MAAM,KAAK,KAAKhC,SAAA,CAAU,GAAGnN,OAAA,CAAQwM,CAAA,CAAE0C,kBAAkB;UAC9F;QACD;MAEA,KAAKjL,WAAA,CAAAkD,cAAA,CAAeiI,YAAA;QAAc;UACjC,KAAK3G,KAAA,GAAQ;UAEb,MAAM4G,KAAA,GAAQ9J,IAAA,CAAKC,GAAA,CAAI;UACvB,KAAKrD,IAAA,CAAK,qCAAwC;YACjDkN,KAAA;YACAC,WAAA,EAAa,KAAKzG,eAAA;YAClB0G,OAAA,EAASF,KAAA,GAAQ,KAAKxG;UACvB,CAAC;UAED;QACD;IACD;EACD;EAEQ6B,QAAQpB,KAAA,EAAc;IAC7B,IAAI,UAAUA,KAAA,IAAS,CAAC,cAAc,cAAc,EAAEkG,QAAA,CAASlG,KAAA,CAAMuB,IAAc,GAAG;MACrF,KAAKR,KAAA,CAAM,CAAC,uEAAuE,CAAC;MACpF,KAAKtB,gCAAA,GAAmC;MACxC;IACD;IAEA,KAAK5G,IAAA,CAAK,qBAA4B;MAAEmH;IAAM,CAAC;EAChD;EAEA,MAAcsB,QAAQC,IAAA,EAAc;IACnC,KAAK1I,IAAA,CAAK,uBAA6B;MAAE0I;IAAK,CAAC;IAE/C,QAAQA,IAAA;MACP,KAAK;QAAmB;UACvB,OAAO,KAAKxK,OAAA,CAAQ;YACnBwK,IAAA;YACA7H,MAAA,EAAQ;YACRiI,OAAA,EAAS;UACV,CAAC;QACF;MAEA,KAAK;QAAqB;UACzB;QACD;MAEA,KAAKhH,WAAA,CAAAwL,iBAAA,CAAkBC,YAAA;QAAc;UACpC,KAAKrF,KAAA,CAAM,CAAC,8BAA8BQ,IAAI,EAAE,CAAC;UACjD,OAAO,KAAKxK,OAAA,CAAQ;YAAEwK,IAAA;YAAMI,OAAA,EAAS;UAAqC,CAAC;QAC5E;MAEA,KAAKhH,WAAA,CAAAwL,iBAAA,CAAkBE,aAAA;QAAe;UACrC,KAAKtF,KAAA,CAAM,CAAC,wCAAwC,CAAC;UACrD,OAAO,KAAKhK,OAAA,CAAQ;YAAEwK,IAAA;YAAMI,OAAA,EAAS;UAAqC,CAAC;QAC5E;MAEA,KAAKhH,WAAA,CAAAwL,iBAAA,CAAkBG,WAAA;QAAa;UACnC,KAAKvF,KAAA,CAAM,CAAC,yCAAyC,CAAC;UACtD,OAAO,KAAKhK,OAAA,CAAQ;YAAEwK,IAAA;YAAMI,OAAA,EAAS;UAAqC,CAAC;QAC5E;MAEA,KAAKhH,WAAA,CAAAwL,iBAAA,CAAkBI,gBAAA;QAAkB;UACxC,KAAKxF,KAAA,CAAM,CAAC,gEAAgE,CAAC;UAC7E,OAAO,KAAKhK,OAAA,CAAQ;YAAEwK,IAAA;YAAMI,OAAA,EAAS;UAAwC,CAAC;QAC/E;MAEA,KAAKhH,WAAA,CAAAwL,iBAAA,CAAkBK,oBAAA;QAAsB;UAC5C,KAAK3N,IAAA,CAAK,qBAA4B;YACrCmH,KAAA,EAAO,IAAI3I,KAAA,CAAM,uBAAuB;UACzC,CAAC;UACD,OAAO,KAAKN,OAAA,CAAQ;YAAEwK;UAAK,CAAC;QAC7B;MAEA,KAAK5G,WAAA,CAAAwL,iBAAA,CAAkBM,oBAAA;QAAsB;UAC5C,KAAK1F,KAAA,CAAM,CAAC,sCAAsC,CAAC;UACnD,OAAO,KAAKhK,OAAA,CAAQ;YAAEwK,IAAA;YAAMI,OAAA,EAAS;UAAwC,CAAC;QAC/E;MAEA,KAAKhH,WAAA,CAAAwL,iBAAA,CAAkBO,UAAA;QAAY;UAClC,KAAK3F,KAAA,CAAM,CAAC,+BAA+B,CAAC;UAC5C,OAAO,KAAKhK,OAAA,CAAQ;YAAEwK,IAAA;YAAMI,OAAA,EAAS;UAAwC,CAAC;QAC/E;MAEA,KAAKhH,WAAA,CAAAwL,iBAAA,CAAkBQ,WAAA;QAAa;UACnC,KAAK5F,KAAA,CAAM,CAAC,iEAAiE,CAAC;UAC9E,OAAO,KAAKhK,OAAA,CAAQ;YAAEwK,IAAA;YAAMI,OAAA,EAAS;UAAwC,CAAC;QAC/E;MAEA,KAAKhH,WAAA,CAAAwL,iBAAA,CAAkBS,eAAA;QAAiB;UACvC,KAAK7F,KAAA,CAAM,CAAC,oBAAoB,CAAC;UACjC,OAAO,KAAKhK,OAAA,CAAQ;YAAEwK,IAAA;YAAMI,OAAA,EAAS;UAAqC,CAAC;QAC5E;MAEA,KAAKhH,WAAA,CAAAwL,iBAAA,CAAkBU,YAAA;QAAc;UACpC,KAAKhO,IAAA,CAAK,qBAA4B;YACrCmH,KAAA,EAAO,IAAI3I,KAAA,CAAM,eAAe;UACjC,CAAC;UACD,OAAO,KAAKN,OAAA,CAAQ;YAAEwK;UAAK,CAAC;QAC7B;MAEA,KAAK5G,WAAA,CAAAwL,iBAAA,CAAkBW,gBAAA;QAAkB;UACxC,KAAKjO,IAAA,CAAK,qBAA4B;YACrCmH,KAAA,EAAO,IAAI3I,KAAA,CAAM,sBAAsB;UACxC,CAAC;UACD,OAAO,KAAKN,OAAA,CAAQ;YAAEwK;UAAK,CAAC;QAC7B;MAEA,KAAK5G,WAAA,CAAAwL,iBAAA,CAAkBY,iBAAA;QAAmB;UACzC,KAAKlO,IAAA,CAAK,qBAA4B;YACrCmH,KAAA,EAAO,IAAI3I,KAAA,CAAM,6BAA6B;UAC/C,CAAC;UACD,OAAO,KAAKN,OAAA,CAAQ;YAAEwK;UAAK,CAAC;QAC7B;MAEA,KAAK5G,WAAA,CAAAwL,iBAAA,CAAkBa,cAAA;QAAgB;UACtC,KAAKnO,IAAA,CAAK,qBAA4B;YACrCmH,KAAA,EAAO,IAAI3I,KAAA,CAAM,sBAAsB;UACxC,CAAC;UACD,OAAO,KAAKN,OAAA,CAAQ;YAAEwK;UAAK,CAAC;QAC7B;MAEA,KAAK5G,WAAA,CAAAwL,iBAAA,CAAkBc,iBAAA;QAAmB;UACzC,KAAKpO,IAAA,CAAK,qBAA4B;YACrCmH,KAAA,EAAO,IAAI3I,KAAA,CAAM,yBAAyB;UAC3C,CAAC;UACD,OAAO,KAAKN,OAAA,CAAQ;YAAEwK;UAAK,CAAC;QAC7B;MAEA;QAAS;UACR,KAAKR,KAAA,CAAM,CACV,8CAA8CQ,IAAI,mBACjD,KAAK9B,gCAAA,GAAmC,cAAc,QACvD,IACA;UACD,OAAO,KAAK1I,OAAA,CAAQ;YACnBwK,IAAA;YACAI,OAAA,EAAS,KAAKlC,gCAAA,GACX,oBACA;UACJ,CAAC;QACF;IACD;EACD;EAEQsB,MAAMmG,QAAA,EAAiC;IAC9C,MAAMC,OAAA,GAAU,GAAGD,QAAA,CAAS,CAAC,CAAC,GAC7BA,QAAA,CAASxR,MAAA,GAAS,IACf;AAAA,EAAKwR,QAAA,CACJjR,KAAA,CAAM,CAAC,EACPmR,GAAA,CAAKC,CAAA,IAAM,IAAIA,CAAC,EAAE,EAClBhP,IAAA,CAAK,IAAI,CAAC,KACX,EACJ;IAEA,KAAKQ,IAAA,CAAK,qBAA4B;MAAEsO;IAAQ,CAAC;EAClD;AACD;;;AD1zBO,IAAMvV,sBAAA,GAAN,MAA0D;EAXjE;IAWiE8B,MAAA;EAAA;EAC/Cb,OAAA;EAEAyU,MAAA,GAAS,IAAIvN,kBAAA,CAAA5E,UAAA,CAAmC;EAE1DvB,YAAYf,OAAA,EAA2B;IAC7C,KAAKA,OAAA,GAAUA,OAAA;EAChB;EAAA;AAAA;AAAA;EAKA,MAAa2C,MAAMrC,QAAA,EAAoB;IACtC,MAAMwC,eAAA,GAAkB,MAAMnD,gCAAA,CAAiC,KAAKK,OAAO;IAE3E,WAAWuB,OAAA,IAAWjB,QAAA,EAAU;MAC/B,MAAMyM,QAAA,GAAW,IAAIlO,6BAAA,CAA8B,KAAKmB,OAAA,EAAS8C,eAAe;MAChF,MAAM2N,KAAA,GAAQ,IAAIxR,cAAA,CAAe8N,QAAA,EAAUxL,OAAO;MAClD,WAAW0E,KAAA,IAASyO,MAAA,CAAO1F,MAAA,CAAO7P,oBAAoB,GAAG;QAExDsR,KAAA,CAAMtL,EAAA,CAAGc,KAAA,EAAQpC,OAAA,IAAY,KAAK7D,OAAA,CAAQgG,IAAA,CAAKC,KAAA,EAAO;UAAE,GAAGpC,OAAA;UAAStC;QAAQ,CAAC,CAAC;MAC/E;MAEA,KAAKkT,MAAA,CAAOnT,GAAA,CAAIC,OAAA,EAASkP,KAAK;IAC/B;EACD;EAAA;AAAA;AAAA;EAKA,MAAa/M,QAAA,EAAU;IACtB,MAAMR,QAAA,GAAW,EAAC;IAElB,WAAWuN,KAAA,IAAS,KAAKgE,MAAA,CAAOzF,MAAA,CAAO,GAAG;MACzC9L,QAAA,CAASI,IAAA,CAAKmN,KAAA,CAAM/M,OAAA,CAAQ,CAAC;IAC9B;IAEA,MAAMF,OAAA,CAAQC,GAAA,CAAIP,QAAQ;EAC3B;EAAA;AAAA;AAAA;EAKA,MAAagB,QAAQzD,OAAA,EAAyD;IAC7E,MAAMyC,QAAA,GAAW,EAAC;IAElB,WAAWuN,KAAA,IAAS,KAAKgE,MAAA,CAAOzF,MAAA,CAAO,GAAG;MACzC9L,QAAA,CAASI,IAAA,CAAKmN,KAAA,CAAMvM,OAAA,CAAQzD,OAAO,CAAC;IACrC;IAEA,MAAM+C,OAAA,CAAQC,GAAA,CAAIP,QAAQ;IAC1B,KAAKuR,MAAA,CAAOpQ,KAAA,CAAM;EACnB;EAAA;AAAA;AAAA;EAKA,MAAaC,KAAK/C,OAAA,EAAiBsC,OAAA,EAA6B;IAC/D,MAAM4M,KAAA,GAAQ,KAAKgE,MAAA,CAAOrT,GAAA,CAAIG,OAAO;IACrC,IAAI,CAACkP,KAAA,EAAO;MACX,MAAM,IAAIkE,UAAA,CAAW,SAASpT,OAAO,YAAY;IAClD;IAEA,OAAOkP,KAAA,CAAMnM,IAAA,CAAKT,OAAO;EAC1B;EAAA;AAAA;AAAA;EAKA,MAAaY,YAAA,EAAc;IAC1B,OAAO,KAAKgQ,MAAA,CAAOG,SAAA,CAAWnE,KAAA,IAAUA,KAAA,CAAM5L,MAAM;EACrD;AACD;;;AInFA,IAAAgQ,2BAAA,GAAqDjT,OAAA;AACrD,IAAAkT,kBAAA,GAA2BlT,OAAA;AAgCpB,IAAMvC,kBAAA,GAAN,MAAyB;EAjChC;IAiCgCwB,MAAA;EAAA;EAAA;AAAA;AAAA;EAIZ0D,IAAA,GAAOsQ,2BAAA,CAAA7P,UAAA;EAAA;AAAA;AAAA;EAKPyP,MAAA,GAAS,IAAIK,kBAAA,CAAAxS,UAAA,CAAmC;EAE5DvB,YAAA,EAAc;IACpB,IAAI8T,2BAAA,CAAArO,YAAA,EAAc;MACjB,MAAM,IAAIhC,KAAA,CAAM,gEAAgE;IACjF;EACD;EAAA;AAAA;AAAA;EAKA,MAAgBd,QAAQnC,OAAA,EAAgC;IACvD,MAAMkP,KAAA,GAAQ,KAAKgE,MAAA,CAAOrT,GAAA,CAAIG,OAAO;IACrC,IAAI,CAACkP,KAAA,EAAO;MACX,MAAM,IAAIkE,UAAA,CAAW,SAASpT,OAAO,iBAAiB;IACvD;IAEA,MAAMkP,KAAA,CAAM/M,OAAA,CAAQ;EACrB;EAAA;AAAA;AAAA;EAKA,MAAgBQ,QAAQ3C,OAAA,EAAiBd,OAAA,EAAuD;IAC/F,MAAMgQ,KAAA,GAAQ,KAAKgE,MAAA,CAAOrT,GAAA,CAAIG,OAAO;IACrC,IAAI,CAACkP,KAAA,EAAO;MACX,MAAM,IAAIkE,UAAA,CAAW,SAASpT,OAAO,iBAAiB;IACvD;IAEA,MAAMkP,KAAA,CAAMvM,OAAA,CAAQzD,OAAO;EAC5B;EAAA;AAAA;AAAA;EAKUsU,kBAAA,EAA0B;IACnCF,2BAAA,CAAApO,UAAA,CACEtB,EAAA,CAAG,gBAAiBC,GAAA,IAAQ;MAC5B,MAAMA,GAAA;IACP,CAAC,EACAD,EAAA,CAAG,WAAW,MAAOtB,OAAA,IAA+B;MACpD,QAAQA,OAAA,CAAQC,EAAA;QACf;UAAkC;YACjC,MAAM,KAAKJ,OAAA,CAAQG,OAAA,CAAQtC,OAAO;YAClC,MAAM4E,QAAA,GAAiC;cACtCrC,EAAA;cACAvC,OAAA,EAASsC,OAAA,CAAQtC;YAClB;YACAsT,2BAAA,CAAApO,UAAA,CAAYxC,WAAA,CAAYkC,QAAQ;YAChC;UACD;QAEA;UAAkC;YACjC,MAAM,KAAKjC,OAAA,CAAQL,OAAA,CAAQtC,OAAA,EAASsC,OAAA,CAAQpD,OAAO;YACnD,MAAM0F,QAAA,GAAiC;cACtCrC,EAAA;cACAvC,OAAA,EAASsC,OAAA,CAAQtC;YAClB;YAEAsT,2BAAA,CAAApO,UAAA,CAAYxC,WAAA,CAAYkC,QAAQ;YAChC;UACD;QAEA;UAA+B;YAC9B,MAAMsK,KAAA,GAAQ,KAAKgE,MAAA,CAAOrT,GAAA,CAAIyC,OAAA,CAAQtC,OAAO;YAC7C,IAAI,CAACkP,KAAA,EAAO;cACX,MAAM,IAAIkE,UAAA,CAAW,SAAS9Q,OAAA,CAAQtC,OAAO,iBAAiB;YAC/D;YAEA,MAAMkP,KAAA,CAAMnM,IAAA,CAAKT,OAAA,CAAQA,OAAO;YAChC;UACD;QAEA;UAA8C;YAC7C;UACD;QAEA;UAAgD;YAC/C;UACD;QAEA;UAAsC;YACrC,MAAM4M,KAAA,GAAQ,KAAKgE,MAAA,CAAOrT,GAAA,CAAIyC,OAAA,CAAQtC,OAAO;YAC7C,IAAI,CAACkP,KAAA,EAAO;cACX,MAAM,IAAIjM,KAAA,CAAM,SAASX,OAAA,CAAQtC,OAAO,iBAAiB;YAC1D;YAEA,MAAM4E,QAAA,GAAiC;cACtCrC,EAAA;cACAe,MAAA,EAAQ4L,KAAA,CAAM5L,MAAA;cACdF,KAAA,EAAOd,OAAA,CAAQc;YAChB;YAEAkQ,2BAAA,CAAApO,UAAA,CAAYxC,WAAA,CAAYkC,QAAQ;YAChC;UACD;MACD;IACD,CAAC;EACH;EAAA;AAAA;AAAA;EAKA,MAAa6O,UAAUvU,OAAA,GAAsC,CAAC,GAAkB;IAE/E,WAAWc,OAAA,IAAW,KAAKgD,IAAA,CAAKjE,QAAA,EAAU;MACzC,MAAMmQ,KAAA,GAAQ,IAAIxR,cAAA,CAAe,IAAIK,6BAAA,CAA8B,KAAKiF,IAAI,GAAGhD,OAAO;MACtF,WAAW0E,KAAA,IAASxF,OAAA,CAAQwU,aAAA,IAAiBP,MAAA,CAAO1F,MAAA,CAAO7P,oBAAoB,GAAG;QAEjFsR,KAAA,CAAMtL,EAAA,CAAGc,KAAA,EAAQ1B,IAAA,IAAS;UACzB,MAAMV,OAAA,GAAgC;YACrCC,EAAA;YACAmC,KAAA;YACA1B,IAAA;YACAhD;UACD;UACAsT,2BAAA,CAAApO,UAAA,CAAYxC,WAAA,CAAYJ,OAAO;QAChC,CAAC;MACF;MAGA,MAAMpD,OAAA,CAAQyU,aAAA,GAAgBzE,KAAK;MACnC,KAAKgE,MAAA,CAAOnT,GAAA,CAAIC,OAAA,EAASkP,KAAK;IAC/B;IAGA,KAAKsE,iBAAA,CAAkB;IAEvB,MAAMT,OAAA,GAAgC;MACrCxQ,EAAA;IACD;IACA+Q,2BAAA,CAAApO,UAAA,CAAYxC,WAAA,CAAYqQ,OAAO;EAChC;AACD;;;AC9KA,IAAAa,YAAA,GAAsCvT,OAAA;AACtC,IAAAwT,2BAAA,GAAkCxT,OAAA;AAClC,IAAAyT,WAAA,GAQOzT,OAAA;AAiLA,IAAM5C,gBAAA,GAAN,cAA+BoW,2BAAA,CAAArJ,iBAAA,CAAyC;EA5L/E;IA4L+ElL,MAAA;EAAA;EAAA;AAAA;AAAA;EAI9DJ,OAAA;EAAA;AAAA;AAAA;EAKRC,kBAAA,GAGG;EAAA;AAAA;AAAA;EAKHJ,QAAA,GAA4B;EAAA;AAAA;AAAA;AAAA;AAAA;EAOnByM,QAAA;EAEVhM,YAAYN,OAAA,EAAqF;IACvG,MAAM;IACN,KAAKA,OAAA,GAAU;MAAE,GAAG/B,8BAAA;MAAgC,GAAG+B;IAAQ;IAC/D,KAAKsM,QAAA,GAAW,KAAKtM,OAAA,CAAQP,aAAA,CAAc,IAAI;EAChD;EAAA;AAAA;AAAA;AAAA;AAAA;EAOA,MAAaS,wBAAwB2U,KAAA,GAAQ,OAAO;IACnD,IAAI,KAAK5U,kBAAA,EAAoB;MAC5B,IAAI,KAAKA,kBAAA,CAAmB6U,SAAA,IAAanM,IAAA,CAAKC,GAAA,CAAI,GAAG;QACpD,KAAK3I,kBAAA,GAAqB;MAC3B,WAAW,CAAC4U,KAAA,EAAO;QAClB,OAAO,KAAK5U,kBAAA,CAAmB6D,IAAA;MAChC;IACD;IAEA,MAAMA,IAAA,GAAQ,MAAM,KAAK9D,OAAA,CAAQF,IAAA,CAAKa,GAAA,CAAIiU,WAAA,CAAAG,MAAA,CAAOC,UAAA,CAAW,CAAC;IAG7D,KAAK/U,kBAAA,GAAqB;MAAE6D,IAAA;MAAMgR,SAAA,EAAWnM,IAAA,CAAKC,GAAA,CAAI,KAAK9E,IAAA,CAAKuF,mBAAA,CAAoB4L,WAAA,IAAe;IAAO;IAC1G,OAAO,KAAKhV,kBAAA,CAAmB6D,IAAA;EAChC;EAAA;AAAA;AAAA;AAAA;AAAA;EAOA,MAAaoR,iBAAiBtV,UAAA,EAA2B;IACxD,MAAM,KAAK0M,QAAA,CAAS7I,OAAA,CAAQ;MAAE2C,MAAA,EAAQ;IAAiC,CAAC;IACxE,KAAKpG,OAAA,CAAQJ,UAAA,GAAaA,UAAA;IAE1B,MAAMC,QAAA,GAAW,MAAM,KAAKsV,WAAA,CAAY,IAAI;IAC5C,MAAM,KAAK7I,QAAA,CAASpK,KAAA,CAAMrC,QAAQ;IAElC,OAAO;EACR;EAAA;AAAA;AAAA;EAKA,MAAaM,cAAA,EAAiC;IAC7C,IAAI,KAAKH,OAAA,CAAQJ,UAAA,EAAY;MAC5B,OAAO,KAAKI,OAAA,CAAQJ,UAAA;IACrB;IAEA,MAAMC,QAAA,GAAW,MAAM,KAAKsV,WAAA,CAAY;IACxC,OAAO5S,IAAA,CAAK6S,GAAA,CAAI,GAAGvV,QAAQ,IAAI;EAChC;EAAA;AAAA;AAAA;EAKA,MAAasV,YAAYN,KAAA,GAAQ,OAA0B;IAC1D,IAAI,KAAKhV,QAAA,IAAY,CAACgV,KAAA,EAAO;MAC5B,OAAO,KAAKhV,QAAA;IACb;IAEA,IAAIA,QAAA;IACJ,IAAI,KAAKG,OAAA,CAAQH,QAAA,EAAU;MAC1B,IAAIwV,KAAA,CAAMC,OAAA,CAAQ,KAAKtV,OAAA,CAAQH,QAAQ,GAAG;QACzCA,QAAA,GAAW,KAAKG,OAAA,CAAQH,QAAA;MACzB,OAAO;QACN,MAAM;UAAE0V,KAAA;UAAOC;QAAI,IAAI,KAAKxV,OAAA,CAAQH,QAAA;QACpCA,QAAA,GAAW,CAAC,OAAG6U,YAAA,CAAAe,KAAA,EAAM;UAAEF,KAAA;UAAOC,GAAA,EAAKA,GAAA,GAAM;QAAE,CAAC,CAAC;MAC9C;IACD,OAAO;MACN,MAAM1R,IAAA,GAAO,MAAM,KAAK5D,uBAAA,CAAwB;MAChDL,QAAA,GAAW,CAAC,OAAG6U,YAAA,CAAAe,KAAA,EAAM,KAAKzV,OAAA,CAAQJ,UAAA,IAAckE,IAAA,CAAKkQ,MAAM,CAAC;IAC7D;IAEA,KAAKnU,QAAA,GAAWA,QAAA;IAChB,OAAOA,QAAA;EACR;EAEA,MAAaoD,QAAA,EAAU;IACtB,MAAMrD,UAAA,GAAa,MAAM,KAAKO,aAAA,CAAc;IAE5C,MAAM2D,IAAA,GAAO,MAAM,KAAK5D,uBAAA,CAAwB;IAChD,IAAI4D,IAAA,CAAKuF,mBAAA,CAAoBsB,SAAA,GAAY/K,UAAA,EAAY;MACpD,MAAM,IAAImE,KAAA,CACT,0CAA0CnE,UAAU,iBACnDkE,IAAA,CAAKuF,mBAAA,CAAoBsB,SAC1B,yBAAyB,IAAIhC,IAAA,CAAKA,IAAA,CAAKC,GAAA,CAAI,IAAI9E,IAAA,CAAKuF,mBAAA,CAAoB4L,WAAW,EAAES,WAAA,CAAY,CAAC,EACnG;IACD;IAGA,MAAM,KAAKR,gBAAA,CAAiBtV,UAAU;IACtC,MAAM,KAAK0M,QAAA,CAASrJ,OAAA,CAAQ;EAC7B;EAEOQ,QAAQzD,OAAA,EAAyD;IACvE,OAAO,KAAKsM,QAAA,CAAS7I,OAAA,CAAQzD,OAAO;EACrC;EAEO6D,KAAK/C,OAAA,EAAiBsC,OAAA,EAA6B;IACzD,OAAO,KAAKkJ,QAAA,CAASzI,IAAA,CAAK/C,OAAA,EAASsC,OAAO;EAC3C;EAEOY,YAAA,EAAc;IACpB,OAAO,KAAKsI,QAAA,CAAStI,WAAA,CAAY;EAClC;AACD;;;AV3SO,IAAM7E,OAAA,GAAU","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}