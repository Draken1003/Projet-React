{"ast":null,"code":"'use strict';\n\nconst {\n  userMention\n} = require('@discordjs/builders');\nconst {\n  ChannelType\n} = require('discord-api-types/v10');\nconst {\n  BaseChannel\n} = require('./BaseChannel');\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\nconst DMMessageManager = require('../managers/DMMessageManager');\nconst Partials = require('../util/Partials');\n\n/**\n * Represents a direct message channel between two users.\n * @extends {BaseChannel}\n * @implements {TextBasedChannel}\n */\nclass DMChannel extends BaseChannel {\n  constructor(client, data) {\n    super(client, data);\n\n    // Override the channel type so partials have a known type\n    this.type = ChannelType.DM;\n\n    /**\n     * A manager of the messages belonging to this channel\n     * @type {DMMessageManager}\n     */\n    this.messages = new DMMessageManager(this);\n  }\n  _patch(data) {\n    super._patch(data);\n    if (data.recipients) {\n      const recipient = data.recipients[0];\n\n      /**\n       * The recipient's id\n       * @type {Snowflake}\n       */\n      this.recipientId = recipient.id;\n      if ('username' in recipient || this.client.options.partials.includes(Partials.User)) {\n        this.client.users._add(recipient);\n      }\n    }\n    if ('last_message_id' in data) {\n      /**\n       * The channel's last message id, if one was sent\n       * @type {?Snowflake}\n       */\n      this.lastMessageId = data.last_message_id;\n    }\n    if ('last_pin_timestamp' in data) {\n      /**\n       * The timestamp when the last pinned message was pinned, if there was one\n       * @type {?number}\n       */\n      this.lastPinTimestamp = Date.parse(data.last_pin_timestamp);\n    } else {\n      this.lastPinTimestamp ??= null;\n    }\n  }\n\n  /**\n   * Whether this DMChannel is a partial\n   * @type {boolean}\n   * @readonly\n   */\n  get partial() {\n    return this.lastMessageId === undefined;\n  }\n\n  /**\n   * The recipient on the other end of the DM\n   * @type {?User}\n   * @readonly\n   */\n  get recipient() {\n    return this.client.users.resolve(this.recipientId);\n  }\n\n  /**\n   * Fetch this DMChannel.\n   * @param {boolean} [force=true] Whether to skip the cache check and request the API\n   * @returns {Promise<DMChannel>}\n   */\n  fetch(force = true) {\n    return this.client.users.createDM(this.recipientId, {\n      force\n    });\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the recipient's mention instead of the\n   * DMChannel object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from <@123456789012345678>!\n   * console.log(`Hello from ${channel}!`);\n   */\n  toString() {\n    return userMention(this.recipientId);\n  }\n\n  // These are here only for documentation purposes - they are implemented by TextBasedChannel\n  /* eslint-disable no-empty-function */\n  get lastMessage() {}\n  get lastPinAt() {}\n  send() {}\n  sendTyping() {}\n  createMessageCollector() {}\n  awaitMessages() {}\n  createMessageComponentCollector() {}\n  awaitMessageComponent() {}\n  // Doesn't work on DM channels; bulkDelete() {}\n  // Doesn't work on DM channels; fetchWebhooks() {}\n  // Doesn't work on DM channels; createWebhook() {}\n  // Doesn't work on DM channels; setRateLimitPerUser() {}\n  // Doesn't work on DM channels; setNSFW() {}\n}\nTextBasedChannel.applyToClass(DMChannel, true, ['bulkDelete', 'fetchWebhooks', 'createWebhook', 'setRateLimitPerUser', 'setNSFW']);\nmodule.exports = DMChannel;","map":{"version":3,"names":["userMention","require","ChannelType","BaseChannel","TextBasedChannel","DMMessageManager","Partials","DMChannel","constructor","client","data","type","DM","messages","_patch","recipients","recipient","recipientId","id","options","partials","includes","User","users","_add","lastMessageId","last_message_id","lastPinTimestamp","Date","parse","last_pin_timestamp","partial","undefined","resolve","fetch","force","createDM","toString","lastMessage","lastPinAt","send","sendTyping","createMessageCollector","awaitMessages","createMessageComponentCollector","awaitMessageComponent","applyToClass","module","exports"],"sources":["C:/Users/hetit/node_modules/discord.js/src/structures/DMChannel.js"],"sourcesContent":["'use strict';\n\nconst { userMention } = require('@discordjs/builders');\nconst { ChannelType } = require('discord-api-types/v10');\nconst { BaseChannel } = require('./BaseChannel');\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\nconst DMMessageManager = require('../managers/DMMessageManager');\nconst Partials = require('../util/Partials');\n\n/**\n * Represents a direct message channel between two users.\n * @extends {BaseChannel}\n * @implements {TextBasedChannel}\n */\nclass DMChannel extends BaseChannel {\n  constructor(client, data) {\n    super(client, data);\n\n    // Override the channel type so partials have a known type\n    this.type = ChannelType.DM;\n\n    /**\n     * A manager of the messages belonging to this channel\n     * @type {DMMessageManager}\n     */\n    this.messages = new DMMessageManager(this);\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if (data.recipients) {\n      const recipient = data.recipients[0];\n\n      /**\n       * The recipient's id\n       * @type {Snowflake}\n       */\n      this.recipientId = recipient.id;\n\n      if ('username' in recipient || this.client.options.partials.includes(Partials.User)) {\n        this.client.users._add(recipient);\n      }\n    }\n\n    if ('last_message_id' in data) {\n      /**\n       * The channel's last message id, if one was sent\n       * @type {?Snowflake}\n       */\n      this.lastMessageId = data.last_message_id;\n    }\n\n    if ('last_pin_timestamp' in data) {\n      /**\n       * The timestamp when the last pinned message was pinned, if there was one\n       * @type {?number}\n       */\n      this.lastPinTimestamp = Date.parse(data.last_pin_timestamp);\n    } else {\n      this.lastPinTimestamp ??= null;\n    }\n  }\n\n  /**\n   * Whether this DMChannel is a partial\n   * @type {boolean}\n   * @readonly\n   */\n  get partial() {\n    return this.lastMessageId === undefined;\n  }\n\n  /**\n   * The recipient on the other end of the DM\n   * @type {?User}\n   * @readonly\n   */\n  get recipient() {\n    return this.client.users.resolve(this.recipientId);\n  }\n\n  /**\n   * Fetch this DMChannel.\n   * @param {boolean} [force=true] Whether to skip the cache check and request the API\n   * @returns {Promise<DMChannel>}\n   */\n  fetch(force = true) {\n    return this.client.users.createDM(this.recipientId, { force });\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the recipient's mention instead of the\n   * DMChannel object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from <@123456789012345678>!\n   * console.log(`Hello from ${channel}!`);\n   */\n  toString() {\n    return userMention(this.recipientId);\n  }\n\n  // These are here only for documentation purposes - they are implemented by TextBasedChannel\n  /* eslint-disable no-empty-function */\n  get lastMessage() {}\n  get lastPinAt() {}\n  send() {}\n  sendTyping() {}\n  createMessageCollector() {}\n  awaitMessages() {}\n  createMessageComponentCollector() {}\n  awaitMessageComponent() {}\n  // Doesn't work on DM channels; bulkDelete() {}\n  // Doesn't work on DM channels; fetchWebhooks() {}\n  // Doesn't work on DM channels; createWebhook() {}\n  // Doesn't work on DM channels; setRateLimitPerUser() {}\n  // Doesn't work on DM channels; setNSFW() {}\n}\n\nTextBasedChannel.applyToClass(DMChannel, true, [\n  'bulkDelete',\n  'fetchWebhooks',\n  'createWebhook',\n  'setRateLimitPerUser',\n  'setNSFW',\n]);\n\nmodule.exports = DMChannel;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}