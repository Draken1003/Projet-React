{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('node:buffer');\nconst {\n  lazy,\n  isJSONEncodable\n} = require('@discordjs/util');\nconst {\n  MessageFlags\n} = require('discord-api-types/v10');\nconst ActionRowBuilder = require('./ActionRowBuilder');\nconst {\n  DiscordjsRangeError,\n  ErrorCodes\n} = require('../errors');\nconst DataResolver = require('../util/DataResolver');\nconst MessageFlagsBitField = require('../util/MessageFlagsBitField');\nconst {\n  basename,\n  verifyString\n} = require('../util/Util');\nconst getBaseInteraction = lazy(() => require('./BaseInteraction'));\n\n/**\n * Represents a message to be sent to the API.\n */\nclass MessagePayload {\n  /**\n   * @param {MessageTarget} target The target for this message to be sent to\n   * @param {MessagePayloadOption} options The payload of this message\n   */\n  constructor(target, options) {\n    /**\n     * The target for this message to be sent to\n     * @type {MessageTarget}\n     */\n    this.target = target;\n\n    /**\n     * The payload of this message.\n     * @type {MessagePayloadOption}\n     */\n    this.options = options;\n\n    /**\n     * Body sendable to the API\n     * @type {?APIMessage}\n     */\n    this.body = null;\n\n    /**\n     * Files sendable to the API\n     * @type {?RawFile[]}\n     */\n    this.files = null;\n  }\n\n  /**\n   * Whether or not the target is a {@link Webhook} or a {@link WebhookClient}\n   * @type {boolean}\n   * @readonly\n   */\n  get isWebhook() {\n    const Webhook = require('./Webhook');\n    const WebhookClient = require('../client/WebhookClient');\n    return this.target instanceof Webhook || this.target instanceof WebhookClient;\n  }\n\n  /**\n   * Whether or not the target is a {@link User}\n   * @type {boolean}\n   * @readonly\n   */\n  get isUser() {\n    const User = require('./User');\n    const {\n      GuildMember\n    } = require('./GuildMember');\n    return this.target instanceof User || this.target instanceof GuildMember;\n  }\n\n  /**\n   * Whether or not the target is a {@link Message}\n   * @type {boolean}\n   * @readonly\n   */\n  get isMessage() {\n    const {\n      Message\n    } = require('./Message');\n    return this.target instanceof Message;\n  }\n\n  /**\n   * Whether or not the target is a {@link MessageManager}\n   * @type {boolean}\n   * @readonly\n   */\n  get isMessageManager() {\n    const MessageManager = require('../managers/MessageManager');\n    return this.target instanceof MessageManager;\n  }\n\n  /**\n   * Whether or not the target is an {@link BaseInteraction} or an {@link InteractionWebhook}\n   * @type {boolean}\n   * @readonly\n   */\n  get isInteraction() {\n    const BaseInteraction = getBaseInteraction();\n    const InteractionWebhook = require('./InteractionWebhook');\n    return this.target instanceof BaseInteraction || this.target instanceof InteractionWebhook;\n  }\n\n  /**\n   * Makes the content of this message.\n   * @returns {?string}\n   */\n  makeContent() {\n    let content;\n    if (this.options.content === null) {\n      content = '';\n    } else if (this.options.content !== undefined) {\n      content = verifyString(this.options.content, DiscordjsRangeError, ErrorCodes.MessageContentType, true);\n    }\n    return content;\n  }\n\n  /**\n   * Resolves the body.\n   * @returns {MessagePayload}\n   */\n  resolveBody() {\n    if (this.body) return this;\n    const isInteraction = this.isInteraction;\n    const isWebhook = this.isWebhook;\n    const content = this.makeContent();\n    const tts = Boolean(this.options.tts);\n    let nonce;\n    if (this.options.nonce !== undefined) {\n      nonce = this.options.nonce;\n      if (typeof nonce === 'number' ? !Number.isInteger(nonce) : typeof nonce !== 'string') {\n        throw new DiscordjsRangeError(ErrorCodes.MessageNonceType);\n      }\n    }\n    const components = this.options.components?.map(c => (isJSONEncodable(c) ? c : new ActionRowBuilder(c)).toJSON());\n    let username;\n    let avatarURL;\n    let threadName;\n    if (isWebhook) {\n      username = this.options.username ?? this.target.name;\n      if (this.options.avatarURL) avatarURL = this.options.avatarURL;\n      if (this.options.threadName) threadName = this.options.threadName;\n    }\n    let flags;\n    if (this.options.flags !== undefined || this.isMessage && this.options.reply === undefined || this.isMessageManager) {\n      flags =\n      // eslint-disable-next-line eqeqeq\n      this.options.flags != null ? new MessageFlagsBitField(this.options.flags).bitfield : this.target.flags?.bitfield;\n    }\n    if (isInteraction && this.options.ephemeral) {\n      flags |= MessageFlags.Ephemeral;\n    }\n    let allowedMentions = this.options.allowedMentions === undefined ? this.target.client.options.allowedMentions : this.options.allowedMentions;\n    if (allowedMentions?.repliedUser !== undefined) {\n      allowedMentions = {\n        ...allowedMentions,\n        replied_user: allowedMentions.repliedUser\n      };\n      delete allowedMentions.repliedUser;\n    }\n    let message_reference;\n    if (typeof this.options.reply === 'object') {\n      const reference = this.options.reply.messageReference;\n      const message_id = this.isMessage ? reference.id ?? reference : this.target.messages.resolveId(reference);\n      if (message_id) {\n        message_reference = {\n          message_id,\n          fail_if_not_exists: this.options.reply.failIfNotExists ?? this.target.client.options.failIfNotExists\n        };\n      }\n    }\n    const attachments = this.options.files?.map((file, index) => ({\n      id: index.toString(),\n      description: file.description\n    }));\n    if (Array.isArray(this.options.attachments)) {\n      this.options.attachments.push(...(attachments ?? []));\n    } else {\n      this.options.attachments = attachments;\n    }\n    this.body = {\n      content,\n      tts,\n      nonce,\n      embeds: this.options.embeds?.map(embed => isJSONEncodable(embed) ? embed.toJSON() : this.target.client.options.jsonTransformer(embed)),\n      components,\n      username,\n      avatar_url: avatarURL,\n      allowed_mentions: content === undefined && message_reference === undefined ? undefined : allowedMentions,\n      flags,\n      message_reference,\n      attachments: this.options.attachments,\n      sticker_ids: this.options.stickers?.map(sticker => sticker.id ?? sticker),\n      thread_name: threadName\n    };\n    return this;\n  }\n\n  /**\n   * Resolves files.\n   * @returns {Promise<MessagePayload>}\n   */\n  async resolveFiles() {\n    if (this.files) return this;\n    this.files = await Promise.all(this.options.files?.map(file => this.constructor.resolveFile(file)) ?? []);\n    return this;\n  }\n\n  /**\n   * Resolves a single file into an object sendable to the API.\n   * @param {AttachmentPayload|BufferResolvable|Stream} fileLike Something that could be resolved to a file\n   * @returns {Promise<RawFile>}\n   */\n  static async resolveFile(fileLike) {\n    let attachment;\n    let name;\n    const findName = thing => {\n      if (typeof thing === 'string') {\n        return basename(thing);\n      }\n      if (thing.path) {\n        return basename(thing.path);\n      }\n      return 'file.jpg';\n    };\n    const ownAttachment = typeof fileLike === 'string' || fileLike instanceof Buffer || typeof fileLike.pipe === 'function';\n    if (ownAttachment) {\n      attachment = fileLike;\n      name = findName(attachment);\n    } else {\n      attachment = fileLike.attachment;\n      name = fileLike.name ?? findName(attachment);\n    }\n    const {\n      data,\n      contentType\n    } = await DataResolver.resolveFile(attachment);\n    return {\n      data,\n      name,\n      contentType\n    };\n  }\n\n  /**\n   * Creates a {@link MessagePayload} from user-level arguments.\n   * @param {MessageTarget} target Target to send to\n   * @param {string|MessagePayloadOption} options Options or content to use\n   * @param {MessagePayloadOption} [extra={}] Extra options to add onto specified options\n   * @returns {MessagePayload}\n   */\n  static create(target, options, extra = {}) {\n    return new this(target, typeof options !== 'object' || options === null ? {\n      content: options,\n      ...extra\n    } : {\n      ...options,\n      ...extra\n    });\n  }\n}\nmodule.exports = MessagePayload;\n\n/**\n * A target for a message.\n * @typedef {TextBasedChannels|User|GuildMember|Webhook|WebhookClient|BaseInteraction|InteractionWebhook|\n * Message|MessageManager} MessageTarget\n */\n\n/**\n * A possible payload option.\n * @typedef {MessageCreateOptions|MessageEditOptions|WebhookMessageCreateOptions|WebhookMessageEditOptions|\n * InteractionReplyOptions|InteractionUpdateOptions} MessagePayloadOption\n */\n\n/**\n * @external APIMessage\n * @see {@link https://discord.com/developers/docs/resources/channel#message-object}\n */\n\n/**\n * @external RawFile\n * @see {@link https://discord.js.org/docs/packages/rest/stable/RawFile:Interface}\n */","map":{"version":3,"names":["Buffer","require","lazy","isJSONEncodable","MessageFlags","ActionRowBuilder","DiscordjsRangeError","ErrorCodes","DataResolver","MessageFlagsBitField","basename","verifyString","getBaseInteraction","MessagePayload","constructor","target","options","body","files","isWebhook","Webhook","WebhookClient","isUser","User","GuildMember","isMessage","Message","isMessageManager","MessageManager","isInteraction","BaseInteraction","InteractionWebhook","makeContent","content","undefined","MessageContentType","resolveBody","tts","Boolean","nonce","Number","isInteger","MessageNonceType","components","map","c","toJSON","username","avatarURL","threadName","name","flags","reply","bitfield","ephemeral","Ephemeral","allowedMentions","client","repliedUser","replied_user","message_reference","reference","messageReference","message_id","id","messages","resolveId","fail_if_not_exists","failIfNotExists","attachments","file","index","toString","description","Array","isArray","push","embeds","embed","jsonTransformer","avatar_url","allowed_mentions","sticker_ids","stickers","sticker","thread_name","resolveFiles","Promise","all","resolveFile","fileLike","attachment","findName","thing","path","ownAttachment","pipe","data","contentType","create","extra","module","exports"],"sources":["C:/Users/hetit/node_modules/discord.js/src/structures/MessagePayload.js"],"sourcesContent":["'use strict';\n\nconst { Buffer } = require('node:buffer');\nconst { lazy, isJSONEncodable } = require('@discordjs/util');\nconst { MessageFlags } = require('discord-api-types/v10');\nconst ActionRowBuilder = require('./ActionRowBuilder');\nconst { DiscordjsRangeError, ErrorCodes } = require('../errors');\nconst DataResolver = require('../util/DataResolver');\nconst MessageFlagsBitField = require('../util/MessageFlagsBitField');\nconst { basename, verifyString } = require('../util/Util');\n\nconst getBaseInteraction = lazy(() => require('./BaseInteraction'));\n\n/**\n * Represents a message to be sent to the API.\n */\nclass MessagePayload {\n  /**\n   * @param {MessageTarget} target The target for this message to be sent to\n   * @param {MessagePayloadOption} options The payload of this message\n   */\n  constructor(target, options) {\n    /**\n     * The target for this message to be sent to\n     * @type {MessageTarget}\n     */\n    this.target = target;\n\n    /**\n     * The payload of this message.\n     * @type {MessagePayloadOption}\n     */\n    this.options = options;\n\n    /**\n     * Body sendable to the API\n     * @type {?APIMessage}\n     */\n    this.body = null;\n\n    /**\n     * Files sendable to the API\n     * @type {?RawFile[]}\n     */\n    this.files = null;\n  }\n\n  /**\n   * Whether or not the target is a {@link Webhook} or a {@link WebhookClient}\n   * @type {boolean}\n   * @readonly\n   */\n  get isWebhook() {\n    const Webhook = require('./Webhook');\n    const WebhookClient = require('../client/WebhookClient');\n    return this.target instanceof Webhook || this.target instanceof WebhookClient;\n  }\n\n  /**\n   * Whether or not the target is a {@link User}\n   * @type {boolean}\n   * @readonly\n   */\n  get isUser() {\n    const User = require('./User');\n    const { GuildMember } = require('./GuildMember');\n    return this.target instanceof User || this.target instanceof GuildMember;\n  }\n\n  /**\n   * Whether or not the target is a {@link Message}\n   * @type {boolean}\n   * @readonly\n   */\n  get isMessage() {\n    const { Message } = require('./Message');\n    return this.target instanceof Message;\n  }\n\n  /**\n   * Whether or not the target is a {@link MessageManager}\n   * @type {boolean}\n   * @readonly\n   */\n  get isMessageManager() {\n    const MessageManager = require('../managers/MessageManager');\n    return this.target instanceof MessageManager;\n  }\n\n  /**\n   * Whether or not the target is an {@link BaseInteraction} or an {@link InteractionWebhook}\n   * @type {boolean}\n   * @readonly\n   */\n  get isInteraction() {\n    const BaseInteraction = getBaseInteraction();\n    const InteractionWebhook = require('./InteractionWebhook');\n    return this.target instanceof BaseInteraction || this.target instanceof InteractionWebhook;\n  }\n\n  /**\n   * Makes the content of this message.\n   * @returns {?string}\n   */\n  makeContent() {\n    let content;\n    if (this.options.content === null) {\n      content = '';\n    } else if (this.options.content !== undefined) {\n      content = verifyString(this.options.content, DiscordjsRangeError, ErrorCodes.MessageContentType, true);\n    }\n\n    return content;\n  }\n\n  /**\n   * Resolves the body.\n   * @returns {MessagePayload}\n   */\n  resolveBody() {\n    if (this.body) return this;\n    const isInteraction = this.isInteraction;\n    const isWebhook = this.isWebhook;\n\n    const content = this.makeContent();\n    const tts = Boolean(this.options.tts);\n\n    let nonce;\n    if (this.options.nonce !== undefined) {\n      nonce = this.options.nonce;\n      if (typeof nonce === 'number' ? !Number.isInteger(nonce) : typeof nonce !== 'string') {\n        throw new DiscordjsRangeError(ErrorCodes.MessageNonceType);\n      }\n    }\n\n    const components = this.options.components?.map(c => (isJSONEncodable(c) ? c : new ActionRowBuilder(c)).toJSON());\n\n    let username;\n    let avatarURL;\n    let threadName;\n    if (isWebhook) {\n      username = this.options.username ?? this.target.name;\n      if (this.options.avatarURL) avatarURL = this.options.avatarURL;\n      if (this.options.threadName) threadName = this.options.threadName;\n    }\n\n    let flags;\n    if (\n      this.options.flags !== undefined ||\n      (this.isMessage && this.options.reply === undefined) ||\n      this.isMessageManager\n    ) {\n      flags =\n        // eslint-disable-next-line eqeqeq\n        this.options.flags != null\n          ? new MessageFlagsBitField(this.options.flags).bitfield\n          : this.target.flags?.bitfield;\n    }\n\n    if (isInteraction && this.options.ephemeral) {\n      flags |= MessageFlags.Ephemeral;\n    }\n\n    let allowedMentions =\n      this.options.allowedMentions === undefined\n        ? this.target.client.options.allowedMentions\n        : this.options.allowedMentions;\n\n    if (allowedMentions?.repliedUser !== undefined) {\n      allowedMentions = { ...allowedMentions, replied_user: allowedMentions.repliedUser };\n      delete allowedMentions.repliedUser;\n    }\n\n    let message_reference;\n    if (typeof this.options.reply === 'object') {\n      const reference = this.options.reply.messageReference;\n      const message_id = this.isMessage ? reference.id ?? reference : this.target.messages.resolveId(reference);\n      if (message_id) {\n        message_reference = {\n          message_id,\n          fail_if_not_exists: this.options.reply.failIfNotExists ?? this.target.client.options.failIfNotExists,\n        };\n      }\n    }\n\n    const attachments = this.options.files?.map((file, index) => ({\n      id: index.toString(),\n      description: file.description,\n    }));\n    if (Array.isArray(this.options.attachments)) {\n      this.options.attachments.push(...(attachments ?? []));\n    } else {\n      this.options.attachments = attachments;\n    }\n\n    this.body = {\n      content,\n      tts,\n      nonce,\n      embeds: this.options.embeds?.map(embed =>\n        isJSONEncodable(embed) ? embed.toJSON() : this.target.client.options.jsonTransformer(embed),\n      ),\n      components,\n      username,\n      avatar_url: avatarURL,\n      allowed_mentions: content === undefined && message_reference === undefined ? undefined : allowedMentions,\n      flags,\n      message_reference,\n      attachments: this.options.attachments,\n      sticker_ids: this.options.stickers?.map(sticker => sticker.id ?? sticker),\n      thread_name: threadName,\n    };\n    return this;\n  }\n\n  /**\n   * Resolves files.\n   * @returns {Promise<MessagePayload>}\n   */\n  async resolveFiles() {\n    if (this.files) return this;\n\n    this.files = await Promise.all(this.options.files?.map(file => this.constructor.resolveFile(file)) ?? []);\n    return this;\n  }\n\n  /**\n   * Resolves a single file into an object sendable to the API.\n   * @param {AttachmentPayload|BufferResolvable|Stream} fileLike Something that could be resolved to a file\n   * @returns {Promise<RawFile>}\n   */\n  static async resolveFile(fileLike) {\n    let attachment;\n    let name;\n\n    const findName = thing => {\n      if (typeof thing === 'string') {\n        return basename(thing);\n      }\n\n      if (thing.path) {\n        return basename(thing.path);\n      }\n\n      return 'file.jpg';\n    };\n\n    const ownAttachment =\n      typeof fileLike === 'string' || fileLike instanceof Buffer || typeof fileLike.pipe === 'function';\n    if (ownAttachment) {\n      attachment = fileLike;\n      name = findName(attachment);\n    } else {\n      attachment = fileLike.attachment;\n      name = fileLike.name ?? findName(attachment);\n    }\n\n    const { data, contentType } = await DataResolver.resolveFile(attachment);\n    return { data, name, contentType };\n  }\n\n  /**\n   * Creates a {@link MessagePayload} from user-level arguments.\n   * @param {MessageTarget} target Target to send to\n   * @param {string|MessagePayloadOption} options Options or content to use\n   * @param {MessagePayloadOption} [extra={}] Extra options to add onto specified options\n   * @returns {MessagePayload}\n   */\n  static create(target, options, extra = {}) {\n    return new this(\n      target,\n      typeof options !== 'object' || options === null ? { content: options, ...extra } : { ...options, ...extra },\n    );\n  }\n}\n\nmodule.exports = MessagePayload;\n\n/**\n * A target for a message.\n * @typedef {TextBasedChannels|User|GuildMember|Webhook|WebhookClient|BaseInteraction|InteractionWebhook|\n * Message|MessageManager} MessageTarget\n */\n\n/**\n * A possible payload option.\n * @typedef {MessageCreateOptions|MessageEditOptions|WebhookMessageCreateOptions|WebhookMessageEditOptions|\n * InteractionReplyOptions|InteractionUpdateOptions} MessagePayloadOption\n */\n\n/**\n * @external APIMessage\n * @see {@link https://discord.com/developers/docs/resources/channel#message-object}\n */\n\n/**\n * @external RawFile\n * @see {@link https://discord.js.org/docs/packages/rest/stable/RawFile:Interface}\n */\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}