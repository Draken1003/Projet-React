{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('node:events');\nconst process = require('node:process');\nconst {\n  setImmediate\n} = require('node:timers');\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  WebSocketManager: WSWebSocketManager,\n  WebSocketShardEvents: WSWebSocketShardEvents,\n  CompressionMethod,\n  CloseCodes\n} = require('@discordjs/ws');\nconst {\n  GatewayCloseCodes,\n  GatewayDispatchEvents\n} = require('discord-api-types/v10');\nconst WebSocketShard = require('./WebSocketShard');\nconst PacketHandlers = require('./handlers');\nconst {\n  DiscordjsError,\n  ErrorCodes\n} = require('../../errors');\nconst Events = require('../../util/Events');\nconst Status = require('../../util/Status');\nconst WebSocketShardEvents = require('../../util/WebSocketShardEvents');\nlet zlib;\ntry {\n  zlib = require('zlib-sync');\n} catch {} // eslint-disable-line no-empty\n\nconst BeforeReadyWhitelist = [GatewayDispatchEvents.Ready, GatewayDispatchEvents.Resumed, GatewayDispatchEvents.GuildCreate, GatewayDispatchEvents.GuildDelete, GatewayDispatchEvents.GuildMembersChunk, GatewayDispatchEvents.GuildMemberAdd, GatewayDispatchEvents.GuildMemberRemove];\nconst WaitingForGuildEvents = [GatewayDispatchEvents.GuildCreate, GatewayDispatchEvents.GuildDelete];\nconst UNRESUMABLE_CLOSE_CODES = [CloseCodes.Normal, GatewayCloseCodes.AlreadyAuthenticated, GatewayCloseCodes.InvalidSeq];\nconst reasonIsDeprecated = 'the reason property is deprecated, use the code property to determine the reason';\nlet deprecationEmittedForInvalidSessionEvent = false;\nlet deprecationEmittedForDestroyedEvent = false;\n\n/**\n * The WebSocket manager for this client.\n * <info>This class forwards raw dispatch events,\n * read more about it here {@link https://discord.com/developers/docs/topics/gateway}</info>\n * @extends {EventEmitter}\n */\nclass WebSocketManager extends EventEmitter {\n  constructor(client) {\n    super();\n\n    /**\n     * The client that instantiated this WebSocketManager\n     * @type {Client}\n     * @readonly\n     * @name WebSocketManager#client\n     */\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n\n    /**\n     * The gateway this manager uses\n     * @type {?string}\n     */\n    this.gateway = null;\n\n    /**\n     * A collection of all shards this manager handles\n     * @type {Collection<number, WebSocketShard>}\n     */\n    this.shards = new Collection();\n\n    /**\n     * An array of queued events before this WebSocketManager became ready\n     * @type {Object[]}\n     * @private\n     * @name WebSocketManager#packetQueue\n     */\n    Object.defineProperty(this, 'packetQueue', {\n      value: []\n    });\n\n    /**\n     * The current status of this WebSocketManager\n     * @type {Status}\n     */\n    this.status = Status.Idle;\n\n    /**\n     * If this manager was destroyed. It will prevent shards from reconnecting\n     * @type {boolean}\n     * @private\n     */\n    this.destroyed = false;\n\n    /**\n     * The internal WebSocketManager from `@discordjs/ws`.\n     * @type {WSWebSocketManager}\n     * @private\n     */\n    this._ws = null;\n  }\n\n  /**\n   * The average ping of all WebSocketShards\n   * @type {number}\n   * @readonly\n   */\n  get ping() {\n    const sum = this.shards.reduce((a, b) => a + b.ping, 0);\n    return sum / this.shards.size;\n  }\n\n  /**\n   * Emits a debug message.\n   * @param {string} message The debug message\n   * @param {?number} [shardId] The id of the shard that emitted this message, if any\n   * @private\n   */\n  debug(message, shardId) {\n    this.client.emit(Events.Debug, `[WS => ${typeof shardId === 'number' ? `Shard ${shardId}` : 'Manager'}] ${message}`);\n  }\n\n  /**\n   * Connects this manager to the gateway.\n   * @private\n   */\n  async connect() {\n    const invalidToken = new DiscordjsError(ErrorCodes.TokenInvalid);\n    const {\n      shards,\n      shardCount,\n      intents,\n      ws\n    } = this.client.options;\n    if (this._ws && this._ws.options.token !== this.client.token) {\n      await this._ws.destroy({\n        code: CloseCodes.Normal,\n        reason: 'Login with differing token requested'\n      });\n      this._ws = null;\n    }\n    if (!this._ws) {\n      const wsOptions = {\n        intents: intents.bitfield,\n        rest: this.client.rest,\n        token: this.client.token,\n        largeThreshold: ws.large_threshold,\n        version: ws.version,\n        shardIds: shards === 'auto' ? null : shards,\n        shardCount: shards === 'auto' ? null : shardCount,\n        initialPresence: ws.presence,\n        retrieveSessionInfo: shardId => this.shards.get(shardId).sessionInfo,\n        updateSessionInfo: (shardId, sessionInfo) => {\n          this.shards.get(shardId).sessionInfo = sessionInfo;\n        },\n        compression: zlib ? CompressionMethod.ZlibStream : null\n      };\n      if (ws.buildIdentifyThrottler) wsOptions.buildIdentifyThrottler = ws.buildIdentifyThrottler;\n      if (ws.buildStrategy) wsOptions.buildStrategy = ws.buildStrategy;\n      this._ws = new WSWebSocketManager(wsOptions);\n      this.attachEvents();\n    }\n    const {\n      url: gatewayURL,\n      shards: recommendedShards,\n      session_start_limit: sessionStartLimit\n    } = await this._ws.fetchGatewayInformation().catch(error => {\n      throw error.status === 401 ? invalidToken : error;\n    });\n    const {\n      total,\n      remaining\n    } = sessionStartLimit;\n    this.debug(`Fetched Gateway Information\n    URL: ${gatewayURL}\n    Recommended Shards: ${recommendedShards}`);\n    this.debug(`Session Limit Information\n    Total: ${total}\n    Remaining: ${remaining}`);\n    this.gateway = `${gatewayURL}/`;\n    this.client.options.shardCount = await this._ws.getShardCount();\n    this.client.options.shards = await this._ws.getShardIds();\n    this.totalShards = this.client.options.shards.length;\n    for (const id of this.client.options.shards) {\n      if (!this.shards.has(id)) {\n        const shard = new WebSocketShard(this, id);\n        this.shards.set(id, shard);\n        shard.on(WebSocketShardEvents.AllReady, unavailableGuilds => {\n          /**\n           * Emitted when a shard turns ready.\n           * @event Client#shardReady\n           * @param {number} id The shard id that turned ready\n           * @param {?Set<Snowflake>} unavailableGuilds Set of unavailable guild ids, if any\n           */\n          this.client.emit(Events.ShardReady, shard.id, unavailableGuilds);\n          this.checkShardsReady();\n        });\n        shard.status = Status.Connecting;\n      }\n    }\n    await this._ws.connect();\n    this.shards.forEach(shard => {\n      if (shard.listenerCount(WebSocketShardEvents.InvalidSession) > 0 && !deprecationEmittedForInvalidSessionEvent) {\n        process.emitWarning('The WebSocketShard#invalidSession event is deprecated and will never emit.', 'DeprecationWarning');\n        deprecationEmittedForInvalidSessionEvent = true;\n      }\n      if (shard.listenerCount(WebSocketShardEvents.Destroyed) > 0 && !deprecationEmittedForDestroyedEvent) {\n        process.emitWarning('The WebSocketShard#destroyed event is deprecated and will never emit.', 'DeprecationWarning');\n        deprecationEmittedForDestroyedEvent = true;\n      }\n    });\n  }\n\n  /**\n   * Attaches event handlers to the internal WebSocketShardManager from `@discordjs/ws`.\n   * @private\n   */\n  attachEvents() {\n    this._ws.on(WSWebSocketShardEvents.Debug, ({\n      message,\n      shardId\n    }) => this.debug(message, shardId));\n    this._ws.on(WSWebSocketShardEvents.Dispatch, ({\n      data,\n      shardId\n    }) => {\n      this.client.emit(Events.Raw, data, shardId);\n      this.emit(data.t, data.d, shardId);\n      const shard = this.shards.get(shardId);\n      this.handlePacket(data, shard);\n      if (shard.status === Status.WaitingForGuilds && WaitingForGuildEvents.includes(data.t)) {\n        shard.gotGuild(data.d.id);\n      }\n    });\n    this._ws.on(WSWebSocketShardEvents.Ready, ({\n      data,\n      shardId\n    }) => {\n      this.shards.get(shardId).onReadyPacket(data);\n    });\n    this._ws.on(WSWebSocketShardEvents.Closed, ({\n      code,\n      shardId\n    }) => {\n      const shard = this.shards.get(shardId);\n      shard.emit(WebSocketShardEvents.Close, {\n        code,\n        reason: reasonIsDeprecated,\n        wasClean: true\n      });\n      if (UNRESUMABLE_CLOSE_CODES.includes(code) && this.destroyed) {\n        shard.status = Status.Disconnected;\n        /**\n         * Emitted when a shard's WebSocket disconnects and will no longer reconnect.\n         * @event Client#shardDisconnect\n         * @param {CloseEvent} event The WebSocket close event\n         * @param {number} id The shard id that disconnected\n         */\n        this.client.emit(Events.ShardDisconnect, {\n          code,\n          reason: reasonIsDeprecated,\n          wasClean: true\n        }, shardId);\n        this.debug(GatewayCloseCodes[code], shardId);\n        return;\n      }\n      this.shards.get(shardId).status = Status.Connecting;\n      /**\n       * Emitted when a shard is attempting to reconnect or re-identify.\n       * @event Client#shardReconnecting\n       * @param {number} id The shard id that is attempting to reconnect\n       */\n      this.client.emit(Events.ShardReconnecting, shardId);\n    });\n    this._ws.on(WSWebSocketShardEvents.Hello, ({\n      shardId\n    }) => {\n      const shard = this.shards.get(shardId);\n      if (shard.sessionInfo) {\n        shard.closeSequence = shard.sessionInfo.sequence;\n        shard.status = Status.Resuming;\n      } else {\n        shard.status = Status.Identifying;\n      }\n    });\n    this._ws.on(WSWebSocketShardEvents.Resumed, ({\n      shardId\n    }) => {\n      const shard = this.shards.get(shardId);\n      shard.status = Status.Ready;\n      /**\n       * Emitted when the shard resumes successfully\n       * @event WebSocketShard#resumed\n       */\n      shard.emit(WebSocketShardEvents.Resumed);\n    });\n    this._ws.on(WSWebSocketShardEvents.HeartbeatComplete, ({\n      heartbeatAt,\n      latency,\n      shardId\n    }) => {\n      this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`, shardId);\n      const shard = this.shards.get(shardId);\n      shard.lastPingTimestamp = heartbeatAt;\n      shard.ping = latency;\n    });\n    this._ws.on(WSWebSocketShardEvents.Error, ({\n      error,\n      shardId\n    }) => {\n      /**\n       * Emitted whenever a shard's WebSocket encounters a connection error.\n       * @event Client#shardError\n       * @param {Error} error The encountered error\n       * @param {number} shardId The shard that encountered this error\n       */\n      this.client.emit(Events.ShardError, error, shardId);\n    });\n  }\n\n  /**\n   * Broadcasts a packet to every shard this manager handles.\n   * @param {Object} packet The packet to send\n   * @private\n   */\n  broadcast(packet) {\n    for (const shardId of this.shards.keys()) this._ws.send(shardId, packet);\n  }\n\n  /**\n   * Destroys this manager and all its shards.\n   * @private\n   */\n  async destroy() {\n    if (this.destroyed) return;\n    // TODO: Make a util for getting a stack\n    this.debug(`Manager was destroyed. Called by:\\n${new Error().stack}`);\n    this.destroyed = true;\n    await this._ws?.destroy({\n      code: CloseCodes.Normal\n    });\n  }\n\n  /**\n   * Processes a packet and queues it if this WebSocketManager is not ready.\n   * @param {Object} [packet] The packet to be handled\n   * @param {WebSocketShard} [shard] The shard that will handle this packet\n   * @returns {boolean}\n   * @private\n   */\n  handlePacket(packet, shard) {\n    if (packet && this.status !== Status.Ready) {\n      if (!BeforeReadyWhitelist.includes(packet.t)) {\n        this.packetQueue.push({\n          packet,\n          shard\n        });\n        return false;\n      }\n    }\n    if (this.packetQueue.length) {\n      const item = this.packetQueue.shift();\n      setImmediate(() => {\n        this.handlePacket(item.packet, item.shard);\n      }).unref();\n    }\n    if (packet && PacketHandlers[packet.t]) {\n      PacketHandlers[packet.t](this.client, packet, shard);\n    }\n    return true;\n  }\n\n  /**\n   * Checks whether the client is ready to be marked as ready.\n   * @private\n   */\n  checkShardsReady() {\n    if (this.status === Status.Ready) return;\n    if (this.shards.size !== this.totalShards || this.shards.some(s => s.status !== Status.Ready)) {\n      return;\n    }\n    this.triggerClientReady();\n  }\n\n  /**\n   * Causes the client to be marked as ready and emits the ready event.\n   * @private\n   */\n  triggerClientReady() {\n    this.status = Status.Ready;\n    this.client.readyTimestamp = Date.now();\n\n    /**\n     * Emitted when the client becomes ready to start working.\n     * @event Client#ready\n     * @param {Client} client The client\n     */\n    this.client.emit(Events.ClientReady, this.client);\n    this.handlePacket();\n  }\n}\nmodule.exports = WebSocketManager;","map":{"version":3,"names":["EventEmitter","require","process","setImmediate","Collection","WebSocketManager","WSWebSocketManager","WebSocketShardEvents","WSWebSocketShardEvents","CompressionMethod","CloseCodes","GatewayCloseCodes","GatewayDispatchEvents","WebSocketShard","PacketHandlers","DiscordjsError","ErrorCodes","Events","Status","zlib","BeforeReadyWhitelist","Ready","Resumed","GuildCreate","GuildDelete","GuildMembersChunk","GuildMemberAdd","GuildMemberRemove","WaitingForGuildEvents","UNRESUMABLE_CLOSE_CODES","Normal","AlreadyAuthenticated","InvalidSeq","reasonIsDeprecated","deprecationEmittedForInvalidSessionEvent","deprecationEmittedForDestroyedEvent","constructor","client","Object","defineProperty","value","gateway","shards","status","Idle","destroyed","_ws","ping","sum","reduce","a","b","size","debug","message","shardId","emit","Debug","connect","invalidToken","TokenInvalid","shardCount","intents","ws","options","token","destroy","code","reason","wsOptions","bitfield","rest","largeThreshold","large_threshold","version","shardIds","initialPresence","presence","retrieveSessionInfo","get","sessionInfo","updateSessionInfo","compression","ZlibStream","buildIdentifyThrottler","buildStrategy","attachEvents","url","gatewayURL","recommendedShards","session_start_limit","sessionStartLimit","fetchGatewayInformation","catch","error","total","remaining","getShardCount","getShardIds","totalShards","length","id","has","shard","set","on","AllReady","unavailableGuilds","ShardReady","checkShardsReady","Connecting","forEach","listenerCount","InvalidSession","emitWarning","Destroyed","Dispatch","data","Raw","t","d","handlePacket","WaitingForGuilds","includes","gotGuild","onReadyPacket","Closed","Close","wasClean","Disconnected","ShardDisconnect","ShardReconnecting","Hello","closeSequence","sequence","Resuming","Identifying","HeartbeatComplete","heartbeatAt","latency","lastPingTimestamp","Error","ShardError","broadcast","packet","keys","send","stack","packetQueue","push","item","shift","unref","some","s","triggerClientReady","readyTimestamp","Date","now","ClientReady","module","exports"],"sources":["C:/Users/hetit/node_modules/discord.js/src/client/websocket/WebSocketManager.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('node:events');\nconst process = require('node:process');\nconst { setImmediate } = require('node:timers');\nconst { Collection } = require('@discordjs/collection');\nconst {\n  WebSocketManager: WSWebSocketManager,\n  WebSocketShardEvents: WSWebSocketShardEvents,\n  CompressionMethod,\n  CloseCodes,\n} = require('@discordjs/ws');\nconst { GatewayCloseCodes, GatewayDispatchEvents } = require('discord-api-types/v10');\nconst WebSocketShard = require('./WebSocketShard');\nconst PacketHandlers = require('./handlers');\nconst { DiscordjsError, ErrorCodes } = require('../../errors');\nconst Events = require('../../util/Events');\nconst Status = require('../../util/Status');\nconst WebSocketShardEvents = require('../../util/WebSocketShardEvents');\n\nlet zlib;\n\ntry {\n  zlib = require('zlib-sync');\n} catch {} // eslint-disable-line no-empty\n\nconst BeforeReadyWhitelist = [\n  GatewayDispatchEvents.Ready,\n  GatewayDispatchEvents.Resumed,\n  GatewayDispatchEvents.GuildCreate,\n  GatewayDispatchEvents.GuildDelete,\n  GatewayDispatchEvents.GuildMembersChunk,\n  GatewayDispatchEvents.GuildMemberAdd,\n  GatewayDispatchEvents.GuildMemberRemove,\n];\n\nconst WaitingForGuildEvents = [GatewayDispatchEvents.GuildCreate, GatewayDispatchEvents.GuildDelete];\n\nconst UNRESUMABLE_CLOSE_CODES = [\n  CloseCodes.Normal,\n  GatewayCloseCodes.AlreadyAuthenticated,\n  GatewayCloseCodes.InvalidSeq,\n];\n\nconst reasonIsDeprecated = 'the reason property is deprecated, use the code property to determine the reason';\nlet deprecationEmittedForInvalidSessionEvent = false;\nlet deprecationEmittedForDestroyedEvent = false;\n\n/**\n * The WebSocket manager for this client.\n * <info>This class forwards raw dispatch events,\n * read more about it here {@link https://discord.com/developers/docs/topics/gateway}</info>\n * @extends {EventEmitter}\n */\nclass WebSocketManager extends EventEmitter {\n  constructor(client) {\n    super();\n\n    /**\n     * The client that instantiated this WebSocketManager\n     * @type {Client}\n     * @readonly\n     * @name WebSocketManager#client\n     */\n    Object.defineProperty(this, 'client', { value: client });\n\n    /**\n     * The gateway this manager uses\n     * @type {?string}\n     */\n    this.gateway = null;\n\n    /**\n     * A collection of all shards this manager handles\n     * @type {Collection<number, WebSocketShard>}\n     */\n    this.shards = new Collection();\n\n    /**\n     * An array of queued events before this WebSocketManager became ready\n     * @type {Object[]}\n     * @private\n     * @name WebSocketManager#packetQueue\n     */\n    Object.defineProperty(this, 'packetQueue', { value: [] });\n\n    /**\n     * The current status of this WebSocketManager\n     * @type {Status}\n     */\n    this.status = Status.Idle;\n\n    /**\n     * If this manager was destroyed. It will prevent shards from reconnecting\n     * @type {boolean}\n     * @private\n     */\n    this.destroyed = false;\n\n    /**\n     * The internal WebSocketManager from `@discordjs/ws`.\n     * @type {WSWebSocketManager}\n     * @private\n     */\n    this._ws = null;\n  }\n\n  /**\n   * The average ping of all WebSocketShards\n   * @type {number}\n   * @readonly\n   */\n  get ping() {\n    const sum = this.shards.reduce((a, b) => a + b.ping, 0);\n    return sum / this.shards.size;\n  }\n\n  /**\n   * Emits a debug message.\n   * @param {string} message The debug message\n   * @param {?number} [shardId] The id of the shard that emitted this message, if any\n   * @private\n   */\n  debug(message, shardId) {\n    this.client.emit(\n      Events.Debug,\n      `[WS => ${typeof shardId === 'number' ? `Shard ${shardId}` : 'Manager'}] ${message}`,\n    );\n  }\n\n  /**\n   * Connects this manager to the gateway.\n   * @private\n   */\n  async connect() {\n    const invalidToken = new DiscordjsError(ErrorCodes.TokenInvalid);\n    const { shards, shardCount, intents, ws } = this.client.options;\n    if (this._ws && this._ws.options.token !== this.client.token) {\n      await this._ws.destroy({ code: CloseCodes.Normal, reason: 'Login with differing token requested' });\n      this._ws = null;\n    }\n    if (!this._ws) {\n      const wsOptions = {\n        intents: intents.bitfield,\n        rest: this.client.rest,\n        token: this.client.token,\n        largeThreshold: ws.large_threshold,\n        version: ws.version,\n        shardIds: shards === 'auto' ? null : shards,\n        shardCount: shards === 'auto' ? null : shardCount,\n        initialPresence: ws.presence,\n        retrieveSessionInfo: shardId => this.shards.get(shardId).sessionInfo,\n        updateSessionInfo: (shardId, sessionInfo) => {\n          this.shards.get(shardId).sessionInfo = sessionInfo;\n        },\n        compression: zlib ? CompressionMethod.ZlibStream : null,\n      };\n      if (ws.buildIdentifyThrottler) wsOptions.buildIdentifyThrottler = ws.buildIdentifyThrottler;\n      if (ws.buildStrategy) wsOptions.buildStrategy = ws.buildStrategy;\n      this._ws = new WSWebSocketManager(wsOptions);\n      this.attachEvents();\n    }\n\n    const {\n      url: gatewayURL,\n      shards: recommendedShards,\n      session_start_limit: sessionStartLimit,\n    } = await this._ws.fetchGatewayInformation().catch(error => {\n      throw error.status === 401 ? invalidToken : error;\n    });\n\n    const { total, remaining } = sessionStartLimit;\n\n    this.debug(`Fetched Gateway Information\n    URL: ${gatewayURL}\n    Recommended Shards: ${recommendedShards}`);\n\n    this.debug(`Session Limit Information\n    Total: ${total}\n    Remaining: ${remaining}`);\n\n    this.gateway = `${gatewayURL}/`;\n\n    this.client.options.shardCount = await this._ws.getShardCount();\n    this.client.options.shards = await this._ws.getShardIds();\n    this.totalShards = this.client.options.shards.length;\n    for (const id of this.client.options.shards) {\n      if (!this.shards.has(id)) {\n        const shard = new WebSocketShard(this, id);\n        this.shards.set(id, shard);\n\n        shard.on(WebSocketShardEvents.AllReady, unavailableGuilds => {\n          /**\n           * Emitted when a shard turns ready.\n           * @event Client#shardReady\n           * @param {number} id The shard id that turned ready\n           * @param {?Set<Snowflake>} unavailableGuilds Set of unavailable guild ids, if any\n           */\n          this.client.emit(Events.ShardReady, shard.id, unavailableGuilds);\n\n          this.checkShardsReady();\n        });\n        shard.status = Status.Connecting;\n      }\n    }\n\n    await this._ws.connect();\n\n    this.shards.forEach(shard => {\n      if (shard.listenerCount(WebSocketShardEvents.InvalidSession) > 0 && !deprecationEmittedForInvalidSessionEvent) {\n        process.emitWarning(\n          'The WebSocketShard#invalidSession event is deprecated and will never emit.',\n          'DeprecationWarning',\n        );\n\n        deprecationEmittedForInvalidSessionEvent = true;\n      }\n      if (shard.listenerCount(WebSocketShardEvents.Destroyed) > 0 && !deprecationEmittedForDestroyedEvent) {\n        process.emitWarning(\n          'The WebSocketShard#destroyed event is deprecated and will never emit.',\n          'DeprecationWarning',\n        );\n\n        deprecationEmittedForDestroyedEvent = true;\n      }\n    });\n  }\n\n  /**\n   * Attaches event handlers to the internal WebSocketShardManager from `@discordjs/ws`.\n   * @private\n   */\n  attachEvents() {\n    this._ws.on(WSWebSocketShardEvents.Debug, ({ message, shardId }) => this.debug(message, shardId));\n    this._ws.on(WSWebSocketShardEvents.Dispatch, ({ data, shardId }) => {\n      this.client.emit(Events.Raw, data, shardId);\n      this.emit(data.t, data.d, shardId);\n      const shard = this.shards.get(shardId);\n      this.handlePacket(data, shard);\n      if (shard.status === Status.WaitingForGuilds && WaitingForGuildEvents.includes(data.t)) {\n        shard.gotGuild(data.d.id);\n      }\n    });\n\n    this._ws.on(WSWebSocketShardEvents.Ready, ({ data, shardId }) => {\n      this.shards.get(shardId).onReadyPacket(data);\n    });\n\n    this._ws.on(WSWebSocketShardEvents.Closed, ({ code, shardId }) => {\n      const shard = this.shards.get(shardId);\n      shard.emit(WebSocketShardEvents.Close, { code, reason: reasonIsDeprecated, wasClean: true });\n      if (UNRESUMABLE_CLOSE_CODES.includes(code) && this.destroyed) {\n        shard.status = Status.Disconnected;\n        /**\n         * Emitted when a shard's WebSocket disconnects and will no longer reconnect.\n         * @event Client#shardDisconnect\n         * @param {CloseEvent} event The WebSocket close event\n         * @param {number} id The shard id that disconnected\n         */\n        this.client.emit(Events.ShardDisconnect, { code, reason: reasonIsDeprecated, wasClean: true }, shardId);\n        this.debug(GatewayCloseCodes[code], shardId);\n        return;\n      }\n\n      this.shards.get(shardId).status = Status.Connecting;\n      /**\n       * Emitted when a shard is attempting to reconnect or re-identify.\n       * @event Client#shardReconnecting\n       * @param {number} id The shard id that is attempting to reconnect\n       */\n      this.client.emit(Events.ShardReconnecting, shardId);\n    });\n    this._ws.on(WSWebSocketShardEvents.Hello, ({ shardId }) => {\n      const shard = this.shards.get(shardId);\n      if (shard.sessionInfo) {\n        shard.closeSequence = shard.sessionInfo.sequence;\n        shard.status = Status.Resuming;\n      } else {\n        shard.status = Status.Identifying;\n      }\n    });\n\n    this._ws.on(WSWebSocketShardEvents.Resumed, ({ shardId }) => {\n      const shard = this.shards.get(shardId);\n      shard.status = Status.Ready;\n      /**\n       * Emitted when the shard resumes successfully\n       * @event WebSocketShard#resumed\n       */\n      shard.emit(WebSocketShardEvents.Resumed);\n    });\n\n    this._ws.on(WSWebSocketShardEvents.HeartbeatComplete, ({ heartbeatAt, latency, shardId }) => {\n      this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`, shardId);\n      const shard = this.shards.get(shardId);\n      shard.lastPingTimestamp = heartbeatAt;\n      shard.ping = latency;\n    });\n\n    this._ws.on(WSWebSocketShardEvents.Error, ({ error, shardId }) => {\n      /**\n       * Emitted whenever a shard's WebSocket encounters a connection error.\n       * @event Client#shardError\n       * @param {Error} error The encountered error\n       * @param {number} shardId The shard that encountered this error\n       */\n      this.client.emit(Events.ShardError, error, shardId);\n    });\n  }\n\n  /**\n   * Broadcasts a packet to every shard this manager handles.\n   * @param {Object} packet The packet to send\n   * @private\n   */\n  broadcast(packet) {\n    for (const shardId of this.shards.keys()) this._ws.send(shardId, packet);\n  }\n\n  /**\n   * Destroys this manager and all its shards.\n   * @private\n   */\n  async destroy() {\n    if (this.destroyed) return;\n    // TODO: Make a util for getting a stack\n    this.debug(`Manager was destroyed. Called by:\\n${new Error().stack}`);\n    this.destroyed = true;\n    await this._ws?.destroy({ code: CloseCodes.Normal });\n  }\n\n  /**\n   * Processes a packet and queues it if this WebSocketManager is not ready.\n   * @param {Object} [packet] The packet to be handled\n   * @param {WebSocketShard} [shard] The shard that will handle this packet\n   * @returns {boolean}\n   * @private\n   */\n  handlePacket(packet, shard) {\n    if (packet && this.status !== Status.Ready) {\n      if (!BeforeReadyWhitelist.includes(packet.t)) {\n        this.packetQueue.push({ packet, shard });\n        return false;\n      }\n    }\n\n    if (this.packetQueue.length) {\n      const item = this.packetQueue.shift();\n      setImmediate(() => {\n        this.handlePacket(item.packet, item.shard);\n      }).unref();\n    }\n\n    if (packet && PacketHandlers[packet.t]) {\n      PacketHandlers[packet.t](this.client, packet, shard);\n    }\n\n    return true;\n  }\n\n  /**\n   * Checks whether the client is ready to be marked as ready.\n   * @private\n   */\n  checkShardsReady() {\n    if (this.status === Status.Ready) return;\n    if (this.shards.size !== this.totalShards || this.shards.some(s => s.status !== Status.Ready)) {\n      return;\n    }\n\n    this.triggerClientReady();\n  }\n\n  /**\n   * Causes the client to be marked as ready and emits the ready event.\n   * @private\n   */\n  triggerClientReady() {\n    this.status = Status.Ready;\n\n    this.client.readyTimestamp = Date.now();\n\n    /**\n     * Emitted when the client becomes ready to start working.\n     * @event Client#ready\n     * @param {Client} client The client\n     */\n    this.client.emit(Events.ClientReady, this.client);\n\n    this.handlePacket();\n  }\n}\n\nmodule.exports = WebSocketManager;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}