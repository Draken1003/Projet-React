{"ast":null,"code":"'use strict';\n\nconst {\n  Snowflake\n} = require('@sapphire/snowflake');\nconst {\n  PermissionFlagsBits,\n  ChannelType\n} = require('discord-api-types/v10');\nconst {\n  BaseChannel\n} = require('./BaseChannel');\nconst {\n  DiscordjsError,\n  ErrorCodes\n} = require('../errors');\nconst PermissionOverwriteManager = require('../managers/PermissionOverwriteManager');\nconst {\n  VoiceBasedChannelTypes\n} = require('../util/Constants');\nconst PermissionsBitField = require('../util/PermissionsBitField');\nconst {\n  getSortableGroupTypes\n} = require('../util/Util');\n\n/**\n * Represents a guild channel from any of the following:\n * - {@link TextChannel}\n * - {@link VoiceChannel}\n * - {@link CategoryChannel}\n * - {@link NewsChannel}\n * - {@link StageChannel}\n * - {@link ForumChannel}\n * @extends {BaseChannel}\n * @abstract\n */\nclass GuildChannel extends BaseChannel {\n  constructor(guild, data, client, immediatePatch = true) {\n    super(client, data, false);\n\n    /**\n     * The guild the channel is in\n     * @type {Guild}\n     */\n    this.guild = guild;\n\n    /**\n     * The id of the guild the channel is in\n     * @type {Snowflake}\n     */\n    this.guildId = guild?.id ?? data.guild_id;\n    /**\n     * A manager of permission overwrites that belong to this channel\n     * @type {PermissionOverwriteManager}\n     */\n    this.permissionOverwrites = new PermissionOverwriteManager(this);\n    if (data && immediatePatch) this._patch(data);\n  }\n  _patch(data) {\n    super._patch(data);\n    if ('name' in data) {\n      /**\n       * The name of the guild channel\n       * @type {string}\n       */\n      this.name = data.name;\n    }\n    if ('position' in data) {\n      /**\n       * The raw position of the channel from Discord\n       * @type {number}\n       */\n      this.rawPosition = data.position;\n    }\n    if ('guild_id' in data) {\n      this.guildId = data.guild_id;\n    }\n    if ('parent_id' in data) {\n      /**\n       * The id of the category parent of this channel\n       * @type {?Snowflake}\n       */\n      this.parentId = data.parent_id;\n    } else {\n      this.parentId ??= null;\n    }\n    if ('permission_overwrites' in data) {\n      this.permissionOverwrites.cache.clear();\n      for (const overwrite of data.permission_overwrites) {\n        this.permissionOverwrites._add(overwrite);\n      }\n    }\n  }\n  _clone() {\n    const clone = super._clone();\n    clone.permissionOverwrites = new PermissionOverwriteManager(clone, this.permissionOverwrites.cache.values());\n    return clone;\n  }\n\n  /**\n   * The category parent of this channel\n   * @type {?CategoryChannel}\n   * @readonly\n   */\n  get parent() {\n    return this.guild.channels.resolve(this.parentId);\n  }\n\n  /**\n   * If the permissionOverwrites match the parent channel, null if no parent\n   * @type {?boolean}\n   * @readonly\n   */\n  get permissionsLocked() {\n    if (!this.parent) return null;\n\n    // Get all overwrites\n    const overwriteIds = new Set([...this.permissionOverwrites.cache.keys(), ...this.parent.permissionOverwrites.cache.keys()]);\n\n    // Compare all overwrites\n    return [...overwriteIds].every(key => {\n      const channelVal = this.permissionOverwrites.cache.get(key);\n      const parentVal = this.parent.permissionOverwrites.cache.get(key);\n\n      // Handle empty overwrite\n      if (!channelVal && parentVal.deny.bitfield === PermissionsBitField.DefaultBit && parentVal.allow.bitfield === PermissionsBitField.DefaultBit || !parentVal && channelVal.deny.bitfield === PermissionsBitField.DefaultBit && channelVal.allow.bitfield === PermissionsBitField.DefaultBit) {\n        return true;\n      }\n\n      // Compare overwrites\n      return channelVal !== undefined && parentVal !== undefined && channelVal.deny.bitfield === parentVal.deny.bitfield && channelVal.allow.bitfield === parentVal.allow.bitfield;\n    });\n  }\n\n  /**\n   * The position of the channel\n   * @type {number}\n   * @readonly\n   */\n  get position() {\n    const selfIsCategory = this.type === ChannelType.GuildCategory;\n    const types = getSortableGroupTypes(this.type);\n    let count = 0;\n    for (const channel of this.guild.channels.cache.values()) {\n      if (!types.includes(channel.type)) continue;\n      if (!selfIsCategory && channel.parentId !== this.parentId) continue;\n      if (this.rawPosition === channel.rawPosition) {\n        if (Snowflake.compare(channel.id, this.id) === -1) count++;\n      } else if (this.rawPosition > channel.rawPosition) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Gets the overall set of permissions for a member or role in this channel, taking into account channel overwrites.\n   * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for\n   * @param {boolean} [checkAdmin=true] Whether having the {@link PermissionFlagsBits.Administrator} permission\n   * will return all permissions\n   * @returns {?Readonly<PermissionsBitField>}\n   */\n  permissionsFor(memberOrRole, checkAdmin = true) {\n    const member = this.guild.members.resolve(memberOrRole);\n    if (member) return this.memberPermissions(member, checkAdmin);\n    const role = this.guild.roles.resolve(memberOrRole);\n    return role && this.rolePermissions(role, checkAdmin);\n  }\n  overwritesFor(member, verified = false, roles = null) {\n    if (!verified) member = this.guild.members.resolve(member);\n    if (!member) return [];\n    roles ??= member.roles.cache;\n    const roleOverwrites = [];\n    let memberOverwrites;\n    let everyoneOverwrites;\n    for (const overwrite of this.permissionOverwrites.cache.values()) {\n      if (overwrite.id === this.guild.id) {\n        everyoneOverwrites = overwrite;\n      } else if (roles.has(overwrite.id)) {\n        roleOverwrites.push(overwrite);\n      } else if (overwrite.id === member.id) {\n        memberOverwrites = overwrite;\n      }\n    }\n    return {\n      everyone: everyoneOverwrites,\n      roles: roleOverwrites,\n      member: memberOverwrites\n    };\n  }\n\n  /**\n   * Gets the overall set of permissions for a member in this channel, taking into account channel overwrites.\n   * @param {GuildMember} member The member to obtain the overall permissions for\n   * @param {boolean} checkAdmin Whether having the {@link PermissionFlagsBits.Administrator} permission\n   * will return all permissions\n   * @returns {Readonly<PermissionsBitField>}\n   * @private\n   */\n  memberPermissions(member, checkAdmin) {\n    if (checkAdmin && member.id === this.guild.ownerId) {\n      return new PermissionsBitField(PermissionsBitField.All).freeze();\n    }\n    const roles = member.roles.cache;\n    const permissions = new PermissionsBitField(roles.map(role => role.permissions));\n    if (checkAdmin && permissions.has(PermissionFlagsBits.Administrator)) {\n      return new PermissionsBitField(PermissionsBitField.All).freeze();\n    }\n    const overwrites = this.overwritesFor(member, true, roles);\n    return permissions.remove(overwrites.everyone?.deny ?? PermissionsBitField.DefaultBit).add(overwrites.everyone?.allow ?? PermissionsBitField.DefaultBit).remove(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.deny) : PermissionsBitField.DefaultBit).add(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.allow) : PermissionsBitField.DefaultBit).remove(overwrites.member?.deny ?? PermissionsBitField.DefaultBit).add(overwrites.member?.allow ?? PermissionsBitField.DefaultBit).freeze();\n  }\n\n  /**\n   * Gets the overall set of permissions for a role in this channel, taking into account channel overwrites.\n   * @param {Role} role The role to obtain the overall permissions for\n   * @param {boolean} checkAdmin Whether having the {@link PermissionFlagsBits.Administrator} permission\n   * will return all permissions\n   * @returns {Readonly<PermissionsBitField>}\n   * @private\n   */\n  rolePermissions(role, checkAdmin) {\n    if (checkAdmin && role.permissions.has(PermissionFlagsBits.Administrator)) {\n      return new PermissionsBitField(PermissionsBitField.All).freeze();\n    }\n    const everyoneOverwrites = this.permissionOverwrites.cache.get(this.guild.id);\n    const roleOverwrites = this.permissionOverwrites.cache.get(role.id);\n    return role.permissions.remove(everyoneOverwrites?.deny ?? PermissionsBitField.DefaultBit).add(everyoneOverwrites?.allow ?? PermissionsBitField.DefaultBit).remove(roleOverwrites?.deny ?? PermissionsBitField.DefaultBit).add(roleOverwrites?.allow ?? PermissionsBitField.DefaultBit).freeze();\n  }\n\n  /**\n   * Locks in the permission overwrites from the parent channel.\n   * @returns {Promise<GuildChannel>}\n   */\n  lockPermissions() {\n    if (!this.parent) return Promise.reject(new DiscordjsError(ErrorCodes.GuildChannelOrphan));\n    const permissionOverwrites = this.parent.permissionOverwrites.cache.map(overwrite => overwrite.toJSON());\n    return this.edit({\n      permissionOverwrites\n    });\n  }\n\n  /**\n   * A collection of cached members of this channel, mapped by their ids.\n   * Members that can view this channel, if the channel is text-based.\n   * Members in the channel, if the channel is voice-based.\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    return this.guild.members.cache.filter(m => this.permissionsFor(m).has(PermissionFlagsBits.ViewChannel, false));\n  }\n\n  /**\n   * Edits the channel.\n   * @param {GuildChannelEditOptions} options The options to provide\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Edit a channel\n   * channel.edit({ name: 'new-channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  edit(options) {\n    return this.guild.channels.edit(this, options);\n  }\n\n  /**\n   * Sets a new name for the guild channel.\n   * @param {string} name The new name for the guild channel\n   * @param {string} [reason] Reason for changing the guild channel's name\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel name\n   * channel.setName('not_general')\n   *   .then(newChannel => console.log(`Channel's new name is ${newChannel.name}`))\n   *   .catch(console.error);\n   */\n  setName(name, reason) {\n    return this.edit({\n      name,\n      reason\n    });\n  }\n\n  /**\n   * Options used to set the parent of a channel.\n   * @typedef {Object} SetParentOptions\n   * @property {boolean} [lockPermissions=true] Whether to lock the permissions to what the parent's permissions are\n   * @property {string} [reason] The reason for modifying the parent of the channel\n   */\n\n  /**\n   * Sets the parent of this channel.\n   * @param {?CategoryChannelResolvable} channel The category channel to set as the parent\n   * @param {SetParentOptions} [options={}] The options for setting the parent\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Add a parent to a channel\n   * message.channel.setParent('355908108431917066', { lockPermissions: false })\n   *   .then(channel => console.log(`New parent of ${message.channel.name}: ${channel.name}`))\n   *   .catch(console.error);\n   */\n  setParent(channel, {\n    lockPermissions = true,\n    reason\n  } = {}) {\n    return this.edit({\n      parent: channel ?? null,\n      lockPermissions,\n      reason\n    });\n  }\n\n  /**\n   * Options used to set the position of a channel.\n   * @typedef {Object} SetChannelPositionOptions\n   * @property {boolean} [relative=false] Whether or not to change the position relative to its current value\n   * @property {string} [reason] The reason for changing the position\n   */\n\n  /**\n   * Sets a new position for the guild channel.\n   * @param {number} position The new position for the guild channel\n   * @param {SetChannelPositionOptions} [options] Options for setting position\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel position\n   * channel.setPosition(2)\n   *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))\n   *   .catch(console.error);\n   */\n  setPosition(position, options = {}) {\n    return this.guild.channels.setPosition(this, position, options);\n  }\n\n  /**\n   * Options used to clone a guild channel.\n   * @typedef {GuildChannelCreateOptions} GuildChannelCloneOptions\n   * @property {string} [name=this.name] Name of the new channel\n   */\n\n  /**\n   * Clones this channel.\n   * @param {GuildChannelCloneOptions} [options] The options for cloning this channel\n   * @returns {Promise<GuildChannel>}\n   */\n  clone(options = {}) {\n    return this.guild.channels.create({\n      name: options.name ?? this.name,\n      permissionOverwrites: this.permissionOverwrites.cache,\n      topic: this.topic,\n      type: this.type,\n      nsfw: this.nsfw,\n      parent: this.parent,\n      bitrate: this.bitrate,\n      userLimit: this.userLimit,\n      rateLimitPerUser: this.rateLimitPerUser,\n      position: this.rawPosition,\n      reason: null,\n      ...options\n    });\n  }\n\n  /**\n   * Checks if this channel has the same type, topic, position, name, overwrites, and id as another channel.\n   * In most cases, a simple `channel.id === channel2.id` will do, and is much faster too.\n   * @param {GuildChannel} channel Channel to compare with\n   * @returns {boolean}\n   */\n  equals(channel) {\n    let equal = channel && this.id === channel.id && this.type === channel.type && this.topic === channel.topic && this.position === channel.position && this.name === channel.name;\n    if (equal) {\n      if (this.permissionOverwrites && channel.permissionOverwrites) {\n        equal = this.permissionOverwrites.cache.equals(channel.permissionOverwrites.cache);\n      } else {\n        equal = !this.permissionOverwrites && !channel.permissionOverwrites;\n      }\n    }\n    return equal;\n  }\n\n  /**\n   * Whether the channel is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    return this.manageable && this.guild.rulesChannelId !== this.id && this.guild.publicUpdatesChannelId !== this.id;\n  }\n\n  /**\n   * Whether the channel is manageable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get manageable() {\n    if (this.client.user.id === this.guild.ownerId) return true;\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n\n    // This flag allows managing even if timed out\n    if (permissions.has(PermissionFlagsBits.Administrator, false)) return true;\n    if (this.guild.members.me.communicationDisabledUntilTimestamp > Date.now()) return false;\n    const bitfield = VoiceBasedChannelTypes.includes(this.type) ? PermissionFlagsBits.ManageChannels | PermissionFlagsBits.Connect : PermissionFlagsBits.ViewChannel | PermissionFlagsBits.ManageChannels;\n    return permissions.has(bitfield, false);\n  }\n\n  /**\n   * Whether the channel is viewable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get viewable() {\n    if (this.client.user.id === this.guild.ownerId) return true;\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    return permissions.has(PermissionFlagsBits.ViewChannel, false);\n  }\n\n  /**\n   * Deletes this channel.\n   * @param {string} [reason] Reason for deleting this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Delete the channel\n   * channel.delete('making room for new channels')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async delete(reason) {\n    await this.guild.channels.delete(this.id, reason);\n    return this;\n  }\n}\nmodule.exports = GuildChannel;","map":{"version":3,"names":["Snowflake","require","PermissionFlagsBits","ChannelType","BaseChannel","DiscordjsError","ErrorCodes","PermissionOverwriteManager","VoiceBasedChannelTypes","PermissionsBitField","getSortableGroupTypes","GuildChannel","constructor","guild","data","client","immediatePatch","guildId","id","guild_id","permissionOverwrites","_patch","name","rawPosition","position","parentId","parent_id","cache","clear","overwrite","permission_overwrites","_add","_clone","clone","values","parent","channels","resolve","permissionsLocked","overwriteIds","Set","keys","every","key","channelVal","get","parentVal","deny","bitfield","DefaultBit","allow","undefined","selfIsCategory","type","GuildCategory","types","count","channel","includes","compare","permissionsFor","memberOrRole","checkAdmin","member","members","memberPermissions","role","roles","rolePermissions","overwritesFor","verified","roleOverwrites","memberOverwrites","everyoneOverwrites","has","push","everyone","ownerId","All","freeze","permissions","map","Administrator","overwrites","remove","add","length","lockPermissions","Promise","reject","GuildChannelOrphan","toJSON","edit","filter","m","ViewChannel","options","setName","reason","setParent","setPosition","create","topic","nsfw","bitrate","userLimit","rateLimitPerUser","equals","equal","deletable","manageable","rulesChannelId","publicUpdatesChannelId","user","me","communicationDisabledUntilTimestamp","Date","now","ManageChannels","Connect","viewable","delete","module","exports"],"sources":["C:/Users/hetit/node_modules/discord.js/src/structures/GuildChannel.js"],"sourcesContent":["'use strict';\n\nconst { Snowflake } = require('@sapphire/snowflake');\nconst { PermissionFlagsBits, ChannelType } = require('discord-api-types/v10');\nconst { BaseChannel } = require('./BaseChannel');\nconst { DiscordjsError, ErrorCodes } = require('../errors');\nconst PermissionOverwriteManager = require('../managers/PermissionOverwriteManager');\nconst { VoiceBasedChannelTypes } = require('../util/Constants');\nconst PermissionsBitField = require('../util/PermissionsBitField');\nconst { getSortableGroupTypes } = require('../util/Util');\n\n/**\n * Represents a guild channel from any of the following:\n * - {@link TextChannel}\n * - {@link VoiceChannel}\n * - {@link CategoryChannel}\n * - {@link NewsChannel}\n * - {@link StageChannel}\n * - {@link ForumChannel}\n * @extends {BaseChannel}\n * @abstract\n */\nclass GuildChannel extends BaseChannel {\n  constructor(guild, data, client, immediatePatch = true) {\n    super(client, data, false);\n\n    /**\n     * The guild the channel is in\n     * @type {Guild}\n     */\n    this.guild = guild;\n\n    /**\n     * The id of the guild the channel is in\n     * @type {Snowflake}\n     */\n    this.guildId = guild?.id ?? data.guild_id;\n    /**\n     * A manager of permission overwrites that belong to this channel\n     * @type {PermissionOverwriteManager}\n     */\n    this.permissionOverwrites = new PermissionOverwriteManager(this);\n\n    if (data && immediatePatch) this._patch(data);\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if ('name' in data) {\n      /**\n       * The name of the guild channel\n       * @type {string}\n       */\n      this.name = data.name;\n    }\n\n    if ('position' in data) {\n      /**\n       * The raw position of the channel from Discord\n       * @type {number}\n       */\n      this.rawPosition = data.position;\n    }\n\n    if ('guild_id' in data) {\n      this.guildId = data.guild_id;\n    }\n\n    if ('parent_id' in data) {\n      /**\n       * The id of the category parent of this channel\n       * @type {?Snowflake}\n       */\n      this.parentId = data.parent_id;\n    } else {\n      this.parentId ??= null;\n    }\n\n    if ('permission_overwrites' in data) {\n      this.permissionOverwrites.cache.clear();\n      for (const overwrite of data.permission_overwrites) {\n        this.permissionOverwrites._add(overwrite);\n      }\n    }\n  }\n\n  _clone() {\n    const clone = super._clone();\n    clone.permissionOverwrites = new PermissionOverwriteManager(clone, this.permissionOverwrites.cache.values());\n    return clone;\n  }\n\n  /**\n   * The category parent of this channel\n   * @type {?CategoryChannel}\n   * @readonly\n   */\n  get parent() {\n    return this.guild.channels.resolve(this.parentId);\n  }\n\n  /**\n   * If the permissionOverwrites match the parent channel, null if no parent\n   * @type {?boolean}\n   * @readonly\n   */\n  get permissionsLocked() {\n    if (!this.parent) return null;\n\n    // Get all overwrites\n    const overwriteIds = new Set([\n      ...this.permissionOverwrites.cache.keys(),\n      ...this.parent.permissionOverwrites.cache.keys(),\n    ]);\n\n    // Compare all overwrites\n    return [...overwriteIds].every(key => {\n      const channelVal = this.permissionOverwrites.cache.get(key);\n      const parentVal = this.parent.permissionOverwrites.cache.get(key);\n\n      // Handle empty overwrite\n      if (\n        (!channelVal &&\n          parentVal.deny.bitfield === PermissionsBitField.DefaultBit &&\n          parentVal.allow.bitfield === PermissionsBitField.DefaultBit) ||\n        (!parentVal &&\n          channelVal.deny.bitfield === PermissionsBitField.DefaultBit &&\n          channelVal.allow.bitfield === PermissionsBitField.DefaultBit)\n      ) {\n        return true;\n      }\n\n      // Compare overwrites\n      return (\n        channelVal !== undefined &&\n        parentVal !== undefined &&\n        channelVal.deny.bitfield === parentVal.deny.bitfield &&\n        channelVal.allow.bitfield === parentVal.allow.bitfield\n      );\n    });\n  }\n\n  /**\n   * The position of the channel\n   * @type {number}\n   * @readonly\n   */\n  get position() {\n    const selfIsCategory = this.type === ChannelType.GuildCategory;\n    const types = getSortableGroupTypes(this.type);\n\n    let count = 0;\n    for (const channel of this.guild.channels.cache.values()) {\n      if (!types.includes(channel.type)) continue;\n      if (!selfIsCategory && channel.parentId !== this.parentId) continue;\n      if (this.rawPosition === channel.rawPosition) {\n        if (Snowflake.compare(channel.id, this.id) === -1) count++;\n      } else if (this.rawPosition > channel.rawPosition) {\n        count++;\n      }\n    }\n\n    return count;\n  }\n\n  /**\n   * Gets the overall set of permissions for a member or role in this channel, taking into account channel overwrites.\n   * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for\n   * @param {boolean} [checkAdmin=true] Whether having the {@link PermissionFlagsBits.Administrator} permission\n   * will return all permissions\n   * @returns {?Readonly<PermissionsBitField>}\n   */\n  permissionsFor(memberOrRole, checkAdmin = true) {\n    const member = this.guild.members.resolve(memberOrRole);\n    if (member) return this.memberPermissions(member, checkAdmin);\n    const role = this.guild.roles.resolve(memberOrRole);\n    return role && this.rolePermissions(role, checkAdmin);\n  }\n\n  overwritesFor(member, verified = false, roles = null) {\n    if (!verified) member = this.guild.members.resolve(member);\n    if (!member) return [];\n\n    roles ??= member.roles.cache;\n    const roleOverwrites = [];\n    let memberOverwrites;\n    let everyoneOverwrites;\n\n    for (const overwrite of this.permissionOverwrites.cache.values()) {\n      if (overwrite.id === this.guild.id) {\n        everyoneOverwrites = overwrite;\n      } else if (roles.has(overwrite.id)) {\n        roleOverwrites.push(overwrite);\n      } else if (overwrite.id === member.id) {\n        memberOverwrites = overwrite;\n      }\n    }\n\n    return {\n      everyone: everyoneOverwrites,\n      roles: roleOverwrites,\n      member: memberOverwrites,\n    };\n  }\n\n  /**\n   * Gets the overall set of permissions for a member in this channel, taking into account channel overwrites.\n   * @param {GuildMember} member The member to obtain the overall permissions for\n   * @param {boolean} checkAdmin Whether having the {@link PermissionFlagsBits.Administrator} permission\n   * will return all permissions\n   * @returns {Readonly<PermissionsBitField>}\n   * @private\n   */\n  memberPermissions(member, checkAdmin) {\n    if (checkAdmin && member.id === this.guild.ownerId) {\n      return new PermissionsBitField(PermissionsBitField.All).freeze();\n    }\n\n    const roles = member.roles.cache;\n    const permissions = new PermissionsBitField(roles.map(role => role.permissions));\n\n    if (checkAdmin && permissions.has(PermissionFlagsBits.Administrator)) {\n      return new PermissionsBitField(PermissionsBitField.All).freeze();\n    }\n\n    const overwrites = this.overwritesFor(member, true, roles);\n\n    return permissions\n      .remove(overwrites.everyone?.deny ?? PermissionsBitField.DefaultBit)\n      .add(overwrites.everyone?.allow ?? PermissionsBitField.DefaultBit)\n      .remove(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.deny) : PermissionsBitField.DefaultBit)\n      .add(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.allow) : PermissionsBitField.DefaultBit)\n      .remove(overwrites.member?.deny ?? PermissionsBitField.DefaultBit)\n      .add(overwrites.member?.allow ?? PermissionsBitField.DefaultBit)\n      .freeze();\n  }\n\n  /**\n   * Gets the overall set of permissions for a role in this channel, taking into account channel overwrites.\n   * @param {Role} role The role to obtain the overall permissions for\n   * @param {boolean} checkAdmin Whether having the {@link PermissionFlagsBits.Administrator} permission\n   * will return all permissions\n   * @returns {Readonly<PermissionsBitField>}\n   * @private\n   */\n  rolePermissions(role, checkAdmin) {\n    if (checkAdmin && role.permissions.has(PermissionFlagsBits.Administrator)) {\n      return new PermissionsBitField(PermissionsBitField.All).freeze();\n    }\n\n    const everyoneOverwrites = this.permissionOverwrites.cache.get(this.guild.id);\n    const roleOverwrites = this.permissionOverwrites.cache.get(role.id);\n\n    return role.permissions\n      .remove(everyoneOverwrites?.deny ?? PermissionsBitField.DefaultBit)\n      .add(everyoneOverwrites?.allow ?? PermissionsBitField.DefaultBit)\n      .remove(roleOverwrites?.deny ?? PermissionsBitField.DefaultBit)\n      .add(roleOverwrites?.allow ?? PermissionsBitField.DefaultBit)\n      .freeze();\n  }\n\n  /**\n   * Locks in the permission overwrites from the parent channel.\n   * @returns {Promise<GuildChannel>}\n   */\n  lockPermissions() {\n    if (!this.parent) return Promise.reject(new DiscordjsError(ErrorCodes.GuildChannelOrphan));\n    const permissionOverwrites = this.parent.permissionOverwrites.cache.map(overwrite => overwrite.toJSON());\n    return this.edit({ permissionOverwrites });\n  }\n\n  /**\n   * A collection of cached members of this channel, mapped by their ids.\n   * Members that can view this channel, if the channel is text-based.\n   * Members in the channel, if the channel is voice-based.\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    return this.guild.members.cache.filter(m => this.permissionsFor(m).has(PermissionFlagsBits.ViewChannel, false));\n  }\n\n  /**\n   * Edits the channel.\n   * @param {GuildChannelEditOptions} options The options to provide\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Edit a channel\n   * channel.edit({ name: 'new-channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  edit(options) {\n    return this.guild.channels.edit(this, options);\n  }\n\n  /**\n   * Sets a new name for the guild channel.\n   * @param {string} name The new name for the guild channel\n   * @param {string} [reason] Reason for changing the guild channel's name\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel name\n   * channel.setName('not_general')\n   *   .then(newChannel => console.log(`Channel's new name is ${newChannel.name}`))\n   *   .catch(console.error);\n   */\n  setName(name, reason) {\n    return this.edit({ name, reason });\n  }\n\n  /**\n   * Options used to set the parent of a channel.\n   * @typedef {Object} SetParentOptions\n   * @property {boolean} [lockPermissions=true] Whether to lock the permissions to what the parent's permissions are\n   * @property {string} [reason] The reason for modifying the parent of the channel\n   */\n\n  /**\n   * Sets the parent of this channel.\n   * @param {?CategoryChannelResolvable} channel The category channel to set as the parent\n   * @param {SetParentOptions} [options={}] The options for setting the parent\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Add a parent to a channel\n   * message.channel.setParent('355908108431917066', { lockPermissions: false })\n   *   .then(channel => console.log(`New parent of ${message.channel.name}: ${channel.name}`))\n   *   .catch(console.error);\n   */\n  setParent(channel, { lockPermissions = true, reason } = {}) {\n    return this.edit({\n      parent: channel ?? null,\n      lockPermissions,\n      reason,\n    });\n  }\n\n  /**\n   * Options used to set the position of a channel.\n   * @typedef {Object} SetChannelPositionOptions\n   * @property {boolean} [relative=false] Whether or not to change the position relative to its current value\n   * @property {string} [reason] The reason for changing the position\n   */\n\n  /**\n   * Sets a new position for the guild channel.\n   * @param {number} position The new position for the guild channel\n   * @param {SetChannelPositionOptions} [options] Options for setting position\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel position\n   * channel.setPosition(2)\n   *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))\n   *   .catch(console.error);\n   */\n  setPosition(position, options = {}) {\n    return this.guild.channels.setPosition(this, position, options);\n  }\n\n  /**\n   * Options used to clone a guild channel.\n   * @typedef {GuildChannelCreateOptions} GuildChannelCloneOptions\n   * @property {string} [name=this.name] Name of the new channel\n   */\n\n  /**\n   * Clones this channel.\n   * @param {GuildChannelCloneOptions} [options] The options for cloning this channel\n   * @returns {Promise<GuildChannel>}\n   */\n  clone(options = {}) {\n    return this.guild.channels.create({\n      name: options.name ?? this.name,\n      permissionOverwrites: this.permissionOverwrites.cache,\n      topic: this.topic,\n      type: this.type,\n      nsfw: this.nsfw,\n      parent: this.parent,\n      bitrate: this.bitrate,\n      userLimit: this.userLimit,\n      rateLimitPerUser: this.rateLimitPerUser,\n      position: this.rawPosition,\n      reason: null,\n      ...options,\n    });\n  }\n\n  /**\n   * Checks if this channel has the same type, topic, position, name, overwrites, and id as another channel.\n   * In most cases, a simple `channel.id === channel2.id` will do, and is much faster too.\n   * @param {GuildChannel} channel Channel to compare with\n   * @returns {boolean}\n   */\n  equals(channel) {\n    let equal =\n      channel &&\n      this.id === channel.id &&\n      this.type === channel.type &&\n      this.topic === channel.topic &&\n      this.position === channel.position &&\n      this.name === channel.name;\n\n    if (equal) {\n      if (this.permissionOverwrites && channel.permissionOverwrites) {\n        equal = this.permissionOverwrites.cache.equals(channel.permissionOverwrites.cache);\n      } else {\n        equal = !this.permissionOverwrites && !channel.permissionOverwrites;\n      }\n    }\n\n    return equal;\n  }\n\n  /**\n   * Whether the channel is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    return this.manageable && this.guild.rulesChannelId !== this.id && this.guild.publicUpdatesChannelId !== this.id;\n  }\n\n  /**\n   * Whether the channel is manageable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get manageable() {\n    if (this.client.user.id === this.guild.ownerId) return true;\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n\n    // This flag allows managing even if timed out\n    if (permissions.has(PermissionFlagsBits.Administrator, false)) return true;\n    if (this.guild.members.me.communicationDisabledUntilTimestamp > Date.now()) return false;\n\n    const bitfield = VoiceBasedChannelTypes.includes(this.type)\n      ? PermissionFlagsBits.ManageChannels | PermissionFlagsBits.Connect\n      : PermissionFlagsBits.ViewChannel | PermissionFlagsBits.ManageChannels;\n    return permissions.has(bitfield, false);\n  }\n\n  /**\n   * Whether the channel is viewable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get viewable() {\n    if (this.client.user.id === this.guild.ownerId) return true;\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    return permissions.has(PermissionFlagsBits.ViewChannel, false);\n  }\n\n  /**\n   * Deletes this channel.\n   * @param {string} [reason] Reason for deleting this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Delete the channel\n   * channel.delete('making room for new channels')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async delete(reason) {\n    await this.guild.channels.delete(this.id, reason);\n    return this;\n  }\n}\n\nmodule.exports = GuildChannel;\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAM;EAAEA;AAAU,CAAC,GAAGC,OAAO,CAAC,qBAAqB,CAAC;AACpD,MAAM;EAAEC,mBAAmB;EAAEC;AAAY,CAAC,GAAGF,OAAO,CAAC,uBAAuB,CAAC;AAC7E,MAAM;EAAEG;AAAY,CAAC,GAAGH,OAAO,CAAC,eAAe,CAAC;AAChD,MAAM;EAAEI,cAAc;EAAEC;AAAW,CAAC,GAAGL,OAAO,CAAC,WAAW,CAAC;AAC3D,MAAMM,0BAA0B,GAAGN,OAAO,CAAC,wCAAwC,CAAC;AACpF,MAAM;EAAEO;AAAuB,CAAC,GAAGP,OAAO,CAAC,mBAAmB,CAAC;AAC/D,MAAMQ,mBAAmB,GAAGR,OAAO,CAAC,6BAA6B,CAAC;AAClE,MAAM;EAAES;AAAsB,CAAC,GAAGT,OAAO,CAAC,cAAc,CAAC;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMU,YAAY,SAASP,WAAW,CAAC;EACrCQ,WAAWA,CAACC,KAAK,EAAEC,IAAI,EAAEC,MAAM,EAAEC,cAAc,GAAG,IAAI,EAAE;IACtD,KAAK,CAACD,MAAM,EAAED,IAAI,EAAE,KAAK,CAAC;;IAE1B;AACJ;AACA;AACA;IACI,IAAI,CAACD,KAAK,GAAGA,KAAK;;IAElB;AACJ;AACA;AACA;IACI,IAAI,CAACI,OAAO,GAAGJ,KAAK,EAAEK,EAAE,IAAIJ,IAAI,CAACK,QAAQ;IACzC;AACJ;AACA;AACA;IACI,IAAI,CAACC,oBAAoB,GAAG,IAAIb,0BAA0B,CAAC,IAAI,CAAC;IAEhE,IAAIO,IAAI,IAAIE,cAAc,EAAE,IAAI,CAACK,MAAM,CAACP,IAAI,CAAC;EAC/C;EAEAO,MAAMA,CAACP,IAAI,EAAE;IACX,KAAK,CAACO,MAAM,CAACP,IAAI,CAAC;IAElB,IAAI,MAAM,IAAIA,IAAI,EAAE;MAClB;AACN;AACA;AACA;MACM,IAAI,CAACQ,IAAI,GAAGR,IAAI,CAACQ,IAAI;IACvB;IAEA,IAAI,UAAU,IAAIR,IAAI,EAAE;MACtB;AACN;AACA;AACA;MACM,IAAI,CAACS,WAAW,GAAGT,IAAI,CAACU,QAAQ;IAClC;IAEA,IAAI,UAAU,IAAIV,IAAI,EAAE;MACtB,IAAI,CAACG,OAAO,GAAGH,IAAI,CAACK,QAAQ;IAC9B;IAEA,IAAI,WAAW,IAAIL,IAAI,EAAE;MACvB;AACN;AACA;AACA;MACM,IAAI,CAACW,QAAQ,GAAGX,IAAI,CAACY,SAAS;IAChC,CAAC,MAAM;MACL,IAAI,CAACD,QAAQ,KAAK,IAAI;IACxB;IAEA,IAAI,uBAAuB,IAAIX,IAAI,EAAE;MACnC,IAAI,CAACM,oBAAoB,CAACO,KAAK,CAACC,KAAK,CAAC,CAAC;MACvC,KAAK,MAAMC,SAAS,IAAIf,IAAI,CAACgB,qBAAqB,EAAE;QAClD,IAAI,CAACV,oBAAoB,CAACW,IAAI,CAACF,SAAS,CAAC;MAC3C;IACF;EACF;EAEAG,MAAMA,CAAA,EAAG;IACP,MAAMC,KAAK,GAAG,KAAK,CAACD,MAAM,CAAC,CAAC;IAC5BC,KAAK,CAACb,oBAAoB,GAAG,IAAIb,0BAA0B,CAAC0B,KAAK,EAAE,IAAI,CAACb,oBAAoB,CAACO,KAAK,CAACO,MAAM,CAAC,CAAC,CAAC;IAC5G,OAAOD,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIE,MAAMA,CAAA,EAAG;IACX,OAAO,IAAI,CAACtB,KAAK,CAACuB,QAAQ,CAACC,OAAO,CAAC,IAAI,CAACZ,QAAQ,CAAC;EACnD;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIa,iBAAiBA,CAAA,EAAG;IACtB,IAAI,CAAC,IAAI,CAACH,MAAM,EAAE,OAAO,IAAI;;IAE7B;IACA,MAAMI,YAAY,GAAG,IAAIC,GAAG,CAAC,CAC3B,GAAG,IAAI,CAACpB,oBAAoB,CAACO,KAAK,CAACc,IAAI,CAAC,CAAC,EACzC,GAAG,IAAI,CAACN,MAAM,CAACf,oBAAoB,CAACO,KAAK,CAACc,IAAI,CAAC,CAAC,CACjD,CAAC;;IAEF;IACA,OAAO,CAAC,GAAGF,YAAY,CAAC,CAACG,KAAK,CAACC,GAAG,IAAI;MACpC,MAAMC,UAAU,GAAG,IAAI,CAACxB,oBAAoB,CAACO,KAAK,CAACkB,GAAG,CAACF,GAAG,CAAC;MAC3D,MAAMG,SAAS,GAAG,IAAI,CAACX,MAAM,CAACf,oBAAoB,CAACO,KAAK,CAACkB,GAAG,CAACF,GAAG,CAAC;;MAEjE;MACA,IACG,CAACC,UAAU,IACVE,SAAS,CAACC,IAAI,CAACC,QAAQ,KAAKvC,mBAAmB,CAACwC,UAAU,IAC1DH,SAAS,CAACI,KAAK,CAACF,QAAQ,KAAKvC,mBAAmB,CAACwC,UAAU,IAC5D,CAACH,SAAS,IACTF,UAAU,CAACG,IAAI,CAACC,QAAQ,KAAKvC,mBAAmB,CAACwC,UAAU,IAC3DL,UAAU,CAACM,KAAK,CAACF,QAAQ,KAAKvC,mBAAmB,CAACwC,UAAW,EAC/D;QACA,OAAO,IAAI;MACb;;MAEA;MACA,OACEL,UAAU,KAAKO,SAAS,IACxBL,SAAS,KAAKK,SAAS,IACvBP,UAAU,CAACG,IAAI,CAACC,QAAQ,KAAKF,SAAS,CAACC,IAAI,CAACC,QAAQ,IACpDJ,UAAU,CAACM,KAAK,CAACF,QAAQ,KAAKF,SAAS,CAACI,KAAK,CAACF,QAAQ;IAE1D,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIxB,QAAQA,CAAA,EAAG;IACb,MAAM4B,cAAc,GAAG,IAAI,CAACC,IAAI,KAAKlD,WAAW,CAACmD,aAAa;IAC9D,MAAMC,KAAK,GAAG7C,qBAAqB,CAAC,IAAI,CAAC2C,IAAI,CAAC;IAE9C,IAAIG,KAAK,GAAG,CAAC;IACb,KAAK,MAAMC,OAAO,IAAI,IAAI,CAAC5C,KAAK,CAACuB,QAAQ,CAACT,KAAK,CAACO,MAAM,CAAC,CAAC,EAAE;MACxD,IAAI,CAACqB,KAAK,CAACG,QAAQ,CAACD,OAAO,CAACJ,IAAI,CAAC,EAAE;MACnC,IAAI,CAACD,cAAc,IAAIK,OAAO,CAAChC,QAAQ,KAAK,IAAI,CAACA,QAAQ,EAAE;MAC3D,IAAI,IAAI,CAACF,WAAW,KAAKkC,OAAO,CAAClC,WAAW,EAAE;QAC5C,IAAIvB,SAAS,CAAC2D,OAAO,CAACF,OAAO,CAACvC,EAAE,EAAE,IAAI,CAACA,EAAE,CAAC,KAAK,CAAC,CAAC,EAAEsC,KAAK,EAAE;MAC5D,CAAC,MAAM,IAAI,IAAI,CAACjC,WAAW,GAAGkC,OAAO,CAAClC,WAAW,EAAE;QACjDiC,KAAK,EAAE;MACT;IACF;IAEA,OAAOA,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEI,cAAcA,CAACC,YAAY,EAAEC,UAAU,GAAG,IAAI,EAAE;IAC9C,MAAMC,MAAM,GAAG,IAAI,CAAClD,KAAK,CAACmD,OAAO,CAAC3B,OAAO,CAACwB,YAAY,CAAC;IACvD,IAAIE,MAAM,EAAE,OAAO,IAAI,CAACE,iBAAiB,CAACF,MAAM,EAAED,UAAU,CAAC;IAC7D,MAAMI,IAAI,GAAG,IAAI,CAACrD,KAAK,CAACsD,KAAK,CAAC9B,OAAO,CAACwB,YAAY,CAAC;IACnD,OAAOK,IAAI,IAAI,IAAI,CAACE,eAAe,CAACF,IAAI,EAAEJ,UAAU,CAAC;EACvD;EAEAO,aAAaA,CAACN,MAAM,EAAEO,QAAQ,GAAG,KAAK,EAAEH,KAAK,GAAG,IAAI,EAAE;IACpD,IAAI,CAACG,QAAQ,EAAEP,MAAM,GAAG,IAAI,CAAClD,KAAK,CAACmD,OAAO,CAAC3B,OAAO,CAAC0B,MAAM,CAAC;IAC1D,IAAI,CAACA,MAAM,EAAE,OAAO,EAAE;IAEtBI,KAAK,KAAKJ,MAAM,CAACI,KAAK,CAACxC,KAAK;IAC5B,MAAM4C,cAAc,GAAG,EAAE;IACzB,IAAIC,gBAAgB;IACpB,IAAIC,kBAAkB;IAEtB,KAAK,MAAM5C,SAAS,IAAI,IAAI,CAACT,oBAAoB,CAACO,KAAK,CAACO,MAAM,CAAC,CAAC,EAAE;MAChE,IAAIL,SAAS,CAACX,EAAE,KAAK,IAAI,CAACL,KAAK,CAACK,EAAE,EAAE;QAClCuD,kBAAkB,GAAG5C,SAAS;MAChC,CAAC,MAAM,IAAIsC,KAAK,CAACO,GAAG,CAAC7C,SAAS,CAACX,EAAE,CAAC,EAAE;QAClCqD,cAAc,CAACI,IAAI,CAAC9C,SAAS,CAAC;MAChC,CAAC,MAAM,IAAIA,SAAS,CAACX,EAAE,KAAK6C,MAAM,CAAC7C,EAAE,EAAE;QACrCsD,gBAAgB,GAAG3C,SAAS;MAC9B;IACF;IAEA,OAAO;MACL+C,QAAQ,EAAEH,kBAAkB;MAC5BN,KAAK,EAAEI,cAAc;MACrBR,MAAM,EAAES;IACV,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEP,iBAAiBA,CAACF,MAAM,EAAED,UAAU,EAAE;IACpC,IAAIA,UAAU,IAAIC,MAAM,CAAC7C,EAAE,KAAK,IAAI,CAACL,KAAK,CAACgE,OAAO,EAAE;MAClD,OAAO,IAAIpE,mBAAmB,CAACA,mBAAmB,CAACqE,GAAG,CAAC,CAACC,MAAM,CAAC,CAAC;IAClE;IAEA,MAAMZ,KAAK,GAAGJ,MAAM,CAACI,KAAK,CAACxC,KAAK;IAChC,MAAMqD,WAAW,GAAG,IAAIvE,mBAAmB,CAAC0D,KAAK,CAACc,GAAG,CAACf,IAAI,IAAIA,IAAI,CAACc,WAAW,CAAC,CAAC;IAEhF,IAAIlB,UAAU,IAAIkB,WAAW,CAACN,GAAG,CAACxE,mBAAmB,CAACgF,aAAa,CAAC,EAAE;MACpE,OAAO,IAAIzE,mBAAmB,CAACA,mBAAmB,CAACqE,GAAG,CAAC,CAACC,MAAM,CAAC,CAAC;IAClE;IAEA,MAAMI,UAAU,GAAG,IAAI,CAACd,aAAa,CAACN,MAAM,EAAE,IAAI,EAAEI,KAAK,CAAC;IAE1D,OAAOa,WAAW,CACfI,MAAM,CAACD,UAAU,CAACP,QAAQ,EAAE7B,IAAI,IAAItC,mBAAmB,CAACwC,UAAU,CAAC,CACnEoC,GAAG,CAACF,UAAU,CAACP,QAAQ,EAAE1B,KAAK,IAAIzC,mBAAmB,CAACwC,UAAU,CAAC,CACjEmC,MAAM,CAACD,UAAU,CAAChB,KAAK,CAACmB,MAAM,GAAG,CAAC,GAAGH,UAAU,CAAChB,KAAK,CAACc,GAAG,CAACf,IAAI,IAAIA,IAAI,CAACnB,IAAI,CAAC,GAAGtC,mBAAmB,CAACwC,UAAU,CAAC,CAC9GoC,GAAG,CAACF,UAAU,CAAChB,KAAK,CAACmB,MAAM,GAAG,CAAC,GAAGH,UAAU,CAAChB,KAAK,CAACc,GAAG,CAACf,IAAI,IAAIA,IAAI,CAAChB,KAAK,CAAC,GAAGzC,mBAAmB,CAACwC,UAAU,CAAC,CAC5GmC,MAAM,CAACD,UAAU,CAACpB,MAAM,EAAEhB,IAAI,IAAItC,mBAAmB,CAACwC,UAAU,CAAC,CACjEoC,GAAG,CAACF,UAAU,CAACpB,MAAM,EAAEb,KAAK,IAAIzC,mBAAmB,CAACwC,UAAU,CAAC,CAC/D8B,MAAM,CAAC,CAAC;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEX,eAAeA,CAACF,IAAI,EAAEJ,UAAU,EAAE;IAChC,IAAIA,UAAU,IAAII,IAAI,CAACc,WAAW,CAACN,GAAG,CAACxE,mBAAmB,CAACgF,aAAa,CAAC,EAAE;MACzE,OAAO,IAAIzE,mBAAmB,CAACA,mBAAmB,CAACqE,GAAG,CAAC,CAACC,MAAM,CAAC,CAAC;IAClE;IAEA,MAAMN,kBAAkB,GAAG,IAAI,CAACrD,oBAAoB,CAACO,KAAK,CAACkB,GAAG,CAAC,IAAI,CAAChC,KAAK,CAACK,EAAE,CAAC;IAC7E,MAAMqD,cAAc,GAAG,IAAI,CAACnD,oBAAoB,CAACO,KAAK,CAACkB,GAAG,CAACqB,IAAI,CAAChD,EAAE,CAAC;IAEnE,OAAOgD,IAAI,CAACc,WAAW,CACpBI,MAAM,CAACX,kBAAkB,EAAE1B,IAAI,IAAItC,mBAAmB,CAACwC,UAAU,CAAC,CAClEoC,GAAG,CAACZ,kBAAkB,EAAEvB,KAAK,IAAIzC,mBAAmB,CAACwC,UAAU,CAAC,CAChEmC,MAAM,CAACb,cAAc,EAAExB,IAAI,IAAItC,mBAAmB,CAACwC,UAAU,CAAC,CAC9DoC,GAAG,CAACd,cAAc,EAAErB,KAAK,IAAIzC,mBAAmB,CAACwC,UAAU,CAAC,CAC5D8B,MAAM,CAAC,CAAC;EACb;;EAEA;AACF;AACA;AACA;EACEQ,eAAeA,CAAA,EAAG;IAChB,IAAI,CAAC,IAAI,CAACpD,MAAM,EAAE,OAAOqD,OAAO,CAACC,MAAM,CAAC,IAAIpF,cAAc,CAACC,UAAU,CAACoF,kBAAkB,CAAC,CAAC;IAC1F,MAAMtE,oBAAoB,GAAG,IAAI,CAACe,MAAM,CAACf,oBAAoB,CAACO,KAAK,CAACsD,GAAG,CAACpD,SAAS,IAAIA,SAAS,CAAC8D,MAAM,CAAC,CAAC,CAAC;IACxG,OAAO,IAAI,CAACC,IAAI,CAAC;MAAExE;IAAqB,CAAC,CAAC;EAC5C;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI4C,OAAOA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACnD,KAAK,CAACmD,OAAO,CAACrC,KAAK,CAACkE,MAAM,CAACC,CAAC,IAAI,IAAI,CAAClC,cAAc,CAACkC,CAAC,CAAC,CAACpB,GAAG,CAACxE,mBAAmB,CAAC6F,WAAW,EAAE,KAAK,CAAC,CAAC;EACjH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEH,IAAIA,CAACI,OAAO,EAAE;IACZ,OAAO,IAAI,CAACnF,KAAK,CAACuB,QAAQ,CAACwD,IAAI,CAAC,IAAI,EAAEI,OAAO,CAAC;EAChD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,OAAOA,CAAC3E,IAAI,EAAE4E,MAAM,EAAE;IACpB,OAAO,IAAI,CAACN,IAAI,CAAC;MAAEtE,IAAI;MAAE4E;IAAO,CAAC,CAAC;EACpC;;EAEA;AACF;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,SAASA,CAAC1C,OAAO,EAAE;IAAE8B,eAAe,GAAG,IAAI;IAAEW;EAAO,CAAC,GAAG,CAAC,CAAC,EAAE;IAC1D,OAAO,IAAI,CAACN,IAAI,CAAC;MACfzD,MAAM,EAAEsB,OAAO,IAAI,IAAI;MACvB8B,eAAe;MACfW;IACF,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEE,WAAWA,CAAC5E,QAAQ,EAAEwE,OAAO,GAAG,CAAC,CAAC,EAAE;IAClC,OAAO,IAAI,CAACnF,KAAK,CAACuB,QAAQ,CAACgE,WAAW,CAAC,IAAI,EAAE5E,QAAQ,EAAEwE,OAAO,CAAC;EACjE;;EAEA;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;EACE/D,KAAKA,CAAC+D,OAAO,GAAG,CAAC,CAAC,EAAE;IAClB,OAAO,IAAI,CAACnF,KAAK,CAACuB,QAAQ,CAACiE,MAAM,CAAC;MAChC/E,IAAI,EAAE0E,OAAO,CAAC1E,IAAI,IAAI,IAAI,CAACA,IAAI;MAC/BF,oBAAoB,EAAE,IAAI,CAACA,oBAAoB,CAACO,KAAK;MACrD2E,KAAK,EAAE,IAAI,CAACA,KAAK;MACjBjD,IAAI,EAAE,IAAI,CAACA,IAAI;MACfkD,IAAI,EAAE,IAAI,CAACA,IAAI;MACfpE,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBqE,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBC,SAAS,EAAE,IAAI,CAACA,SAAS;MACzBC,gBAAgB,EAAE,IAAI,CAACA,gBAAgB;MACvClF,QAAQ,EAAE,IAAI,CAACD,WAAW;MAC1B2E,MAAM,EAAE,IAAI;MACZ,GAAGF;IACL,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEW,MAAMA,CAAClD,OAAO,EAAE;IACd,IAAImD,KAAK,GACPnD,OAAO,IACP,IAAI,CAACvC,EAAE,KAAKuC,OAAO,CAACvC,EAAE,IACtB,IAAI,CAACmC,IAAI,KAAKI,OAAO,CAACJ,IAAI,IAC1B,IAAI,CAACiD,KAAK,KAAK7C,OAAO,CAAC6C,KAAK,IAC5B,IAAI,CAAC9E,QAAQ,KAAKiC,OAAO,CAACjC,QAAQ,IAClC,IAAI,CAACF,IAAI,KAAKmC,OAAO,CAACnC,IAAI;IAE5B,IAAIsF,KAAK,EAAE;MACT,IAAI,IAAI,CAACxF,oBAAoB,IAAIqC,OAAO,CAACrC,oBAAoB,EAAE;QAC7DwF,KAAK,GAAG,IAAI,CAACxF,oBAAoB,CAACO,KAAK,CAACgF,MAAM,CAAClD,OAAO,CAACrC,oBAAoB,CAACO,KAAK,CAAC;MACpF,CAAC,MAAM;QACLiF,KAAK,GAAG,CAAC,IAAI,CAACxF,oBAAoB,IAAI,CAACqC,OAAO,CAACrC,oBAAoB;MACrE;IACF;IAEA,OAAOwF,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIC,SAASA,CAAA,EAAG;IACd,OAAO,IAAI,CAACC,UAAU,IAAI,IAAI,CAACjG,KAAK,CAACkG,cAAc,KAAK,IAAI,CAAC7F,EAAE,IAAI,IAAI,CAACL,KAAK,CAACmG,sBAAsB,KAAK,IAAI,CAAC9F,EAAE;EAClH;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAI4F,UAAUA,CAAA,EAAG;IACf,IAAI,IAAI,CAAC/F,MAAM,CAACkG,IAAI,CAAC/F,EAAE,KAAK,IAAI,CAACL,KAAK,CAACgE,OAAO,EAAE,OAAO,IAAI;IAC3D,MAAMG,WAAW,GAAG,IAAI,CAACpB,cAAc,CAAC,IAAI,CAAC7C,MAAM,CAACkG,IAAI,CAAC;IACzD,IAAI,CAACjC,WAAW,EAAE,OAAO,KAAK;;IAE9B;IACA,IAAIA,WAAW,CAACN,GAAG,CAACxE,mBAAmB,CAACgF,aAAa,EAAE,KAAK,CAAC,EAAE,OAAO,IAAI;IAC1E,IAAI,IAAI,CAACrE,KAAK,CAACmD,OAAO,CAACkD,EAAE,CAACC,mCAAmC,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,OAAO,KAAK;IAExF,MAAMrE,QAAQ,GAAGxC,sBAAsB,CAACkD,QAAQ,CAAC,IAAI,CAACL,IAAI,CAAC,GACvDnD,mBAAmB,CAACoH,cAAc,GAAGpH,mBAAmB,CAACqH,OAAO,GAChErH,mBAAmB,CAAC6F,WAAW,GAAG7F,mBAAmB,CAACoH,cAAc;IACxE,OAAOtC,WAAW,CAACN,GAAG,CAAC1B,QAAQ,EAAE,KAAK,CAAC;EACzC;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIwE,QAAQA,CAAA,EAAG;IACb,IAAI,IAAI,CAACzG,MAAM,CAACkG,IAAI,CAAC/F,EAAE,KAAK,IAAI,CAACL,KAAK,CAACgE,OAAO,EAAE,OAAO,IAAI;IAC3D,MAAMG,WAAW,GAAG,IAAI,CAACpB,cAAc,CAAC,IAAI,CAAC7C,MAAM,CAACkG,IAAI,CAAC;IACzD,IAAI,CAACjC,WAAW,EAAE,OAAO,KAAK;IAC9B,OAAOA,WAAW,CAACN,GAAG,CAACxE,mBAAmB,CAAC6F,WAAW,EAAE,KAAK,CAAC;EAChE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAM0B,MAAMA,CAACvB,MAAM,EAAE;IACnB,MAAM,IAAI,CAACrF,KAAK,CAACuB,QAAQ,CAACqF,MAAM,CAAC,IAAI,CAACvG,EAAE,EAAEgF,MAAM,CAAC;IACjD,OAAO,IAAI;EACb;AACF;AAEAwB,MAAM,CAACC,OAAO,GAAGhH,YAAY","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}