{"ast":null,"code":"'use strict';\n\nconst process = require('node:process');\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  ChannelType,\n  Routes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst GuildTextThreadManager = require('./GuildTextThreadManager');\nconst {\n  DiscordjsError,\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../errors');\nconst GuildChannel = require('../structures/GuildChannel');\nconst PermissionOverwrites = require('../structures/PermissionOverwrites');\nconst ThreadChannel = require('../structures/ThreadChannel');\nconst Webhook = require('../structures/Webhook');\nconst ChannelFlagsBitField = require('../util/ChannelFlagsBitField');\nconst {\n  transformGuildForumTag,\n  transformGuildDefaultReaction\n} = require('../util/Channels');\nconst {\n  ThreadChannelTypes\n} = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst {\n  setPosition\n} = require('../util/Util');\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for GuildChannels and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildChannelManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, GuildChannel, iterable);\n    const defaultCaching = this._cache.constructor.name === 'Collection' || this._cache.maxSize === undefined || this._cache.maxSize === Infinity;\n    if (!cacheWarningEmitted && !defaultCaching) {\n      cacheWarningEmitted = true;\n      process.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, 'UnsupportedCacheOverwriteWarning');\n    }\n\n    /**\n     * The guild this Manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The number of channels in this managers cache excluding thread channels\n   * that do not count towards a guild's maximum channels restriction.\n   * @type {number}\n   * @readonly\n   */\n  get channelCountWithoutThreads() {\n    return this.cache.reduce((acc, channel) => {\n      if (ThreadChannelTypes.includes(channel.type)) return acc;\n      return ++acc;\n    }, 0);\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, GuildChannel|ThreadChannel>}\n   * @name GuildChannelManager#cache\n   */\n\n  _add(channel) {\n    const existing = this.cache.get(channel.id);\n    if (existing) return existing;\n    this.cache.set(channel.id, channel);\n    return channel;\n  }\n\n  /**\n   * Data that can be resolved to give a Guild Channel object. This can be:\n   * * A GuildChannel object\n   * * A ThreadChannel object\n   * * A Snowflake\n   * @typedef {GuildChannel|ThreadChannel|Snowflake} GuildChannelResolvable\n   */\n\n  /**\n   * Resolves a GuildChannelResolvable to a Channel object.\n   * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve\n   * @returns {?(GuildChannel|ThreadChannel)}\n   */\n  resolve(channel) {\n    if (channel instanceof ThreadChannel) return super.resolve(channel.id);\n    return super.resolve(channel);\n  }\n\n  /**\n   * Resolves a GuildChannelResolvable to a channel id.\n   * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n  resolveId(channel) {\n    if (channel instanceof ThreadChannel) return super.resolveId(channel.id);\n    return super.resolveId(channel);\n  }\n\n  /**\n   * Adds the target channel to a channel's followers.\n   * @param {NewsChannel|Snowflake} channel The channel to follow\n   * @param {TextChannelResolvable} targetChannel The channel where published announcements will be posted at\n   * @param {string} [reason] Reason for creating the webhook\n   * @returns {Promise<Snowflake>} Returns created target webhook id.\n   */\n  async addFollower(channel, targetChannel, reason) {\n    const channelId = this.resolveId(channel);\n    const targetChannelId = this.resolveId(targetChannel);\n    if (!channelId || !targetChannelId) throw new Error(ErrorCodes.GuildChannelResolve);\n    const {\n      webhook_id\n    } = await this.client.rest.post(Routes.channelFollowers(channelId), {\n      body: {\n        webhook_channel_id: targetChannelId\n      },\n      reason\n    });\n    return webhook_id;\n  }\n\n  /**\n   * Options used to create a new channel in a guild.\n   * @typedef {CategoryCreateChannelOptions} GuildChannelCreateOptions\n   * @property {?CategoryChannelResolvable} [parent] Parent of the new channel\n   */\n\n  /**\n   * Creates a new channel in the guild.\n   * @param {GuildChannelCreateOptions} options Options for creating the new channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Create a new text channel\n   * guild.channels.create({ name: 'new-general', reason: 'Needed a cool new channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Create a new channel with permission overwrites\n   * guild.channels.create({\n   *   name: 'new-general',\n   *   type: ChannelType.GuildVoice,\n   *   permissionOverwrites: [\n   *      {\n   *        id: message.author.id,\n   *        deny: [PermissionFlagsBits.ViewChannel],\n   *     },\n   *   ],\n   * })\n   */\n  async create({\n    name,\n    type,\n    topic,\n    nsfw,\n    bitrate,\n    userLimit,\n    parent,\n    permissionOverwrites,\n    position,\n    rateLimitPerUser,\n    rtcRegion,\n    videoQualityMode,\n    availableTags,\n    defaultReactionEmoji,\n    defaultAutoArchiveDuration,\n    defaultSortOrder,\n    defaultForumLayout,\n    reason\n  }) {\n    parent &&= this.client.channels.resolveId(parent);\n    permissionOverwrites &&= permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n    const data = await this.client.rest.post(Routes.guildChannels(this.guild.id), {\n      body: {\n        name,\n        topic,\n        type,\n        nsfw,\n        bitrate,\n        user_limit: userLimit,\n        parent_id: parent,\n        position,\n        permission_overwrites: permissionOverwrites,\n        rate_limit_per_user: rateLimitPerUser,\n        rtc_region: rtcRegion,\n        video_quality_mode: videoQualityMode,\n        available_tags: availableTags?.map(availableTag => transformGuildForumTag(availableTag)),\n        default_reaction_emoji: defaultReactionEmoji && transformGuildDefaultReaction(defaultReactionEmoji),\n        default_auto_archive_duration: defaultAutoArchiveDuration,\n        default_sort_order: defaultSortOrder,\n        default_forum_layout: defaultForumLayout\n      },\n      reason\n    });\n    return this.client.actions.ChannelCreate.handle(data).channel;\n  }\n\n  /**\n   * @typedef {ChannelWebhookCreateOptions} WebhookCreateOptions\n   * @property {TextChannel|NewsChannel|VoiceChannel|StageChannel|ForumChannel|Snowflake} channel\n   * The channel to create the webhook for\n   */\n\n  /**\n   * Creates a webhook for the channel.\n   * @param {WebhookCreateOptions} options Options for creating the webhook\n   * @returns {Promise<Webhook>} Returns the created Webhook\n   * @example\n   * // Create a webhook for the current channel\n   * guild.channels.createWebhook({\n   *   channel: '222197033908436994',\n   *   name: 'Snek',\n   *   avatar: 'https://i.imgur.com/mI8XcpG.jpg',\n   *   reason: 'Needed a cool new Webhook'\n   * })\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  async createWebhook({\n    channel,\n    name,\n    avatar,\n    reason\n  }) {\n    const id = this.resolveId(channel);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    if (typeof avatar === 'string' && !avatar.startsWith('data:')) {\n      avatar = await DataResolver.resolveImage(avatar);\n    }\n    const data = await this.client.rest.post(Routes.channelWebhooks(id), {\n      body: {\n        name,\n        avatar\n      },\n      reason\n    });\n    return new Webhook(this.client, data);\n  }\n\n  /**\n   * Options used to edit a guild channel.\n   * @typedef {Object} GuildChannelEditOptions\n   * @property {string} [name] The name of the channel\n   * @property {ChannelType} [type] The type of the channel (only conversion between text and news is supported)\n   * @property {number} [position] The position of the channel\n   * @property {?string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the voice channel\n   * @property {?CategoryChannelResolvable} [parent] The parent of the channel\n   * @property {boolean} [lockPermissions]\n   * Lock the permissions of the channel to what the parent's permissions are\n   * @property {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [permissionOverwrites]\n   * Permission overwrites for the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the channel in seconds\n   * @property {ThreadAutoArchiveDuration} [defaultAutoArchiveDuration]\n   * The default auto archive duration for all new threads in this channel\n   * @property {?string} [rtcRegion] The RTC region of the channel\n   * @property {?VideoQualityMode} [videoQualityMode] The camera video quality mode of the channel\n   * @property {GuildForumTagData[]} [availableTags] The tags to set as available in a forum channel\n   * @property {?DefaultReactionEmoji} [defaultReactionEmoji] The emoji to set as the default reaction emoji\n   * @property {number} [defaultThreadRateLimitPerUser] The rate limit per user (slowmode) to set on forum posts\n   * @property {ChannelFlagsResolvable} [flags] The flags to set on the channel\n   * @property {?SortOrderType} [defaultSortOrder] The default sort order mode to set on the channel\n   * @property {ForumLayoutType} [defaultForumLayout] The default forum layout to set on the channel\n   * @property {string} [reason] Reason for editing this channel\n   */\n\n  /**\n   * Edits the channel.\n   * @param {GuildChannelResolvable} channel The channel to edit\n   * @param {GuildChannelEditOptions} options Options for editing the channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Edit a channel\n   * guild.channels.edit('222197033908436994', { name: 'new-channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async edit(channel, options) {\n    channel = this.resolve(channel);\n    if (!channel) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    const parent = options.parent && this.client.channels.resolveId(options.parent);\n    if (options.position !== undefined) {\n      await this.setPosition(channel, options.position, {\n        position: options.position,\n        reason: options.reason\n      });\n    }\n    let permission_overwrites = options.permissionOverwrites?.map(o => PermissionOverwrites.resolve(o, this.guild));\n    if (options.lockPermissions) {\n      if (parent) {\n        const newParent = this.guild.channels.resolve(parent);\n        if (newParent?.type === ChannelType.GuildCategory) {\n          permission_overwrites = newParent.permissionOverwrites.cache.map(o => PermissionOverwrites.resolve(o, this.guild));\n        }\n      } else if (channel.parent) {\n        permission_overwrites = channel.parent.permissionOverwrites.cache.map(o => PermissionOverwrites.resolve(o, this.guild));\n      }\n    }\n    const newData = await this.client.rest.patch(Routes.channel(channel.id), {\n      body: {\n        name: (options.name ?? channel.name).trim(),\n        type: options.type,\n        topic: options.topic,\n        nsfw: options.nsfw,\n        bitrate: options.bitrate ?? channel.bitrate,\n        user_limit: options.userLimit ?? channel.userLimit,\n        rtc_region: 'rtcRegion' in options ? options.rtcRegion : channel.rtcRegion,\n        video_quality_mode: options.videoQualityMode,\n        parent_id: parent,\n        lock_permissions: options.lockPermissions,\n        rate_limit_per_user: options.rateLimitPerUser,\n        default_auto_archive_duration: options.defaultAutoArchiveDuration,\n        permission_overwrites,\n        available_tags: options.availableTags?.map(availableTag => transformGuildForumTag(availableTag)),\n        default_reaction_emoji: options.defaultReactionEmoji && transformGuildDefaultReaction(options.defaultReactionEmoji),\n        default_thread_rate_limit_per_user: options.defaultThreadRateLimitPerUser,\n        flags: 'flags' in options ? ChannelFlagsBitField.resolve(options.flags) : undefined,\n        default_sort_order: options.defaultSortOrder,\n        default_forum_layout: options.defaultForumLayout\n      },\n      reason: options.reason\n    });\n    return this.client.actions.ChannelUpdate.handle(newData).updated;\n  }\n\n  /**\n   * Sets a new position for the guild channel.\n   * @param {GuildChannelResolvable} channel The channel to set the position for\n   * @param {number} position The new position for the guild channel\n   * @param {SetChannelPositionOptions} options Options for setting position\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel position\n   * guild.channels.setPosition('222078374472843266', 2)\n   *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))\n   *   .catch(console.error);\n   */\n  async setPosition(channel, position, {\n    relative,\n    reason\n  } = {}) {\n    channel = this.resolve(channel);\n    if (!channel) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    const updatedChannels = await setPosition(channel, position, relative, this.guild._sortedChannels(channel), this.client, Routes.guildChannels(this.guild.id), reason);\n    this.client.actions.GuildChannelsPositionUpdate.handle({\n      guild_id: this.guild.id,\n      channels: updatedChannels\n    });\n    return channel;\n  }\n\n  /**\n   * Obtains one or more guild channels from Discord, or the channel cache if they're already available.\n   * @param {Snowflake} [id] The channel's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<?GuildChannel|ThreadChannel|Collection<Snowflake, ?GuildChannel>>}\n   * @example\n   * // Fetch all channels from the guild (excluding threads)\n   * message.guild.channels.fetch()\n   *   .then(channels => console.log(`There are ${channels.size} channels.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single channel\n   * message.guild.channels.fetch('222197033908436994')\n   *   .then(channel => console.log(`The channel name is: ${channel.name}`))\n   *   .catch(console.error);\n   */\n  async fetch(id, {\n    cache = true,\n    force = false\n  } = {}) {\n    if (id && !force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    }\n    if (id) {\n      const data = await this.client.rest.get(Routes.channel(id));\n      // Since this is the guild manager, throw if on a different guild\n      if (this.guild.id !== data.guild_id) throw new DiscordjsError(ErrorCodes.GuildChannelUnowned);\n      return this.client.channels._add(data, this.guild, {\n        cache\n      });\n    }\n    const data = await this.client.rest.get(Routes.guildChannels(this.guild.id));\n    const channels = new Collection();\n    for (const channel of data) channels.set(channel.id, this.client.channels._add(channel, this.guild, {\n      cache\n    }));\n    return channels;\n  }\n\n  /**\n   * Fetches all webhooks for the channel.\n   * @param {GuildChannelResolvable} channel The channel to fetch webhooks for\n   * @returns {Promise<Collection<Snowflake, Webhook>>}\n   * @example\n   * // Fetch webhooks\n   * guild.channels.fetchWebhooks('769862166131245066')\n   *   .then(hooks => console.log(`This channel has ${hooks.size} hooks`))\n   *   .catch(console.error);\n   */\n  async fetchWebhooks(channel) {\n    const id = this.resolveId(channel);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    const data = await this.client.rest.get(Routes.channelWebhooks(id));\n    return data.reduce((hooks, hook) => hooks.set(hook.id, new Webhook(this.client, hook)), new Collection());\n  }\n\n  /**\n   * Data that can be resolved to give a Category Channel object. This can be:\n   * * A CategoryChannel object\n   * * A Snowflake\n   * @typedef {CategoryChannel|Snowflake} CategoryChannelResolvable\n   */\n\n  /**\n   * The data needed for updating a channel's position.\n   * @typedef {Object} ChannelPosition\n   * @property {GuildChannel|Snowflake} channel Channel to update\n   * @property {number} [position] New position for the channel\n   * @property {CategoryChannelResolvable} [parent] Parent channel for this channel\n   * @property {boolean} [lockPermissions] If the overwrites should be locked to the parents overwrites\n   */\n\n  /**\n   * Batch-updates the guild's channels' positions.\n   * <info>Only one channel's parent can be changed at a time</info>\n   * @param {ChannelPosition[]} channelPositions Channel positions to update\n   * @returns {Promise<Guild>}\n   * @example\n   * guild.channels.setPositions([{ channel: channelId, position: newChannelIndex }])\n   *   .then(guild => console.log(`Updated channel positions for ${guild}`))\n   *   .catch(console.error);\n   */\n  async setPositions(channelPositions) {\n    channelPositions = channelPositions.map(r => ({\n      id: this.client.channels.resolveId(r.channel),\n      position: r.position,\n      lock_permissions: r.lockPermissions,\n      parent_id: r.parent !== undefined ? this.resolveId(r.parent) : undefined\n    }));\n    await this.client.rest.patch(Routes.guildChannels(this.guild.id), {\n      body: channelPositions\n    });\n    return this.client.actions.GuildChannelsPositionUpdate.handle({\n      guild_id: this.guild.id,\n      channels: channelPositions\n    }).guild;\n  }\n\n  /**\n   * Data returned from fetching threads.\n   * @typedef {Object} FetchedThreads\n   * @property {Collection<Snowflake, ThreadChannel>} threads The threads that were fetched\n   * @property {Collection<Snowflake, ThreadMember>} members The thread members in the received threads\n   */\n\n  /**\n   * Obtains all active thread channels in the guild.\n   * @param {boolean} [cache=true] Whether to cache the fetched data\n   * @returns {Promise<FetchedThreads>}\n   * @example\n   * // Fetch all threads from the guild\n   * message.guild.channels.fetchActiveThreads()\n   *   .then(fetched => console.log(`There are ${fetched.threads.size} threads.`))\n   *   .catch(console.error);\n   */\n  async fetchActiveThreads(cache = true) {\n    const data = await this.rawFetchGuildActiveThreads();\n    return GuildTextThreadManager._mapThreads(data, this.client, {\n      guild: this.guild,\n      cache\n    });\n  }\n\n  /**\n   * `GET /guilds/{guild.id}/threads/active`\n   * @private\n   * @returns {Promise<RESTGetAPIGuildThreadsResult>}\n   */\n  rawFetchGuildActiveThreads() {\n    return this.client.rest.get(Routes.guildActiveThreads(this.guild.id));\n  }\n\n  /**\n   * Deletes the channel.\n   * @param {GuildChannelResolvable} channel The channel to delete\n   * @param {string} [reason] Reason for deleting this channel\n   * @returns {Promise<void>}\n   * @example\n   * // Delete the channel\n   * guild.channels.delete('858850993013260338', 'making room for new channels')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async delete(channel, reason) {\n    const id = this.resolveId(channel);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    await this.client.rest.delete(Routes.channel(id), {\n      reason\n    });\n    this.client.actions.ChannelDelete.handle({\n      id\n    });\n  }\n}\nmodule.exports = GuildChannelManager;","map":{"version":3,"names":["process","require","Collection","ChannelType","Routes","CachedManager","GuildTextThreadManager","DiscordjsError","DiscordjsTypeError","ErrorCodes","GuildChannel","PermissionOverwrites","ThreadChannel","Webhook","ChannelFlagsBitField","transformGuildForumTag","transformGuildDefaultReaction","ThreadChannelTypes","DataResolver","setPosition","cacheWarningEmitted","GuildChannelManager","constructor","guild","iterable","client","defaultCaching","_cache","name","maxSize","undefined","Infinity","emitWarning","channelCountWithoutThreads","cache","reduce","acc","channel","includes","type","_add","existing","get","id","set","resolve","resolveId","addFollower","targetChannel","reason","channelId","targetChannelId","Error","GuildChannelResolve","webhook_id","rest","post","channelFollowers","body","webhook_channel_id","create","topic","nsfw","bitrate","userLimit","parent","permissionOverwrites","position","rateLimitPerUser","rtcRegion","videoQualityMode","availableTags","defaultReactionEmoji","defaultAutoArchiveDuration","defaultSortOrder","defaultForumLayout","channels","map","o","data","guildChannels","user_limit","parent_id","permission_overwrites","rate_limit_per_user","rtc_region","video_quality_mode","available_tags","availableTag","default_reaction_emoji","default_auto_archive_duration","default_sort_order","default_forum_layout","actions","ChannelCreate","handle","createWebhook","avatar","InvalidType","startsWith","resolveImage","channelWebhooks","edit","options","lockPermissions","newParent","GuildCategory","newData","patch","trim","lock_permissions","default_thread_rate_limit_per_user","defaultThreadRateLimitPerUser","flags","ChannelUpdate","updated","relative","updatedChannels","_sortedChannels","GuildChannelsPositionUpdate","guild_id","fetch","force","GuildChannelUnowned","fetchWebhooks","hooks","hook","setPositions","channelPositions","r","fetchActiveThreads","rawFetchGuildActiveThreads","_mapThreads","guildActiveThreads","delete","ChannelDelete","module","exports"],"sources":["C:/Users/hetit/node_modules/discord.js/src/managers/GuildChannelManager.js"],"sourcesContent":["'use strict';\n\nconst process = require('node:process');\nconst { Collection } = require('@discordjs/collection');\nconst { ChannelType, Routes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst GuildTextThreadManager = require('./GuildTextThreadManager');\nconst { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require('../errors');\nconst GuildChannel = require('../structures/GuildChannel');\nconst PermissionOverwrites = require('../structures/PermissionOverwrites');\nconst ThreadChannel = require('../structures/ThreadChannel');\nconst Webhook = require('../structures/Webhook');\nconst ChannelFlagsBitField = require('../util/ChannelFlagsBitField');\nconst { transformGuildForumTag, transformGuildDefaultReaction } = require('../util/Channels');\nconst { ThreadChannelTypes } = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst { setPosition } = require('../util/Util');\n\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for GuildChannels and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildChannelManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, GuildChannel, iterable);\n    const defaultCaching =\n      this._cache.constructor.name === 'Collection' ||\n      this._cache.maxSize === undefined ||\n      this._cache.maxSize === Infinity;\n    if (!cacheWarningEmitted && !defaultCaching) {\n      cacheWarningEmitted = true;\n      process.emitWarning(\n        `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,\n        'UnsupportedCacheOverwriteWarning',\n      );\n    }\n\n    /**\n     * The guild this Manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The number of channels in this managers cache excluding thread channels\n   * that do not count towards a guild's maximum channels restriction.\n   * @type {number}\n   * @readonly\n   */\n  get channelCountWithoutThreads() {\n    return this.cache.reduce((acc, channel) => {\n      if (ThreadChannelTypes.includes(channel.type)) return acc;\n      return ++acc;\n    }, 0);\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, GuildChannel|ThreadChannel>}\n   * @name GuildChannelManager#cache\n   */\n\n  _add(channel) {\n    const existing = this.cache.get(channel.id);\n    if (existing) return existing;\n    this.cache.set(channel.id, channel);\n    return channel;\n  }\n\n  /**\n   * Data that can be resolved to give a Guild Channel object. This can be:\n   * * A GuildChannel object\n   * * A ThreadChannel object\n   * * A Snowflake\n   * @typedef {GuildChannel|ThreadChannel|Snowflake} GuildChannelResolvable\n   */\n\n  /**\n   * Resolves a GuildChannelResolvable to a Channel object.\n   * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve\n   * @returns {?(GuildChannel|ThreadChannel)}\n   */\n  resolve(channel) {\n    if (channel instanceof ThreadChannel) return super.resolve(channel.id);\n    return super.resolve(channel);\n  }\n\n  /**\n   * Resolves a GuildChannelResolvable to a channel id.\n   * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n  resolveId(channel) {\n    if (channel instanceof ThreadChannel) return super.resolveId(channel.id);\n    return super.resolveId(channel);\n  }\n\n  /**\n   * Adds the target channel to a channel's followers.\n   * @param {NewsChannel|Snowflake} channel The channel to follow\n   * @param {TextChannelResolvable} targetChannel The channel where published announcements will be posted at\n   * @param {string} [reason] Reason for creating the webhook\n   * @returns {Promise<Snowflake>} Returns created target webhook id.\n   */\n  async addFollower(channel, targetChannel, reason) {\n    const channelId = this.resolveId(channel);\n    const targetChannelId = this.resolveId(targetChannel);\n    if (!channelId || !targetChannelId) throw new Error(ErrorCodes.GuildChannelResolve);\n    const { webhook_id } = await this.client.rest.post(Routes.channelFollowers(channelId), {\n      body: { webhook_channel_id: targetChannelId },\n      reason,\n    });\n    return webhook_id;\n  }\n\n  /**\n   * Options used to create a new channel in a guild.\n   * @typedef {CategoryCreateChannelOptions} GuildChannelCreateOptions\n   * @property {?CategoryChannelResolvable} [parent] Parent of the new channel\n   */\n\n  /**\n   * Creates a new channel in the guild.\n   * @param {GuildChannelCreateOptions} options Options for creating the new channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Create a new text channel\n   * guild.channels.create({ name: 'new-general', reason: 'Needed a cool new channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Create a new channel with permission overwrites\n   * guild.channels.create({\n   *   name: 'new-general',\n   *   type: ChannelType.GuildVoice,\n   *   permissionOverwrites: [\n   *      {\n   *        id: message.author.id,\n   *        deny: [PermissionFlagsBits.ViewChannel],\n   *     },\n   *   ],\n   * })\n   */\n  async create({\n    name,\n    type,\n    topic,\n    nsfw,\n    bitrate,\n    userLimit,\n    parent,\n    permissionOverwrites,\n    position,\n    rateLimitPerUser,\n    rtcRegion,\n    videoQualityMode,\n    availableTags,\n    defaultReactionEmoji,\n    defaultAutoArchiveDuration,\n    defaultSortOrder,\n    defaultForumLayout,\n    reason,\n  }) {\n    parent &&= this.client.channels.resolveId(parent);\n    permissionOverwrites &&= permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n\n    const data = await this.client.rest.post(Routes.guildChannels(this.guild.id), {\n      body: {\n        name,\n        topic,\n        type,\n        nsfw,\n        bitrate,\n        user_limit: userLimit,\n        parent_id: parent,\n        position,\n        permission_overwrites: permissionOverwrites,\n        rate_limit_per_user: rateLimitPerUser,\n        rtc_region: rtcRegion,\n        video_quality_mode: videoQualityMode,\n        available_tags: availableTags?.map(availableTag => transformGuildForumTag(availableTag)),\n        default_reaction_emoji: defaultReactionEmoji && transformGuildDefaultReaction(defaultReactionEmoji),\n        default_auto_archive_duration: defaultAutoArchiveDuration,\n        default_sort_order: defaultSortOrder,\n        default_forum_layout: defaultForumLayout,\n      },\n      reason,\n    });\n    return this.client.actions.ChannelCreate.handle(data).channel;\n  }\n\n  /**\n   * @typedef {ChannelWebhookCreateOptions} WebhookCreateOptions\n   * @property {TextChannel|NewsChannel|VoiceChannel|StageChannel|ForumChannel|Snowflake} channel\n   * The channel to create the webhook for\n   */\n\n  /**\n   * Creates a webhook for the channel.\n   * @param {WebhookCreateOptions} options Options for creating the webhook\n   * @returns {Promise<Webhook>} Returns the created Webhook\n   * @example\n   * // Create a webhook for the current channel\n   * guild.channels.createWebhook({\n   *   channel: '222197033908436994',\n   *   name: 'Snek',\n   *   avatar: 'https://i.imgur.com/mI8XcpG.jpg',\n   *   reason: 'Needed a cool new Webhook'\n   * })\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  async createWebhook({ channel, name, avatar, reason }) {\n    const id = this.resolveId(channel);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    if (typeof avatar === 'string' && !avatar.startsWith('data:')) {\n      avatar = await DataResolver.resolveImage(avatar);\n    }\n    const data = await this.client.rest.post(Routes.channelWebhooks(id), {\n      body: {\n        name,\n        avatar,\n      },\n      reason,\n    });\n    return new Webhook(this.client, data);\n  }\n\n  /**\n   * Options used to edit a guild channel.\n   * @typedef {Object} GuildChannelEditOptions\n   * @property {string} [name] The name of the channel\n   * @property {ChannelType} [type] The type of the channel (only conversion between text and news is supported)\n   * @property {number} [position] The position of the channel\n   * @property {?string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the voice channel\n   * @property {?CategoryChannelResolvable} [parent] The parent of the channel\n   * @property {boolean} [lockPermissions]\n   * Lock the permissions of the channel to what the parent's permissions are\n   * @property {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [permissionOverwrites]\n   * Permission overwrites for the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the channel in seconds\n   * @property {ThreadAutoArchiveDuration} [defaultAutoArchiveDuration]\n   * The default auto archive duration for all new threads in this channel\n   * @property {?string} [rtcRegion] The RTC region of the channel\n   * @property {?VideoQualityMode} [videoQualityMode] The camera video quality mode of the channel\n   * @property {GuildForumTagData[]} [availableTags] The tags to set as available in a forum channel\n   * @property {?DefaultReactionEmoji} [defaultReactionEmoji] The emoji to set as the default reaction emoji\n   * @property {number} [defaultThreadRateLimitPerUser] The rate limit per user (slowmode) to set on forum posts\n   * @property {ChannelFlagsResolvable} [flags] The flags to set on the channel\n   * @property {?SortOrderType} [defaultSortOrder] The default sort order mode to set on the channel\n   * @property {ForumLayoutType} [defaultForumLayout] The default forum layout to set on the channel\n   * @property {string} [reason] Reason for editing this channel\n   */\n\n  /**\n   * Edits the channel.\n   * @param {GuildChannelResolvable} channel The channel to edit\n   * @param {GuildChannelEditOptions} options Options for editing the channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Edit a channel\n   * guild.channels.edit('222197033908436994', { name: 'new-channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async edit(channel, options) {\n    channel = this.resolve(channel);\n    if (!channel) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n\n    const parent = options.parent && this.client.channels.resolveId(options.parent);\n\n    if (options.position !== undefined) {\n      await this.setPosition(channel, options.position, { position: options.position, reason: options.reason });\n    }\n\n    let permission_overwrites = options.permissionOverwrites?.map(o => PermissionOverwrites.resolve(o, this.guild));\n\n    if (options.lockPermissions) {\n      if (parent) {\n        const newParent = this.guild.channels.resolve(parent);\n        if (newParent?.type === ChannelType.GuildCategory) {\n          permission_overwrites = newParent.permissionOverwrites.cache.map(o =>\n            PermissionOverwrites.resolve(o, this.guild),\n          );\n        }\n      } else if (channel.parent) {\n        permission_overwrites = channel.parent.permissionOverwrites.cache.map(o =>\n          PermissionOverwrites.resolve(o, this.guild),\n        );\n      }\n    }\n\n    const newData = await this.client.rest.patch(Routes.channel(channel.id), {\n      body: {\n        name: (options.name ?? channel.name).trim(),\n        type: options.type,\n        topic: options.topic,\n        nsfw: options.nsfw,\n        bitrate: options.bitrate ?? channel.bitrate,\n        user_limit: options.userLimit ?? channel.userLimit,\n        rtc_region: 'rtcRegion' in options ? options.rtcRegion : channel.rtcRegion,\n        video_quality_mode: options.videoQualityMode,\n        parent_id: parent,\n        lock_permissions: options.lockPermissions,\n        rate_limit_per_user: options.rateLimitPerUser,\n        default_auto_archive_duration: options.defaultAutoArchiveDuration,\n        permission_overwrites,\n        available_tags: options.availableTags?.map(availableTag => transformGuildForumTag(availableTag)),\n        default_reaction_emoji:\n          options.defaultReactionEmoji && transformGuildDefaultReaction(options.defaultReactionEmoji),\n        default_thread_rate_limit_per_user: options.defaultThreadRateLimitPerUser,\n        flags: 'flags' in options ? ChannelFlagsBitField.resolve(options.flags) : undefined,\n        default_sort_order: options.defaultSortOrder,\n        default_forum_layout: options.defaultForumLayout,\n      },\n      reason: options.reason,\n    });\n\n    return this.client.actions.ChannelUpdate.handle(newData).updated;\n  }\n\n  /**\n   * Sets a new position for the guild channel.\n   * @param {GuildChannelResolvable} channel The channel to set the position for\n   * @param {number} position The new position for the guild channel\n   * @param {SetChannelPositionOptions} options Options for setting position\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel position\n   * guild.channels.setPosition('222078374472843266', 2)\n   *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))\n   *   .catch(console.error);\n   */\n  async setPosition(channel, position, { relative, reason } = {}) {\n    channel = this.resolve(channel);\n    if (!channel) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    const updatedChannels = await setPosition(\n      channel,\n      position,\n      relative,\n      this.guild._sortedChannels(channel),\n      this.client,\n      Routes.guildChannels(this.guild.id),\n      reason,\n    );\n\n    this.client.actions.GuildChannelsPositionUpdate.handle({\n      guild_id: this.guild.id,\n      channels: updatedChannels,\n    });\n    return channel;\n  }\n\n  /**\n   * Obtains one or more guild channels from Discord, or the channel cache if they're already available.\n   * @param {Snowflake} [id] The channel's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<?GuildChannel|ThreadChannel|Collection<Snowflake, ?GuildChannel>>}\n   * @example\n   * // Fetch all channels from the guild (excluding threads)\n   * message.guild.channels.fetch()\n   *   .then(channels => console.log(`There are ${channels.size} channels.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single channel\n   * message.guild.channels.fetch('222197033908436994')\n   *   .then(channel => console.log(`The channel name is: ${channel.name}`))\n   *   .catch(console.error);\n   */\n  async fetch(id, { cache = true, force = false } = {}) {\n    if (id && !force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    }\n\n    if (id) {\n      const data = await this.client.rest.get(Routes.channel(id));\n      // Since this is the guild manager, throw if on a different guild\n      if (this.guild.id !== data.guild_id) throw new DiscordjsError(ErrorCodes.GuildChannelUnowned);\n      return this.client.channels._add(data, this.guild, { cache });\n    }\n\n    const data = await this.client.rest.get(Routes.guildChannels(this.guild.id));\n    const channels = new Collection();\n    for (const channel of data) channels.set(channel.id, this.client.channels._add(channel, this.guild, { cache }));\n    return channels;\n  }\n\n  /**\n   * Fetches all webhooks for the channel.\n   * @param {GuildChannelResolvable} channel The channel to fetch webhooks for\n   * @returns {Promise<Collection<Snowflake, Webhook>>}\n   * @example\n   * // Fetch webhooks\n   * guild.channels.fetchWebhooks('769862166131245066')\n   *   .then(hooks => console.log(`This channel has ${hooks.size} hooks`))\n   *   .catch(console.error);\n   */\n  async fetchWebhooks(channel) {\n    const id = this.resolveId(channel);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    const data = await this.client.rest.get(Routes.channelWebhooks(id));\n    return data.reduce((hooks, hook) => hooks.set(hook.id, new Webhook(this.client, hook)), new Collection());\n  }\n\n  /**\n   * Data that can be resolved to give a Category Channel object. This can be:\n   * * A CategoryChannel object\n   * * A Snowflake\n   * @typedef {CategoryChannel|Snowflake} CategoryChannelResolvable\n   */\n\n  /**\n   * The data needed for updating a channel's position.\n   * @typedef {Object} ChannelPosition\n   * @property {GuildChannel|Snowflake} channel Channel to update\n   * @property {number} [position] New position for the channel\n   * @property {CategoryChannelResolvable} [parent] Parent channel for this channel\n   * @property {boolean} [lockPermissions] If the overwrites should be locked to the parents overwrites\n   */\n\n  /**\n   * Batch-updates the guild's channels' positions.\n   * <info>Only one channel's parent can be changed at a time</info>\n   * @param {ChannelPosition[]} channelPositions Channel positions to update\n   * @returns {Promise<Guild>}\n   * @example\n   * guild.channels.setPositions([{ channel: channelId, position: newChannelIndex }])\n   *   .then(guild => console.log(`Updated channel positions for ${guild}`))\n   *   .catch(console.error);\n   */\n  async setPositions(channelPositions) {\n    channelPositions = channelPositions.map(r => ({\n      id: this.client.channels.resolveId(r.channel),\n      position: r.position,\n      lock_permissions: r.lockPermissions,\n      parent_id: r.parent !== undefined ? this.resolveId(r.parent) : undefined,\n    }));\n\n    await this.client.rest.patch(Routes.guildChannels(this.guild.id), { body: channelPositions });\n    return this.client.actions.GuildChannelsPositionUpdate.handle({\n      guild_id: this.guild.id,\n      channels: channelPositions,\n    }).guild;\n  }\n\n  /**\n   * Data returned from fetching threads.\n   * @typedef {Object} FetchedThreads\n   * @property {Collection<Snowflake, ThreadChannel>} threads The threads that were fetched\n   * @property {Collection<Snowflake, ThreadMember>} members The thread members in the received threads\n   */\n\n  /**\n   * Obtains all active thread channels in the guild.\n   * @param {boolean} [cache=true] Whether to cache the fetched data\n   * @returns {Promise<FetchedThreads>}\n   * @example\n   * // Fetch all threads from the guild\n   * message.guild.channels.fetchActiveThreads()\n   *   .then(fetched => console.log(`There are ${fetched.threads.size} threads.`))\n   *   .catch(console.error);\n   */\n  async fetchActiveThreads(cache = true) {\n    const data = await this.rawFetchGuildActiveThreads();\n    return GuildTextThreadManager._mapThreads(data, this.client, { guild: this.guild, cache });\n  }\n\n  /**\n   * `GET /guilds/{guild.id}/threads/active`\n   * @private\n   * @returns {Promise<RESTGetAPIGuildThreadsResult>}\n   */\n  rawFetchGuildActiveThreads() {\n    return this.client.rest.get(Routes.guildActiveThreads(this.guild.id));\n  }\n\n  /**\n   * Deletes the channel.\n   * @param {GuildChannelResolvable} channel The channel to delete\n   * @param {string} [reason] Reason for deleting this channel\n   * @returns {Promise<void>}\n   * @example\n   * // Delete the channel\n   * guild.channels.delete('858850993013260338', 'making room for new channels')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async delete(channel, reason) {\n    const id = this.resolveId(channel);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    await this.client.rest.delete(Routes.channel(id), { reason });\n    this.client.actions.ChannelDelete.handle({ id });\n  }\n}\n\nmodule.exports = GuildChannelManager;\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,OAAO,GAAGC,OAAO,CAAC,cAAc,CAAC;AACvC,MAAM;EAAEC;AAAW,CAAC,GAAGD,OAAO,CAAC,uBAAuB,CAAC;AACvD,MAAM;EAAEE,WAAW;EAAEC;AAAO,CAAC,GAAGH,OAAO,CAAC,uBAAuB,CAAC;AAChE,MAAMI,aAAa,GAAGJ,OAAO,CAAC,iBAAiB,CAAC;AAChD,MAAMK,sBAAsB,GAAGL,OAAO,CAAC,0BAA0B,CAAC;AAClE,MAAM;EAAEM,cAAc;EAAEC,kBAAkB;EAAEC;AAAW,CAAC,GAAGR,OAAO,CAAC,WAAW,CAAC;AAC/E,MAAMS,YAAY,GAAGT,OAAO,CAAC,4BAA4B,CAAC;AAC1D,MAAMU,oBAAoB,GAAGV,OAAO,CAAC,oCAAoC,CAAC;AAC1E,MAAMW,aAAa,GAAGX,OAAO,CAAC,6BAA6B,CAAC;AAC5D,MAAMY,OAAO,GAAGZ,OAAO,CAAC,uBAAuB,CAAC;AAChD,MAAMa,oBAAoB,GAAGb,OAAO,CAAC,8BAA8B,CAAC;AACpE,MAAM;EAAEc,sBAAsB;EAAEC;AAA8B,CAAC,GAAGf,OAAO,CAAC,kBAAkB,CAAC;AAC7F,MAAM;EAAEgB;AAAmB,CAAC,GAAGhB,OAAO,CAAC,mBAAmB,CAAC;AAC3D,MAAMiB,YAAY,GAAGjB,OAAO,CAAC,sBAAsB,CAAC;AACpD,MAAM;EAAEkB;AAAY,CAAC,GAAGlB,OAAO,CAAC,cAAc,CAAC;AAE/C,IAAImB,mBAAmB,GAAG,KAAK;;AAE/B;AACA;AACA;AACA;AACA,MAAMC,mBAAmB,SAAShB,aAAa,CAAC;EAC9CiB,WAAWA,CAACC,KAAK,EAAEC,QAAQ,EAAE;IAC3B,KAAK,CAACD,KAAK,CAACE,MAAM,EAAEf,YAAY,EAAEc,QAAQ,CAAC;IAC3C,MAAME,cAAc,GAClB,IAAI,CAACC,MAAM,CAACL,WAAW,CAACM,IAAI,KAAK,YAAY,IAC7C,IAAI,CAACD,MAAM,CAACE,OAAO,KAAKC,SAAS,IACjC,IAAI,CAACH,MAAM,CAACE,OAAO,KAAKE,QAAQ;IAClC,IAAI,CAACX,mBAAmB,IAAI,CAACM,cAAc,EAAE;MAC3CN,mBAAmB,GAAG,IAAI;MAC1BpB,OAAO,CAACgC,WAAW,CACjB,qCAAqC,IAAI,CAACV,WAAW,CAACM,IAAI,2CAA2C,EACrG,kCACF,CAAC;IACH;;IAEA;AACJ;AACA;AACA;IACI,IAAI,CAACL,KAAK,GAAGA,KAAK;EACpB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,IAAIU,0BAA0BA,CAAA,EAAG;IAC/B,OAAO,IAAI,CAACC,KAAK,CAACC,MAAM,CAAC,CAACC,GAAG,EAAEC,OAAO,KAAK;MACzC,IAAIpB,kBAAkB,CAACqB,QAAQ,CAACD,OAAO,CAACE,IAAI,CAAC,EAAE,OAAOH,GAAG;MACzD,OAAO,EAAEA,GAAG;IACd,CAAC,EAAE,CAAC,CAAC;EACP;;EAEA;AACF;AACA;AACA;AACA;;EAEEI,IAAIA,CAACH,OAAO,EAAE;IACZ,MAAMI,QAAQ,GAAG,IAAI,CAACP,KAAK,CAACQ,GAAG,CAACL,OAAO,CAACM,EAAE,CAAC;IAC3C,IAAIF,QAAQ,EAAE,OAAOA,QAAQ;IAC7B,IAAI,CAACP,KAAK,CAACU,GAAG,CAACP,OAAO,CAACM,EAAE,EAAEN,OAAO,CAAC;IACnC,OAAOA,OAAO;EAChB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;EACEQ,OAAOA,CAACR,OAAO,EAAE;IACf,IAAIA,OAAO,YAAYzB,aAAa,EAAE,OAAO,KAAK,CAACiC,OAAO,CAACR,OAAO,CAACM,EAAE,CAAC;IACtE,OAAO,KAAK,CAACE,OAAO,CAACR,OAAO,CAAC;EAC/B;;EAEA;AACF;AACA;AACA;AACA;EACES,SAASA,CAACT,OAAO,EAAE;IACjB,IAAIA,OAAO,YAAYzB,aAAa,EAAE,OAAO,KAAK,CAACkC,SAAS,CAACT,OAAO,CAACM,EAAE,CAAC;IACxE,OAAO,KAAK,CAACG,SAAS,CAACT,OAAO,CAAC;EACjC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,MAAMU,WAAWA,CAACV,OAAO,EAAEW,aAAa,EAAEC,MAAM,EAAE;IAChD,MAAMC,SAAS,GAAG,IAAI,CAACJ,SAAS,CAACT,OAAO,CAAC;IACzC,MAAMc,eAAe,GAAG,IAAI,CAACL,SAAS,CAACE,aAAa,CAAC;IACrD,IAAI,CAACE,SAAS,IAAI,CAACC,eAAe,EAAE,MAAM,IAAIC,KAAK,CAAC3C,UAAU,CAAC4C,mBAAmB,CAAC;IACnF,MAAM;MAAEC;IAAW,CAAC,GAAG,MAAM,IAAI,CAAC7B,MAAM,CAAC8B,IAAI,CAACC,IAAI,CAACpD,MAAM,CAACqD,gBAAgB,CAACP,SAAS,CAAC,EAAE;MACrFQ,IAAI,EAAE;QAAEC,kBAAkB,EAAER;MAAgB,CAAC;MAC7CF;IACF,CAAC,CAAC;IACF,OAAOK,UAAU;EACnB;;EAEA;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMM,MAAMA,CAAC;IACXhC,IAAI;IACJW,IAAI;IACJsB,KAAK;IACLC,IAAI;IACJC,OAAO;IACPC,SAAS;IACTC,MAAM;IACNC,oBAAoB;IACpBC,QAAQ;IACRC,gBAAgB;IAChBC,SAAS;IACTC,gBAAgB;IAChBC,aAAa;IACbC,oBAAoB;IACpBC,0BAA0B;IAC1BC,gBAAgB;IAChBC,kBAAkB;IAClB1B;EACF,CAAC,EAAE;IACDgB,MAAM,KAAK,IAAI,CAACxC,MAAM,CAACmD,QAAQ,CAAC9B,SAAS,CAACmB,MAAM,CAAC;IACjDC,oBAAoB,KAAKA,oBAAoB,CAACW,GAAG,CAACC,CAAC,IAAInE,oBAAoB,CAACkC,OAAO,CAACiC,CAAC,EAAE,IAAI,CAACvD,KAAK,CAAC,CAAC;IAEnG,MAAMwD,IAAI,GAAG,MAAM,IAAI,CAACtD,MAAM,CAAC8B,IAAI,CAACC,IAAI,CAACpD,MAAM,CAAC4E,aAAa,CAAC,IAAI,CAACzD,KAAK,CAACoB,EAAE,CAAC,EAAE;MAC5Ee,IAAI,EAAE;QACJ9B,IAAI;QACJiC,KAAK;QACLtB,IAAI;QACJuB,IAAI;QACJC,OAAO;QACPkB,UAAU,EAAEjB,SAAS;QACrBkB,SAAS,EAAEjB,MAAM;QACjBE,QAAQ;QACRgB,qBAAqB,EAAEjB,oBAAoB;QAC3CkB,mBAAmB,EAAEhB,gBAAgB;QACrCiB,UAAU,EAAEhB,SAAS;QACrBiB,kBAAkB,EAAEhB,gBAAgB;QACpCiB,cAAc,EAAEhB,aAAa,EAAEM,GAAG,CAACW,YAAY,IAAIzE,sBAAsB,CAACyE,YAAY,CAAC,CAAC;QACxFC,sBAAsB,EAAEjB,oBAAoB,IAAIxD,6BAA6B,CAACwD,oBAAoB,CAAC;QACnGkB,6BAA6B,EAAEjB,0BAA0B;QACzDkB,kBAAkB,EAAEjB,gBAAgB;QACpCkB,oBAAoB,EAAEjB;MACxB,CAAC;MACD1B;IACF,CAAC,CAAC;IACF,OAAO,IAAI,CAACxB,MAAM,CAACoE,OAAO,CAACC,aAAa,CAACC,MAAM,CAAChB,IAAI,CAAC,CAAC1C,OAAO;EAC/D;;EAEA;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAM2D,aAAaA,CAAC;IAAE3D,OAAO;IAAET,IAAI;IAAEqE,MAAM;IAAEhD;EAAO,CAAC,EAAE;IACrD,MAAMN,EAAE,GAAG,IAAI,CAACG,SAAS,CAACT,OAAO,CAAC;IAClC,IAAI,CAACM,EAAE,EAAE,MAAM,IAAInC,kBAAkB,CAACC,UAAU,CAACyF,WAAW,EAAE,SAAS,EAAE,wBAAwB,CAAC;IAClG,IAAI,OAAOD,MAAM,KAAK,QAAQ,IAAI,CAACA,MAAM,CAACE,UAAU,CAAC,OAAO,CAAC,EAAE;MAC7DF,MAAM,GAAG,MAAM/E,YAAY,CAACkF,YAAY,CAACH,MAAM,CAAC;IAClD;IACA,MAAMlB,IAAI,GAAG,MAAM,IAAI,CAACtD,MAAM,CAAC8B,IAAI,CAACC,IAAI,CAACpD,MAAM,CAACiG,eAAe,CAAC1D,EAAE,CAAC,EAAE;MACnEe,IAAI,EAAE;QACJ9B,IAAI;QACJqE;MACF,CAAC;MACDhD;IACF,CAAC,CAAC;IACF,OAAO,IAAIpC,OAAO,CAAC,IAAI,CAACY,MAAM,EAAEsD,IAAI,CAAC;EACvC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMuB,IAAIA,CAACjE,OAAO,EAAEkE,OAAO,EAAE;IAC3BlE,OAAO,GAAG,IAAI,CAACQ,OAAO,CAACR,OAAO,CAAC;IAC/B,IAAI,CAACA,OAAO,EAAE,MAAM,IAAI7B,kBAAkB,CAACC,UAAU,CAACyF,WAAW,EAAE,SAAS,EAAE,wBAAwB,CAAC;IAEvG,MAAMjC,MAAM,GAAGsC,OAAO,CAACtC,MAAM,IAAI,IAAI,CAACxC,MAAM,CAACmD,QAAQ,CAAC9B,SAAS,CAACyD,OAAO,CAACtC,MAAM,CAAC;IAE/E,IAAIsC,OAAO,CAACpC,QAAQ,KAAKrC,SAAS,EAAE;MAClC,MAAM,IAAI,CAACX,WAAW,CAACkB,OAAO,EAAEkE,OAAO,CAACpC,QAAQ,EAAE;QAAEA,QAAQ,EAAEoC,OAAO,CAACpC,QAAQ;QAAElB,MAAM,EAAEsD,OAAO,CAACtD;MAAO,CAAC,CAAC;IAC3G;IAEA,IAAIkC,qBAAqB,GAAGoB,OAAO,CAACrC,oBAAoB,EAAEW,GAAG,CAACC,CAAC,IAAInE,oBAAoB,CAACkC,OAAO,CAACiC,CAAC,EAAE,IAAI,CAACvD,KAAK,CAAC,CAAC;IAE/G,IAAIgF,OAAO,CAACC,eAAe,EAAE;MAC3B,IAAIvC,MAAM,EAAE;QACV,MAAMwC,SAAS,GAAG,IAAI,CAAClF,KAAK,CAACqD,QAAQ,CAAC/B,OAAO,CAACoB,MAAM,CAAC;QACrD,IAAIwC,SAAS,EAAElE,IAAI,KAAKpC,WAAW,CAACuG,aAAa,EAAE;UACjDvB,qBAAqB,GAAGsB,SAAS,CAACvC,oBAAoB,CAAChC,KAAK,CAAC2C,GAAG,CAACC,CAAC,IAChEnE,oBAAoB,CAACkC,OAAO,CAACiC,CAAC,EAAE,IAAI,CAACvD,KAAK,CAC5C,CAAC;QACH;MACF,CAAC,MAAM,IAAIc,OAAO,CAAC4B,MAAM,EAAE;QACzBkB,qBAAqB,GAAG9C,OAAO,CAAC4B,MAAM,CAACC,oBAAoB,CAAChC,KAAK,CAAC2C,GAAG,CAACC,CAAC,IACrEnE,oBAAoB,CAACkC,OAAO,CAACiC,CAAC,EAAE,IAAI,CAACvD,KAAK,CAC5C,CAAC;MACH;IACF;IAEA,MAAMoF,OAAO,GAAG,MAAM,IAAI,CAAClF,MAAM,CAAC8B,IAAI,CAACqD,KAAK,CAACxG,MAAM,CAACiC,OAAO,CAACA,OAAO,CAACM,EAAE,CAAC,EAAE;MACvEe,IAAI,EAAE;QACJ9B,IAAI,EAAE,CAAC2E,OAAO,CAAC3E,IAAI,IAAIS,OAAO,CAACT,IAAI,EAAEiF,IAAI,CAAC,CAAC;QAC3CtE,IAAI,EAAEgE,OAAO,CAAChE,IAAI;QAClBsB,KAAK,EAAE0C,OAAO,CAAC1C,KAAK;QACpBC,IAAI,EAAEyC,OAAO,CAACzC,IAAI;QAClBC,OAAO,EAAEwC,OAAO,CAACxC,OAAO,IAAI1B,OAAO,CAAC0B,OAAO;QAC3CkB,UAAU,EAAEsB,OAAO,CAACvC,SAAS,IAAI3B,OAAO,CAAC2B,SAAS;QAClDqB,UAAU,EAAE,WAAW,IAAIkB,OAAO,GAAGA,OAAO,CAAClC,SAAS,GAAGhC,OAAO,CAACgC,SAAS;QAC1EiB,kBAAkB,EAAEiB,OAAO,CAACjC,gBAAgB;QAC5CY,SAAS,EAAEjB,MAAM;QACjB6C,gBAAgB,EAAEP,OAAO,CAACC,eAAe;QACzCpB,mBAAmB,EAAEmB,OAAO,CAACnC,gBAAgB;QAC7CsB,6BAA6B,EAAEa,OAAO,CAAC9B,0BAA0B;QACjEU,qBAAqB;QACrBI,cAAc,EAAEgB,OAAO,CAAChC,aAAa,EAAEM,GAAG,CAACW,YAAY,IAAIzE,sBAAsB,CAACyE,YAAY,CAAC,CAAC;QAChGC,sBAAsB,EACpBc,OAAO,CAAC/B,oBAAoB,IAAIxD,6BAA6B,CAACuF,OAAO,CAAC/B,oBAAoB,CAAC;QAC7FuC,kCAAkC,EAAER,OAAO,CAACS,6BAA6B;QACzEC,KAAK,EAAE,OAAO,IAAIV,OAAO,GAAGzF,oBAAoB,CAAC+B,OAAO,CAAC0D,OAAO,CAACU,KAAK,CAAC,GAAGnF,SAAS;QACnF6D,kBAAkB,EAAEY,OAAO,CAAC7B,gBAAgB;QAC5CkB,oBAAoB,EAAEW,OAAO,CAAC5B;MAChC,CAAC;MACD1B,MAAM,EAAEsD,OAAO,CAACtD;IAClB,CAAC,CAAC;IAEF,OAAO,IAAI,CAACxB,MAAM,CAACoE,OAAO,CAACqB,aAAa,CAACnB,MAAM,CAACY,OAAO,CAAC,CAACQ,OAAO;EAClE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMhG,WAAWA,CAACkB,OAAO,EAAE8B,QAAQ,EAAE;IAAEiD,QAAQ;IAAEnE;EAAO,CAAC,GAAG,CAAC,CAAC,EAAE;IAC9DZ,OAAO,GAAG,IAAI,CAACQ,OAAO,CAACR,OAAO,CAAC;IAC/B,IAAI,CAACA,OAAO,EAAE,MAAM,IAAI7B,kBAAkB,CAACC,UAAU,CAACyF,WAAW,EAAE,SAAS,EAAE,wBAAwB,CAAC;IACvG,MAAMmB,eAAe,GAAG,MAAMlG,WAAW,CACvCkB,OAAO,EACP8B,QAAQ,EACRiD,QAAQ,EACR,IAAI,CAAC7F,KAAK,CAAC+F,eAAe,CAACjF,OAAO,CAAC,EACnC,IAAI,CAACZ,MAAM,EACXrB,MAAM,CAAC4E,aAAa,CAAC,IAAI,CAACzD,KAAK,CAACoB,EAAE,CAAC,EACnCM,MACF,CAAC;IAED,IAAI,CAACxB,MAAM,CAACoE,OAAO,CAAC0B,2BAA2B,CAACxB,MAAM,CAAC;MACrDyB,QAAQ,EAAE,IAAI,CAACjG,KAAK,CAACoB,EAAE;MACvBiC,QAAQ,EAAEyC;IACZ,CAAC,CAAC;IACF,OAAOhF,OAAO;EAChB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMoF,KAAKA,CAAC9E,EAAE,EAAE;IAAET,KAAK,GAAG,IAAI;IAAEwF,KAAK,GAAG;EAAM,CAAC,GAAG,CAAC,CAAC,EAAE;IACpD,IAAI/E,EAAE,IAAI,CAAC+E,KAAK,EAAE;MAChB,MAAMjF,QAAQ,GAAG,IAAI,CAACP,KAAK,CAACQ,GAAG,CAACC,EAAE,CAAC;MACnC,IAAIF,QAAQ,EAAE,OAAOA,QAAQ;IAC/B;IAEA,IAAIE,EAAE,EAAE;MACN,MAAMoC,IAAI,GAAG,MAAM,IAAI,CAACtD,MAAM,CAAC8B,IAAI,CAACb,GAAG,CAACtC,MAAM,CAACiC,OAAO,CAACM,EAAE,CAAC,CAAC;MAC3D;MACA,IAAI,IAAI,CAACpB,KAAK,CAACoB,EAAE,KAAKoC,IAAI,CAACyC,QAAQ,EAAE,MAAM,IAAIjH,cAAc,CAACE,UAAU,CAACkH,mBAAmB,CAAC;MAC7F,OAAO,IAAI,CAAClG,MAAM,CAACmD,QAAQ,CAACpC,IAAI,CAACuC,IAAI,EAAE,IAAI,CAACxD,KAAK,EAAE;QAAEW;MAAM,CAAC,CAAC;IAC/D;IAEA,MAAM6C,IAAI,GAAG,MAAM,IAAI,CAACtD,MAAM,CAAC8B,IAAI,CAACb,GAAG,CAACtC,MAAM,CAAC4E,aAAa,CAAC,IAAI,CAACzD,KAAK,CAACoB,EAAE,CAAC,CAAC;IAC5E,MAAMiC,QAAQ,GAAG,IAAI1E,UAAU,CAAC,CAAC;IACjC,KAAK,MAAMmC,OAAO,IAAI0C,IAAI,EAAEH,QAAQ,CAAChC,GAAG,CAACP,OAAO,CAACM,EAAE,EAAE,IAAI,CAAClB,MAAM,CAACmD,QAAQ,CAACpC,IAAI,CAACH,OAAO,EAAE,IAAI,CAACd,KAAK,EAAE;MAAEW;IAAM,CAAC,CAAC,CAAC;IAC/G,OAAO0C,QAAQ;EACjB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMgD,aAAaA,CAACvF,OAAO,EAAE;IAC3B,MAAMM,EAAE,GAAG,IAAI,CAACG,SAAS,CAACT,OAAO,CAAC;IAClC,IAAI,CAACM,EAAE,EAAE,MAAM,IAAInC,kBAAkB,CAACC,UAAU,CAACyF,WAAW,EAAE,SAAS,EAAE,wBAAwB,CAAC;IAClG,MAAMnB,IAAI,GAAG,MAAM,IAAI,CAACtD,MAAM,CAAC8B,IAAI,CAACb,GAAG,CAACtC,MAAM,CAACiG,eAAe,CAAC1D,EAAE,CAAC,CAAC;IACnE,OAAOoC,IAAI,CAAC5C,MAAM,CAAC,CAAC0F,KAAK,EAAEC,IAAI,KAAKD,KAAK,CAACjF,GAAG,CAACkF,IAAI,CAACnF,EAAE,EAAE,IAAI9B,OAAO,CAAC,IAAI,CAACY,MAAM,EAAEqG,IAAI,CAAC,CAAC,EAAE,IAAI5H,UAAU,CAAC,CAAC,CAAC;EAC3G;;EAEA;AACF;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAM6H,YAAYA,CAACC,gBAAgB,EAAE;IACnCA,gBAAgB,GAAGA,gBAAgB,CAACnD,GAAG,CAACoD,CAAC,KAAK;MAC5CtF,EAAE,EAAE,IAAI,CAAClB,MAAM,CAACmD,QAAQ,CAAC9B,SAAS,CAACmF,CAAC,CAAC5F,OAAO,CAAC;MAC7C8B,QAAQ,EAAE8D,CAAC,CAAC9D,QAAQ;MACpB2C,gBAAgB,EAAEmB,CAAC,CAACzB,eAAe;MACnCtB,SAAS,EAAE+C,CAAC,CAAChE,MAAM,KAAKnC,SAAS,GAAG,IAAI,CAACgB,SAAS,CAACmF,CAAC,CAAChE,MAAM,CAAC,GAAGnC;IACjE,CAAC,CAAC,CAAC;IAEH,MAAM,IAAI,CAACL,MAAM,CAAC8B,IAAI,CAACqD,KAAK,CAACxG,MAAM,CAAC4E,aAAa,CAAC,IAAI,CAACzD,KAAK,CAACoB,EAAE,CAAC,EAAE;MAAEe,IAAI,EAAEsE;IAAiB,CAAC,CAAC;IAC7F,OAAO,IAAI,CAACvG,MAAM,CAACoE,OAAO,CAAC0B,2BAA2B,CAACxB,MAAM,CAAC;MAC5DyB,QAAQ,EAAE,IAAI,CAACjG,KAAK,CAACoB,EAAE;MACvBiC,QAAQ,EAAEoD;IACZ,CAAC,CAAC,CAACzG,KAAK;EACV;;EAEA;AACF;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAM2G,kBAAkBA,CAAChG,KAAK,GAAG,IAAI,EAAE;IACrC,MAAM6C,IAAI,GAAG,MAAM,IAAI,CAACoD,0BAA0B,CAAC,CAAC;IACpD,OAAO7H,sBAAsB,CAAC8H,WAAW,CAACrD,IAAI,EAAE,IAAI,CAACtD,MAAM,EAAE;MAAEF,KAAK,EAAE,IAAI,CAACA,KAAK;MAAEW;IAAM,CAAC,CAAC;EAC5F;;EAEA;AACF;AACA;AACA;AACA;EACEiG,0BAA0BA,CAAA,EAAG;IAC3B,OAAO,IAAI,CAAC1G,MAAM,CAAC8B,IAAI,CAACb,GAAG,CAACtC,MAAM,CAACiI,kBAAkB,CAAC,IAAI,CAAC9G,KAAK,CAACoB,EAAE,CAAC,CAAC;EACvE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAM2F,MAAMA,CAACjG,OAAO,EAAEY,MAAM,EAAE;IAC5B,MAAMN,EAAE,GAAG,IAAI,CAACG,SAAS,CAACT,OAAO,CAAC;IAClC,IAAI,CAACM,EAAE,EAAE,MAAM,IAAInC,kBAAkB,CAACC,UAAU,CAACyF,WAAW,EAAE,SAAS,EAAE,wBAAwB,CAAC;IAClG,MAAM,IAAI,CAACzE,MAAM,CAAC8B,IAAI,CAAC+E,MAAM,CAAClI,MAAM,CAACiC,OAAO,CAACM,EAAE,CAAC,EAAE;MAAEM;IAAO,CAAC,CAAC;IAC7D,IAAI,CAACxB,MAAM,CAACoE,OAAO,CAAC0C,aAAa,CAACxC,MAAM,CAAC;MAAEpD;IAAG,CAAC,CAAC;EAClD;AACF;AAEA6F,MAAM,CAACC,OAAO,GAAGpH,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}