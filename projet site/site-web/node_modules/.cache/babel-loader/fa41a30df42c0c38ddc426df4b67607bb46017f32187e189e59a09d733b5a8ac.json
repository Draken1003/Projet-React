{"ast":null,"code":"'use strict';\n\nconst {\n  ChannelType,\n  PermissionFlagsBits,\n  Routes,\n  ChannelFlags\n} = require('discord-api-types/v10');\nconst {\n  BaseChannel\n} = require('./BaseChannel');\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\nconst {\n  DiscordjsRangeError,\n  ErrorCodes\n} = require('../errors');\nconst GuildMessageManager = require('../managers/GuildMessageManager');\nconst ThreadMemberManager = require('../managers/ThreadMemberManager');\nconst ChannelFlagsBitField = require('../util/ChannelFlagsBitField');\n\n/**\n * Represents a thread channel on Discord.\n * @extends {BaseChannel}\n * @implements {TextBasedChannel}\n */\nclass ThreadChannel extends BaseChannel {\n  constructor(guild, data, client) {\n    super(guild?.client ?? client, data, false);\n\n    /**\n     * The guild the thread is in\n     * @type {Guild}\n     */\n    this.guild = guild;\n\n    /**\n     * The id of the guild the channel is in\n     * @type {Snowflake}\n     */\n    this.guildId = guild?.id ?? data.guild_id;\n\n    /**\n     * A manager of the messages sent to this thread\n     * @type {GuildMessageManager}\n     */\n    this.messages = new GuildMessageManager(this);\n\n    /**\n     * A manager of the members that are part of this thread\n     * @type {ThreadMemberManager}\n     */\n    this.members = new ThreadMemberManager(this);\n    if (data) this._patch(data);\n  }\n  _patch(data) {\n    super._patch(data);\n    if ('message' in data) this.messages._add(data.message);\n    if ('name' in data) {\n      /**\n       * The name of the thread\n       * @type {string}\n       */\n      this.name = data.name;\n    }\n    if ('guild_id' in data) {\n      this.guildId = data.guild_id;\n    }\n    if ('parent_id' in data) {\n      /**\n       * The id of the parent channel of this thread\n       * @type {?Snowflake}\n       */\n      this.parentId = data.parent_id;\n    } else {\n      this.parentId ??= null;\n    }\n    if ('thread_metadata' in data) {\n      /**\n       * Whether the thread is locked\n       * @type {?boolean}\n       */\n      this.locked = data.thread_metadata.locked ?? false;\n\n      /**\n       * Whether members without the {@link PermissionFlagsBits.ManageThreads} permission\n       * can invite other members to this thread.\n       * <info>This property is always `null` in public threads.</info>\n       * @type {?boolean}\n       */\n      this.invitable = this.type === ChannelType.PrivateThread ? data.thread_metadata.invitable ?? false : null;\n\n      /**\n       * Whether the thread is archived\n       * @type {?boolean}\n       */\n      this.archived = data.thread_metadata.archived;\n\n      /**\n       * The amount of time (in minutes) after which the thread will automatically archive in case of no recent activity\n       * @type {?ThreadAutoArchiveDuration}\n       */\n      this.autoArchiveDuration = data.thread_metadata.auto_archive_duration;\n\n      /**\n       * The timestamp when the thread's archive status was last changed\n       * <info>If the thread was never archived or unarchived, this is the timestamp at which the thread was\n       * created</info>\n       * @type {?number}\n       */\n      this.archiveTimestamp = Date.parse(data.thread_metadata.archive_timestamp);\n      if ('create_timestamp' in data.thread_metadata) {\n        // Note: this is needed because we can't assign directly to getters\n        this._createdTimestamp = Date.parse(data.thread_metadata.create_timestamp);\n      }\n    } else {\n      this.locked ??= null;\n      this.archived ??= null;\n      this.autoArchiveDuration ??= null;\n      this.archiveTimestamp ??= null;\n      this.invitable ??= null;\n    }\n    this._createdTimestamp ??= this.type === ChannelType.PrivateThread ? super.createdTimestamp : null;\n    if ('owner_id' in data) {\n      /**\n       * The id of the member who created this thread\n       * @type {?Snowflake}\n       */\n      this.ownerId = data.owner_id;\n    } else {\n      this.ownerId ??= null;\n    }\n    if ('last_message_id' in data) {\n      /**\n       * The last message id sent in this thread, if one was sent\n       * @type {?Snowflake}\n       */\n      this.lastMessageId = data.last_message_id;\n    } else {\n      this.lastMessageId ??= null;\n    }\n    if ('last_pin_timestamp' in data) {\n      /**\n       * The timestamp when the last pinned message was pinned, if there was one\n       * @type {?number}\n       */\n      this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;\n    } else {\n      this.lastPinTimestamp ??= null;\n    }\n    if ('rate_limit_per_user' in data) {\n      /**\n       * The rate limit per user (slowmode) for this thread in seconds\n       * @type {?number}\n       */\n      this.rateLimitPerUser = data.rate_limit_per_user ?? 0;\n    } else {\n      this.rateLimitPerUser ??= null;\n    }\n    if ('message_count' in data) {\n      /**\n       * The approximate count of messages in this thread\n       * <info>Threads created before July 1, 2022 may have an inaccurate count.\n       * If you need an approximate value higher than that, use `ThreadChannel#messages.cache.size`</info>\n       * @type {?number}\n       */\n      this.messageCount = data.message_count;\n    } else {\n      this.messageCount ??= null;\n    }\n    if ('member_count' in data) {\n      /**\n       * The approximate count of users in this thread\n       * <info>This stops counting at 50. If you need an approximate value higher than that, use\n       * `ThreadChannel#members.cache.size`</info>\n       * @type {?number}\n       */\n      this.memberCount = data.member_count;\n    } else {\n      this.memberCount ??= null;\n    }\n    if ('total_message_sent' in data) {\n      /**\n       * The number of messages ever sent in a thread, similar to {@link ThreadChannel#messageCount} except it\n       * will not decrement whenever a message is deleted\n       * @type {?number}\n       */\n      this.totalMessageSent = data.total_message_sent;\n    } else {\n      this.totalMessageSent ??= null;\n    }\n    if (data.member && this.client.user) this.members._add({\n      user_id: this.client.user.id,\n      ...data.member\n    });\n    if (data.messages) for (const message of data.messages) this.messages._add(message);\n    if ('applied_tags' in data) {\n      /**\n       * The tags applied to this thread\n       * @type {Snowflake[]}\n       */\n      this.appliedTags = data.applied_tags;\n    } else {\n      this.appliedTags ??= [];\n    }\n  }\n\n  /**\n   * The timestamp when this thread was created. This isn't available for threads\n   * created before 2022-01-09\n   * @type {?number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return this._createdTimestamp;\n  }\n\n  /**\n   * A collection of associated guild member objects of this thread's members\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get guildMembers() {\n    return this.members.cache.mapValues(member => member.guildMember);\n  }\n\n  /**\n   * The time at which this thread's archive status was last changed\n   * <info>If the thread was never archived or unarchived, this is the time at which the thread was created</info>\n   * @type {?Date}\n   * @readonly\n   */\n  get archivedAt() {\n    return this.archiveTimestamp && new Date(this.archiveTimestamp);\n  }\n\n  /**\n   * The time the thread was created at\n   * @type {?Date}\n   * @readonly\n   */\n  get createdAt() {\n    return this.createdTimestamp && new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The parent channel of this thread\n   * @type {?(NewsChannel|TextChannel|ForumChannel)}\n   * @readonly\n   */\n  get parent() {\n    return this.guild.channels.resolve(this.parentId);\n  }\n\n  /**\n   * Makes the client user join the thread.\n   * @returns {Promise<ThreadChannel>}\n   */\n  async join() {\n    await this.members.add('@me');\n    return this;\n  }\n\n  /**\n   * Makes the client user leave the thread.\n   * @returns {Promise<ThreadChannel>}\n   */\n  async leave() {\n    await this.members.remove('@me');\n    return this;\n  }\n\n  /**\n   * Gets the overall set of permissions for a member or role in this thread's parent channel, taking overwrites into\n   * account.\n   * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for\n   * @param {boolean} [checkAdmin=true] Whether having the {@link PermissionFlagsBits.Administrator} permission\n   * will return all permissions\n   * @returns {?Readonly<PermissionsBitField>}\n   */\n  permissionsFor(memberOrRole, checkAdmin) {\n    return this.parent?.permissionsFor(memberOrRole, checkAdmin) ?? null;\n  }\n\n  /**\n   * Fetches the owner of this thread. If the thread member object isn't needed,\n   * use {@link ThreadChannel#ownerId} instead.\n   * @param {BaseFetchOptions} [options] The options for fetching the member\n   * @returns {Promise<?ThreadMember>}\n   */\n  async fetchOwner({\n    cache = true,\n    force = false\n  } = {}) {\n    if (!force) {\n      const existing = this.members.cache.get(this.ownerId);\n      if (existing) return existing;\n    }\n\n    // We cannot fetch a single thread member, as of this commit's date, Discord API responds with 405\n    const members = await this.members.fetch({\n      cache\n    });\n    return members.get(this.ownerId) ?? null;\n  }\n\n  /**\n   * Fetches the message that started this thread, if any.\n   * <info>The `Promise` will reject if the original message in a forum post is deleted\n   * or when the original message in the parent channel is deleted.\n   * If you just need the id of that message, use {@link ThreadChannel#id} instead.</info>\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<Message<true>|null>}\n   */\n  // eslint-disable-next-line require-await\n  async fetchStarterMessage(options) {\n    const channel = this.parent?.type === ChannelType.GuildForum ? this : this.parent;\n    return channel?.messages.fetch({\n      message: this.id,\n      ...options\n    }) ?? null;\n  }\n\n  /**\n   * The options used to edit a thread channel\n   * @typedef {Object} ThreadEditOptions\n   * @property {string} [name] The new name for the thread\n   * @property {boolean} [archived] Whether the thread is archived\n   * @property {ThreadAutoArchiveDuration} [autoArchiveDuration] The amount of time after which the thread\n   * should automatically archive in case of no recent activity\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the thread in seconds\n   * @property {boolean} [locked] Whether the thread is locked\n   * @property {boolean} [invitable] Whether non-moderators can add other non-moderators to a thread\n   * <info>Can only be edited on {@link ChannelType.PrivateThread}</info>\n   * @property {Snowflake[]} [appliedTags] The tags to apply to the thread\n   * @property {ChannelFlagsResolvable} [flags] The flags to set on the channel\n   * @property {string} [reason] Reason for editing the thread\n   */\n\n  /**\n   * Edits this thread.\n   * @param {ThreadEditOptions} options The options to provide\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Edit a thread\n   * thread.edit({ name: 'new-thread' })\n   *   .then(editedThread => console.log(editedThread))\n   *   .catch(console.error);\n   */\n  async edit(options) {\n    const newData = await this.client.rest.patch(Routes.channel(this.id), {\n      body: {\n        name: (options.name ?? this.name).trim(),\n        archived: options.archived,\n        auto_archive_duration: options.autoArchiveDuration,\n        rate_limit_per_user: options.rateLimitPerUser,\n        locked: options.locked,\n        invitable: this.type === ChannelType.PrivateThread ? options.invitable : undefined,\n        applied_tags: options.appliedTags,\n        flags: 'flags' in options ? ChannelFlagsBitField.resolve(options.flags) : undefined\n      },\n      reason: options.reason\n    });\n    return this.client.actions.ChannelUpdate.handle(newData).updated;\n  }\n\n  /**\n   * Sets whether the thread is archived.\n   * @param {boolean} [archived=true] Whether the thread is archived\n   * @param {string} [reason] Reason for archiving or unarchiving\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Archive the thread\n   * thread.setArchived(true)\n   *   .then(newThread => console.log(`Thread is now ${newThread.archived ? 'archived' : 'active'}`))\n   *   .catch(console.error);\n   */\n  setArchived(archived = true, reason) {\n    return this.edit({\n      archived,\n      reason\n    });\n  }\n\n  /**\n   * Sets the duration after which the thread will automatically archive in case of no recent activity.\n   * @param {ThreadAutoArchiveDuration} autoArchiveDuration The amount of time after which the thread\n   * should automatically archive in case of no recent activity\n   * @param {string} [reason] Reason for changing the auto archive duration\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Set the thread's auto archive time to 1 hour\n   * thread.setAutoArchiveDuration(ThreadAutoArchiveDuration.OneHour)\n   *   .then(newThread => {\n   *     console.log(`Thread will now archive after ${newThread.autoArchiveDuration} minutes of inactivity`);\n   *    });\n   *   .catch(console.error);\n   */\n  setAutoArchiveDuration(autoArchiveDuration, reason) {\n    return this.edit({\n      autoArchiveDuration,\n      reason\n    });\n  }\n\n  /**\n   * Sets whether members without the {@link PermissionFlagsBits.ManageThreads} permission\n   * can invite other members to this thread.\n   * @param {boolean} [invitable=true] Whether non-moderators can invite non-moderators to this thread\n   * @param {string} [reason] Reason for changing invite\n   * @returns {Promise<ThreadChannel>}\n   */\n  setInvitable(invitable = true, reason) {\n    if (this.type !== ChannelType.PrivateThread) {\n      return Promise.reject(new DiscordjsRangeError(ErrorCodes.ThreadInvitableType, this.type));\n    }\n    return this.edit({\n      invitable,\n      reason\n    });\n  }\n\n  /**\n   * Sets whether the thread can be **unarchived** by anyone with the\n   * {@link PermissionFlagsBits.SendMessages} permission. When a thread is locked, only members with the\n   * {@link PermissionFlagsBits.ManageThreads} permission can unarchive it.\n   * @param {boolean} [locked=true] Whether the thread is locked\n   * @param {string} [reason] Reason for locking or unlocking the thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Set the thread to locked\n   * thread.setLocked(true)\n   *   .then(newThread => console.log(`Thread is now ${newThread.locked ? 'locked' : 'unlocked'}`))\n   *   .catch(console.error);\n   */\n  setLocked(locked = true, reason) {\n    return this.edit({\n      locked,\n      reason\n    });\n  }\n\n  /**\n   * Sets a new name for this thread.\n   * @param {string} name The new name for the thread\n   * @param {string} [reason] Reason for changing the thread's name\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Change the thread's name\n   * thread.setName('not_general')\n   *   .then(newThread => console.log(`Thread's new name is ${newThread.name}`))\n   *   .catch(console.error);\n   */\n  setName(name, reason) {\n    return this.edit({\n      name,\n      reason\n    });\n  }\n\n  /**\n   * Sets the rate limit per user (slowmode) for this thread.\n   * @param {number} rateLimitPerUser The new rate limit in seconds\n   * @param {string} [reason] Reason for changing the thread's rate limit\n   * @returns {Promise<ThreadChannel>}\n   */\n  setRateLimitPerUser(rateLimitPerUser, reason) {\n    return this.edit({\n      rateLimitPerUser,\n      reason\n    });\n  }\n\n  /**\n   * Set the applied tags for this channel (only applicable to forum threads)\n   * @param {Snowflake[]} appliedTags The tags to set for this channel\n   * @param {string} [reason] Reason for changing the thread's applied tags\n   * @returns {Promise<ThreadChannel>}\n   */\n  setAppliedTags(appliedTags, reason) {\n    return this.edit({\n      appliedTags,\n      reason\n    });\n  }\n\n  /**\n   * Pins this thread from the forum channel (only applicable to forum threads).\n   * @param {string} [reason] Reason for pinning\n   * @returns {Promise<ThreadChannel>}\n   */\n  pin(reason) {\n    return this.edit({\n      flags: this.flags.add(ChannelFlags.Pinned),\n      reason\n    });\n  }\n\n  /**\n   * Unpins this thread from the forum channel (only applicable to forum threads).\n   * @param {string} [reason] Reason for unpinning\n   * @returns {Promise<ThreadChannel>}\n   */\n  unpin(reason) {\n    return this.edit({\n      flags: this.flags.remove(ChannelFlags.Pinned),\n      reason\n    });\n  }\n\n  /**\n   * Whether the client user is a member of the thread.\n   * @type {boolean}\n   * @readonly\n   */\n  get joined() {\n    return this.members.cache.has(this.client.user?.id);\n  }\n\n  /**\n   * Whether the thread is editable by the client user (name, archived, autoArchiveDuration)\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    return this.ownerId === this.client.user.id && (this.type !== ChannelType.PrivateThread || this.joined) || this.manageable;\n  }\n\n  /**\n   * Whether the thread is joinable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get joinable() {\n    return !this.archived && !this.joined && this.permissionsFor(this.client.user)?.has(this.type === ChannelType.PrivateThread ? PermissionFlagsBits.ManageThreads : PermissionFlagsBits.ViewChannel, false);\n  }\n\n  /**\n   * Whether the thread is manageable by the client user, for deleting or editing rateLimitPerUser or locked.\n   * @type {boolean}\n   * @readonly\n   */\n  get manageable() {\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    // This flag allows managing even if timed out\n    if (permissions.has(PermissionFlagsBits.Administrator, false)) return true;\n    return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.ManageThreads, false);\n  }\n\n  /**\n   * Whether the thread is viewable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get viewable() {\n    if (this.client.user.id === this.guild.ownerId) return true;\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    return permissions.has(PermissionFlagsBits.ViewChannel, false);\n  }\n\n  /**\n   * Whether the client user can send messages in this thread\n   * @type {boolean}\n   * @readonly\n   */\n  get sendable() {\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    // This flag allows sending even if timed out\n    if (permissions.has(PermissionFlagsBits.Administrator, false)) return true;\n    return !(this.archived && this.locked && !this.manageable) && (this.type !== ChannelType.PrivateThread || this.joined || this.manageable) && permissions.has(PermissionFlagsBits.SendMessagesInThreads, false) && this.guild.members.me.communicationDisabledUntilTimestamp < Date.now();\n  }\n\n  /**\n   * Whether the thread is unarchivable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get unarchivable() {\n    return this.archived && this.sendable && (!this.locked || this.manageable);\n  }\n\n  /**\n   * Deletes this thread.\n   * @param {string} [reason] Reason for deleting this thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Delete the thread\n   * thread.delete('cleaning out old threads')\n   *   .then(deletedThread => console.log(deletedThread))\n   *   .catch(console.error);\n   */\n  async delete(reason) {\n    await this.guild.channels.delete(this.id, reason);\n    return this;\n  }\n\n  // These are here only for documentation purposes - they are implemented by TextBasedChannel\n  /* eslint-disable no-empty-function */\n  get lastMessage() {}\n  get lastPinAt() {}\n  send() {}\n  sendTyping() {}\n  createMessageCollector() {}\n  awaitMessages() {}\n  createMessageComponentCollector() {}\n  awaitMessageComponent() {}\n  bulkDelete() {}\n  // Doesn't work on Thread channels; setRateLimitPerUser() {}\n  // Doesn't work on Thread channels; setNSFW() {}\n}\nTextBasedChannel.applyToClass(ThreadChannel, true, ['fetchWebhooks', 'setRateLimitPerUser', 'setNSFW']);\nmodule.exports = ThreadChannel;","map":{"version":3,"names":["ChannelType","PermissionFlagsBits","Routes","ChannelFlags","require","BaseChannel","TextBasedChannel","DiscordjsRangeError","ErrorCodes","GuildMessageManager","ThreadMemberManager","ChannelFlagsBitField","ThreadChannel","constructor","guild","data","client","guildId","id","guild_id","messages","members","_patch","_add","message","name","parentId","parent_id","locked","thread_metadata","invitable","type","PrivateThread","archived","autoArchiveDuration","auto_archive_duration","archiveTimestamp","Date","parse","archive_timestamp","_createdTimestamp","create_timestamp","createdTimestamp","ownerId","owner_id","lastMessageId","last_message_id","lastPinTimestamp","last_pin_timestamp","rateLimitPerUser","rate_limit_per_user","messageCount","message_count","memberCount","member_count","totalMessageSent","total_message_sent","member","user","user_id","appliedTags","applied_tags","guildMembers","cache","mapValues","guildMember","archivedAt","createdAt","parent","channels","resolve","join","add","leave","remove","permissionsFor","memberOrRole","checkAdmin","fetchOwner","force","existing","get","fetch","fetchStarterMessage","options","channel","GuildForum","edit","newData","rest","patch","body","trim","undefined","flags","reason","actions","ChannelUpdate","handle","updated","setArchived","setAutoArchiveDuration","setInvitable","Promise","reject","ThreadInvitableType","setLocked","setName","setRateLimitPerUser","setAppliedTags","pin","Pinned","unpin","joined","has","editable","manageable","joinable","ManageThreads","ViewChannel","permissions","Administrator","me","communicationDisabledUntilTimestamp","now","viewable","sendable","SendMessagesInThreads","unarchivable","delete","lastMessage","lastPinAt","send","sendTyping","createMessageCollector","awaitMessages","createMessageComponentCollector","awaitMessageComponent","bulkDelete","applyToClass","module","exports"],"sources":["C:/Users/hetit/node_modules/discord.js/src/structures/ThreadChannel.js"],"sourcesContent":["'use strict';\n\nconst { ChannelType, PermissionFlagsBits, Routes, ChannelFlags } = require('discord-api-types/v10');\nconst { BaseChannel } = require('./BaseChannel');\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\nconst { DiscordjsRangeError, ErrorCodes } = require('../errors');\nconst GuildMessageManager = require('../managers/GuildMessageManager');\nconst ThreadMemberManager = require('../managers/ThreadMemberManager');\nconst ChannelFlagsBitField = require('../util/ChannelFlagsBitField');\n\n/**\n * Represents a thread channel on Discord.\n * @extends {BaseChannel}\n * @implements {TextBasedChannel}\n */\nclass ThreadChannel extends BaseChannel {\n  constructor(guild, data, client) {\n    super(guild?.client ?? client, data, false);\n\n    /**\n     * The guild the thread is in\n     * @type {Guild}\n     */\n    this.guild = guild;\n\n    /**\n     * The id of the guild the channel is in\n     * @type {Snowflake}\n     */\n    this.guildId = guild?.id ?? data.guild_id;\n\n    /**\n     * A manager of the messages sent to this thread\n     * @type {GuildMessageManager}\n     */\n    this.messages = new GuildMessageManager(this);\n\n    /**\n     * A manager of the members that are part of this thread\n     * @type {ThreadMemberManager}\n     */\n    this.members = new ThreadMemberManager(this);\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if ('message' in data) this.messages._add(data.message);\n\n    if ('name' in data) {\n      /**\n       * The name of the thread\n       * @type {string}\n       */\n      this.name = data.name;\n    }\n\n    if ('guild_id' in data) {\n      this.guildId = data.guild_id;\n    }\n\n    if ('parent_id' in data) {\n      /**\n       * The id of the parent channel of this thread\n       * @type {?Snowflake}\n       */\n      this.parentId = data.parent_id;\n    } else {\n      this.parentId ??= null;\n    }\n\n    if ('thread_metadata' in data) {\n      /**\n       * Whether the thread is locked\n       * @type {?boolean}\n       */\n      this.locked = data.thread_metadata.locked ?? false;\n\n      /**\n       * Whether members without the {@link PermissionFlagsBits.ManageThreads} permission\n       * can invite other members to this thread.\n       * <info>This property is always `null` in public threads.</info>\n       * @type {?boolean}\n       */\n      this.invitable = this.type === ChannelType.PrivateThread ? data.thread_metadata.invitable ?? false : null;\n\n      /**\n       * Whether the thread is archived\n       * @type {?boolean}\n       */\n      this.archived = data.thread_metadata.archived;\n\n      /**\n       * The amount of time (in minutes) after which the thread will automatically archive in case of no recent activity\n       * @type {?ThreadAutoArchiveDuration}\n       */\n      this.autoArchiveDuration = data.thread_metadata.auto_archive_duration;\n\n      /**\n       * The timestamp when the thread's archive status was last changed\n       * <info>If the thread was never archived or unarchived, this is the timestamp at which the thread was\n       * created</info>\n       * @type {?number}\n       */\n      this.archiveTimestamp = Date.parse(data.thread_metadata.archive_timestamp);\n\n      if ('create_timestamp' in data.thread_metadata) {\n        // Note: this is needed because we can't assign directly to getters\n        this._createdTimestamp = Date.parse(data.thread_metadata.create_timestamp);\n      }\n    } else {\n      this.locked ??= null;\n      this.archived ??= null;\n      this.autoArchiveDuration ??= null;\n      this.archiveTimestamp ??= null;\n      this.invitable ??= null;\n    }\n\n    this._createdTimestamp ??= this.type === ChannelType.PrivateThread ? super.createdTimestamp : null;\n\n    if ('owner_id' in data) {\n      /**\n       * The id of the member who created this thread\n       * @type {?Snowflake}\n       */\n      this.ownerId = data.owner_id;\n    } else {\n      this.ownerId ??= null;\n    }\n\n    if ('last_message_id' in data) {\n      /**\n       * The last message id sent in this thread, if one was sent\n       * @type {?Snowflake}\n       */\n      this.lastMessageId = data.last_message_id;\n    } else {\n      this.lastMessageId ??= null;\n    }\n\n    if ('last_pin_timestamp' in data) {\n      /**\n       * The timestamp when the last pinned message was pinned, if there was one\n       * @type {?number}\n       */\n      this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;\n    } else {\n      this.lastPinTimestamp ??= null;\n    }\n\n    if ('rate_limit_per_user' in data) {\n      /**\n       * The rate limit per user (slowmode) for this thread in seconds\n       * @type {?number}\n       */\n      this.rateLimitPerUser = data.rate_limit_per_user ?? 0;\n    } else {\n      this.rateLimitPerUser ??= null;\n    }\n\n    if ('message_count' in data) {\n      /**\n       * The approximate count of messages in this thread\n       * <info>Threads created before July 1, 2022 may have an inaccurate count.\n       * If you need an approximate value higher than that, use `ThreadChannel#messages.cache.size`</info>\n       * @type {?number}\n       */\n      this.messageCount = data.message_count;\n    } else {\n      this.messageCount ??= null;\n    }\n\n    if ('member_count' in data) {\n      /**\n       * The approximate count of users in this thread\n       * <info>This stops counting at 50. If you need an approximate value higher than that, use\n       * `ThreadChannel#members.cache.size`</info>\n       * @type {?number}\n       */\n      this.memberCount = data.member_count;\n    } else {\n      this.memberCount ??= null;\n    }\n\n    if ('total_message_sent' in data) {\n      /**\n       * The number of messages ever sent in a thread, similar to {@link ThreadChannel#messageCount} except it\n       * will not decrement whenever a message is deleted\n       * @type {?number}\n       */\n      this.totalMessageSent = data.total_message_sent;\n    } else {\n      this.totalMessageSent ??= null;\n    }\n\n    if (data.member && this.client.user) this.members._add({ user_id: this.client.user.id, ...data.member });\n    if (data.messages) for (const message of data.messages) this.messages._add(message);\n\n    if ('applied_tags' in data) {\n      /**\n       * The tags applied to this thread\n       * @type {Snowflake[]}\n       */\n      this.appliedTags = data.applied_tags;\n    } else {\n      this.appliedTags ??= [];\n    }\n  }\n\n  /**\n   * The timestamp when this thread was created. This isn't available for threads\n   * created before 2022-01-09\n   * @type {?number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return this._createdTimestamp;\n  }\n\n  /**\n   * A collection of associated guild member objects of this thread's members\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get guildMembers() {\n    return this.members.cache.mapValues(member => member.guildMember);\n  }\n\n  /**\n   * The time at which this thread's archive status was last changed\n   * <info>If the thread was never archived or unarchived, this is the time at which the thread was created</info>\n   * @type {?Date}\n   * @readonly\n   */\n  get archivedAt() {\n    return this.archiveTimestamp && new Date(this.archiveTimestamp);\n  }\n\n  /**\n   * The time the thread was created at\n   * @type {?Date}\n   * @readonly\n   */\n  get createdAt() {\n    return this.createdTimestamp && new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The parent channel of this thread\n   * @type {?(NewsChannel|TextChannel|ForumChannel)}\n   * @readonly\n   */\n  get parent() {\n    return this.guild.channels.resolve(this.parentId);\n  }\n\n  /**\n   * Makes the client user join the thread.\n   * @returns {Promise<ThreadChannel>}\n   */\n  async join() {\n    await this.members.add('@me');\n    return this;\n  }\n\n  /**\n   * Makes the client user leave the thread.\n   * @returns {Promise<ThreadChannel>}\n   */\n  async leave() {\n    await this.members.remove('@me');\n    return this;\n  }\n\n  /**\n   * Gets the overall set of permissions for a member or role in this thread's parent channel, taking overwrites into\n   * account.\n   * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for\n   * @param {boolean} [checkAdmin=true] Whether having the {@link PermissionFlagsBits.Administrator} permission\n   * will return all permissions\n   * @returns {?Readonly<PermissionsBitField>}\n   */\n  permissionsFor(memberOrRole, checkAdmin) {\n    return this.parent?.permissionsFor(memberOrRole, checkAdmin) ?? null;\n  }\n\n  /**\n   * Fetches the owner of this thread. If the thread member object isn't needed,\n   * use {@link ThreadChannel#ownerId} instead.\n   * @param {BaseFetchOptions} [options] The options for fetching the member\n   * @returns {Promise<?ThreadMember>}\n   */\n  async fetchOwner({ cache = true, force = false } = {}) {\n    if (!force) {\n      const existing = this.members.cache.get(this.ownerId);\n      if (existing) return existing;\n    }\n\n    // We cannot fetch a single thread member, as of this commit's date, Discord API responds with 405\n    const members = await this.members.fetch({ cache });\n    return members.get(this.ownerId) ?? null;\n  }\n\n  /**\n   * Fetches the message that started this thread, if any.\n   * <info>The `Promise` will reject if the original message in a forum post is deleted\n   * or when the original message in the parent channel is deleted.\n   * If you just need the id of that message, use {@link ThreadChannel#id} instead.</info>\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<Message<true>|null>}\n   */\n  // eslint-disable-next-line require-await\n  async fetchStarterMessage(options) {\n    const channel = this.parent?.type === ChannelType.GuildForum ? this : this.parent;\n    return channel?.messages.fetch({ message: this.id, ...options }) ?? null;\n  }\n\n  /**\n   * The options used to edit a thread channel\n   * @typedef {Object} ThreadEditOptions\n   * @property {string} [name] The new name for the thread\n   * @property {boolean} [archived] Whether the thread is archived\n   * @property {ThreadAutoArchiveDuration} [autoArchiveDuration] The amount of time after which the thread\n   * should automatically archive in case of no recent activity\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the thread in seconds\n   * @property {boolean} [locked] Whether the thread is locked\n   * @property {boolean} [invitable] Whether non-moderators can add other non-moderators to a thread\n   * <info>Can only be edited on {@link ChannelType.PrivateThread}</info>\n   * @property {Snowflake[]} [appliedTags] The tags to apply to the thread\n   * @property {ChannelFlagsResolvable} [flags] The flags to set on the channel\n   * @property {string} [reason] Reason for editing the thread\n   */\n\n  /**\n   * Edits this thread.\n   * @param {ThreadEditOptions} options The options to provide\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Edit a thread\n   * thread.edit({ name: 'new-thread' })\n   *   .then(editedThread => console.log(editedThread))\n   *   .catch(console.error);\n   */\n  async edit(options) {\n    const newData = await this.client.rest.patch(Routes.channel(this.id), {\n      body: {\n        name: (options.name ?? this.name).trim(),\n        archived: options.archived,\n        auto_archive_duration: options.autoArchiveDuration,\n        rate_limit_per_user: options.rateLimitPerUser,\n        locked: options.locked,\n        invitable: this.type === ChannelType.PrivateThread ? options.invitable : undefined,\n        applied_tags: options.appliedTags,\n        flags: 'flags' in options ? ChannelFlagsBitField.resolve(options.flags) : undefined,\n      },\n      reason: options.reason,\n    });\n\n    return this.client.actions.ChannelUpdate.handle(newData).updated;\n  }\n\n  /**\n   * Sets whether the thread is archived.\n   * @param {boolean} [archived=true] Whether the thread is archived\n   * @param {string} [reason] Reason for archiving or unarchiving\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Archive the thread\n   * thread.setArchived(true)\n   *   .then(newThread => console.log(`Thread is now ${newThread.archived ? 'archived' : 'active'}`))\n   *   .catch(console.error);\n   */\n  setArchived(archived = true, reason) {\n    return this.edit({ archived, reason });\n  }\n\n  /**\n   * Sets the duration after which the thread will automatically archive in case of no recent activity.\n   * @param {ThreadAutoArchiveDuration} autoArchiveDuration The amount of time after which the thread\n   * should automatically archive in case of no recent activity\n   * @param {string} [reason] Reason for changing the auto archive duration\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Set the thread's auto archive time to 1 hour\n   * thread.setAutoArchiveDuration(ThreadAutoArchiveDuration.OneHour)\n   *   .then(newThread => {\n   *     console.log(`Thread will now archive after ${newThread.autoArchiveDuration} minutes of inactivity`);\n   *    });\n   *   .catch(console.error);\n   */\n  setAutoArchiveDuration(autoArchiveDuration, reason) {\n    return this.edit({ autoArchiveDuration, reason });\n  }\n\n  /**\n   * Sets whether members without the {@link PermissionFlagsBits.ManageThreads} permission\n   * can invite other members to this thread.\n   * @param {boolean} [invitable=true] Whether non-moderators can invite non-moderators to this thread\n   * @param {string} [reason] Reason for changing invite\n   * @returns {Promise<ThreadChannel>}\n   */\n  setInvitable(invitable = true, reason) {\n    if (this.type !== ChannelType.PrivateThread) {\n      return Promise.reject(new DiscordjsRangeError(ErrorCodes.ThreadInvitableType, this.type));\n    }\n    return this.edit({ invitable, reason });\n  }\n\n  /**\n   * Sets whether the thread can be **unarchived** by anyone with the\n   * {@link PermissionFlagsBits.SendMessages} permission. When a thread is locked, only members with the\n   * {@link PermissionFlagsBits.ManageThreads} permission can unarchive it.\n   * @param {boolean} [locked=true] Whether the thread is locked\n   * @param {string} [reason] Reason for locking or unlocking the thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Set the thread to locked\n   * thread.setLocked(true)\n   *   .then(newThread => console.log(`Thread is now ${newThread.locked ? 'locked' : 'unlocked'}`))\n   *   .catch(console.error);\n   */\n  setLocked(locked = true, reason) {\n    return this.edit({ locked, reason });\n  }\n\n  /**\n   * Sets a new name for this thread.\n   * @param {string} name The new name for the thread\n   * @param {string} [reason] Reason for changing the thread's name\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Change the thread's name\n   * thread.setName('not_general')\n   *   .then(newThread => console.log(`Thread's new name is ${newThread.name}`))\n   *   .catch(console.error);\n   */\n  setName(name, reason) {\n    return this.edit({ name, reason });\n  }\n\n  /**\n   * Sets the rate limit per user (slowmode) for this thread.\n   * @param {number} rateLimitPerUser The new rate limit in seconds\n   * @param {string} [reason] Reason for changing the thread's rate limit\n   * @returns {Promise<ThreadChannel>}\n   */\n  setRateLimitPerUser(rateLimitPerUser, reason) {\n    return this.edit({ rateLimitPerUser, reason });\n  }\n\n  /**\n   * Set the applied tags for this channel (only applicable to forum threads)\n   * @param {Snowflake[]} appliedTags The tags to set for this channel\n   * @param {string} [reason] Reason for changing the thread's applied tags\n   * @returns {Promise<ThreadChannel>}\n   */\n  setAppliedTags(appliedTags, reason) {\n    return this.edit({ appliedTags, reason });\n  }\n\n  /**\n   * Pins this thread from the forum channel (only applicable to forum threads).\n   * @param {string} [reason] Reason for pinning\n   * @returns {Promise<ThreadChannel>}\n   */\n  pin(reason) {\n    return this.edit({ flags: this.flags.add(ChannelFlags.Pinned), reason });\n  }\n\n  /**\n   * Unpins this thread from the forum channel (only applicable to forum threads).\n   * @param {string} [reason] Reason for unpinning\n   * @returns {Promise<ThreadChannel>}\n   */\n  unpin(reason) {\n    return this.edit({ flags: this.flags.remove(ChannelFlags.Pinned), reason });\n  }\n\n  /**\n   * Whether the client user is a member of the thread.\n   * @type {boolean}\n   * @readonly\n   */\n  get joined() {\n    return this.members.cache.has(this.client.user?.id);\n  }\n\n  /**\n   * Whether the thread is editable by the client user (name, archived, autoArchiveDuration)\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    return (\n      (this.ownerId === this.client.user.id && (this.type !== ChannelType.PrivateThread || this.joined)) ||\n      this.manageable\n    );\n  }\n\n  /**\n   * Whether the thread is joinable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get joinable() {\n    return (\n      !this.archived &&\n      !this.joined &&\n      this.permissionsFor(this.client.user)?.has(\n        this.type === ChannelType.PrivateThread ? PermissionFlagsBits.ManageThreads : PermissionFlagsBits.ViewChannel,\n        false,\n      )\n    );\n  }\n\n  /**\n   * Whether the thread is manageable by the client user, for deleting or editing rateLimitPerUser or locked.\n   * @type {boolean}\n   * @readonly\n   */\n  get manageable() {\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    // This flag allows managing even if timed out\n    if (permissions.has(PermissionFlagsBits.Administrator, false)) return true;\n\n    return (\n      this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() &&\n      permissions.has(PermissionFlagsBits.ManageThreads, false)\n    );\n  }\n\n  /**\n   * Whether the thread is viewable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get viewable() {\n    if (this.client.user.id === this.guild.ownerId) return true;\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    return permissions.has(PermissionFlagsBits.ViewChannel, false);\n  }\n\n  /**\n   * Whether the client user can send messages in this thread\n   * @type {boolean}\n   * @readonly\n   */\n  get sendable() {\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    // This flag allows sending even if timed out\n    if (permissions.has(PermissionFlagsBits.Administrator, false)) return true;\n\n    return (\n      !(this.archived && this.locked && !this.manageable) &&\n      (this.type !== ChannelType.PrivateThread || this.joined || this.manageable) &&\n      permissions.has(PermissionFlagsBits.SendMessagesInThreads, false) &&\n      this.guild.members.me.communicationDisabledUntilTimestamp < Date.now()\n    );\n  }\n\n  /**\n   * Whether the thread is unarchivable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get unarchivable() {\n    return this.archived && this.sendable && (!this.locked || this.manageable);\n  }\n\n  /**\n   * Deletes this thread.\n   * @param {string} [reason] Reason for deleting this thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Delete the thread\n   * thread.delete('cleaning out old threads')\n   *   .then(deletedThread => console.log(deletedThread))\n   *   .catch(console.error);\n   */\n  async delete(reason) {\n    await this.guild.channels.delete(this.id, reason);\n    return this;\n  }\n\n  // These are here only for documentation purposes - they are implemented by TextBasedChannel\n  /* eslint-disable no-empty-function */\n  get lastMessage() {}\n  get lastPinAt() {}\n  send() {}\n  sendTyping() {}\n  createMessageCollector() {}\n  awaitMessages() {}\n  createMessageComponentCollector() {}\n  awaitMessageComponent() {}\n  bulkDelete() {}\n  // Doesn't work on Thread channels; setRateLimitPerUser() {}\n  // Doesn't work on Thread channels; setNSFW() {}\n}\n\nTextBasedChannel.applyToClass(ThreadChannel, true, ['fetchWebhooks', 'setRateLimitPerUser', 'setNSFW']);\n\nmodule.exports = ThreadChannel;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}