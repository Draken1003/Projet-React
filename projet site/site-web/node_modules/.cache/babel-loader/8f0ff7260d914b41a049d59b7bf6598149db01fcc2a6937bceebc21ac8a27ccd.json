{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createComplexNode = exports.createNode = exports.merge = void 0;\nconst createMatch = leaf => ({\n  typename: leaf.typename,\n  mime: leaf.info.mime,\n  extension: leaf.info.extension\n});\nconst isMatchingNode = (tree, path) => tree && path.length === 0;\nconst head = arr => arr[0];\nconst tail = arr => arr.slice(1, arr.length);\nconst merge = (node, tree) => {\n  if (node.bytes.length === 0) return tree;\n  const currentByte = head(node.bytes); // 0\n  const path = tail(node.bytes); // [1,2]\n  const currentTree = tree.bytes[currentByte];\n  // traversed to end. Just add key to leaf.\n  if (isMatchingNode(currentTree, path)) {\n    const matchingNode = tree.bytes[currentByte];\n    tree.bytes[currentByte] = {\n      ...matchingNode,\n      matches: [...(matchingNode.matches ? matchingNode.matches : []), createMatch(node)]\n    };\n    return tree;\n  }\n  // Path exists already, Merge subtree\n  if (tree.bytes[currentByte]) {\n    tree.bytes[currentByte] = exports.merge(exports.createNode(node.typename, path, node.info), tree.bytes[currentByte]);\n    return tree;\n  }\n  // Tree did not exist before\n  if (!tree.bytes[currentByte]) {\n    tree.bytes[currentByte] = {\n      ...tree.bytes[currentByte],\n      ...exports.createComplexNode(node.typename, path, node.info)\n    };\n  }\n  return tree;\n};\nexports.merge = merge;\nconst createNode = (typename, bytes, info) => {\n  return {\n    typename,\n    bytes,\n    info: info ? info : {}\n  };\n};\nexports.createNode = createNode;\nconst createComplexNode = (typename, bytes, info) => {\n  let obj = {\n    bytes: {},\n    matches: undefined\n  };\n  const currentKey = head(bytes); // 0\n  const path = tail(bytes); // [1,2]\n  if (bytes.length === 0) {\n    return {\n      matches: [createMatch({\n        typename: typename,\n        info: info ? {\n          extension: info.extension,\n          mime: info.mime\n        } : {}\n      })],\n      bytes: {}\n    };\n  }\n  obj.bytes[currentKey] = exports.createComplexNode(typename, path, info);\n  return obj;\n};\nexports.createComplexNode = createComplexNode;","map":{"version":3,"names":["Object","defineProperty","exports","value","createComplexNode","createNode","merge","createMatch","leaf","typename","mime","info","extension","isMatchingNode","tree","path","length","head","arr","tail","slice","node","bytes","currentByte","currentTree","matchingNode","matches","obj","undefined","currentKey"],"sources":["C:/Users/hetit/node_modules/magic-bytes.js/dist/model/tree.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createComplexNode = exports.createNode = exports.merge = void 0;\nconst createMatch = (leaf) => ({\n    typename: leaf.typename,\n    mime: leaf.info.mime,\n    extension: leaf.info.extension,\n});\nconst isMatchingNode = (tree, path) => tree && path.length === 0;\nconst head = (arr) => arr[0];\nconst tail = (arr) => arr.slice(1, arr.length);\nconst merge = (node, tree) => {\n    if (node.bytes.length === 0)\n        return tree;\n    const currentByte = head(node.bytes); // 0\n    const path = tail(node.bytes); // [1,2]\n    const currentTree = tree.bytes[currentByte];\n    // traversed to end. Just add key to leaf.\n    if (isMatchingNode(currentTree, path)) {\n        const matchingNode = tree.bytes[currentByte];\n        tree.bytes[currentByte] = {\n            ...matchingNode,\n            matches: [\n                ...(matchingNode.matches ? matchingNode.matches : []),\n                createMatch(node),\n            ],\n        };\n        return tree;\n    }\n    // Path exists already, Merge subtree\n    if (tree.bytes[currentByte]) {\n        tree.bytes[currentByte] = exports.merge(exports.createNode(node.typename, path, node.info), tree.bytes[currentByte]);\n        return tree;\n    }\n    // Tree did not exist before\n    if (!tree.bytes[currentByte]) {\n        tree.bytes[currentByte] = {\n            ...tree.bytes[currentByte],\n            ...exports.createComplexNode(node.typename, path, node.info),\n        };\n    }\n    return tree;\n};\nexports.merge = merge;\nconst createNode = (typename, bytes, info) => {\n    return { typename, bytes, info: info ? info : {} };\n};\nexports.createNode = createNode;\nconst createComplexNode = (typename, bytes, info) => {\n    let obj = {\n        bytes: {},\n        matches: undefined,\n    };\n    const currentKey = head(bytes); // 0\n    const path = tail(bytes); // [1,2]\n    if (bytes.length === 0) {\n        return {\n            matches: [\n                createMatch({\n                    typename: typename,\n                    info: info ? { extension: info.extension, mime: info.mime } : {},\n                }),\n            ],\n            bytes: {},\n        };\n    }\n    obj.bytes[currentKey] = exports.createComplexNode(typename, path, info);\n    return obj;\n};\nexports.createComplexNode = createComplexNode;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}