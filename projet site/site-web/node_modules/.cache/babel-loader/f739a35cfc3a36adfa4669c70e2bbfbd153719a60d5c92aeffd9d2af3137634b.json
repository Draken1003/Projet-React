{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.filetypeextension = exports.filetypemime = exports.filetypename = exports.filetypeinfo = void 0;\nconst pattern_tree_1 = __importDefault(require(\"./model/pattern-tree\"));\nconst toHex_1 = require(\"./model/toHex\");\nconst patternTree = pattern_tree_1.default();\nconst filetypeinfo = bytes => {\n  let tree = patternTree;\n  for (const k of Object.keys(tree.offset)) {\n    const offset = toHex_1.fromHex(k);\n    const offsetExceedsFile = offset >= bytes.length;\n    if (offsetExceedsFile) {\n      continue;\n    }\n    const node = patternTree.offset[k];\n    const guessed = walkTree(offset, bytes, node);\n    if (guessed.length > 0) {\n      return guessed;\n    }\n  }\n  if (tree.noOffset === null) {\n    return [];\n  }\n  return walkTree(0, bytes, tree.noOffset);\n};\nexports.filetypeinfo = filetypeinfo;\nconst walkTree = (index, bytes, node) => {\n  let step = node;\n  let guessFile = [];\n  while (true) {\n    const currentByte = toHex_1.toHex(bytes[index]);\n    if (step.bytes[\"?\"] && !step.bytes[currentByte]) {\n      step = step.bytes[\"?\"];\n    } else {\n      step = step.bytes[currentByte];\n    }\n    if (!step) {\n      return guessFile;\n    }\n    if (step && step.matches) {\n      guessFile = step.matches.slice(0);\n    }\n    index += 1;\n  }\n};\nexports.default = exports.filetypeinfo;\nconst filetypename = bytes => exports.filetypeinfo(bytes).map(e => e.typename);\nexports.filetypename = filetypename;\nconst filetypemime = bytes => exports.filetypeinfo(bytes).map(e => e.mime ? e.mime : \"\");\nexports.filetypemime = filetypemime;\nconst filetypeextension = bytes => exports.filetypeinfo(bytes).map(e => e.extension ? e.extension : \"\");\nexports.filetypeextension = filetypeextension;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","filetypeextension","filetypemime","filetypename","filetypeinfo","pattern_tree_1","require","toHex_1","patternTree","default","bytes","tree","k","keys","offset","fromHex","offsetExceedsFile","length","node","guessed","walkTree","noOffset","index","step","guessFile","currentByte","toHex","matches","slice","map","e","typename","mime","extension"],"sources":["C:/Users/hetit/node_modules/magic-bytes.js/dist/index.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.filetypeextension = exports.filetypemime = exports.filetypename = exports.filetypeinfo = void 0;\nconst pattern_tree_1 = __importDefault(require(\"./model/pattern-tree\"));\nconst toHex_1 = require(\"./model/toHex\");\nconst patternTree = pattern_tree_1.default();\nconst filetypeinfo = (bytes) => {\n    let tree = patternTree;\n    for (const k of Object.keys(tree.offset)) {\n        const offset = toHex_1.fromHex(k);\n        const offsetExceedsFile = offset >= bytes.length;\n        if (offsetExceedsFile) {\n            continue;\n        }\n        const node = patternTree.offset[k];\n        const guessed = walkTree(offset, bytes, node);\n        if (guessed.length > 0) {\n            return guessed;\n        }\n    }\n    if (tree.noOffset === null) {\n        return [];\n    }\n    return walkTree(0, bytes, tree.noOffset);\n};\nexports.filetypeinfo = filetypeinfo;\nconst walkTree = (index, bytes, node) => {\n    let step = node;\n    let guessFile = [];\n    while (true) {\n        const currentByte = toHex_1.toHex(bytes[index]);\n        if (step.bytes[\"?\"] && !step.bytes[currentByte]) {\n            step = step.bytes[\"?\"];\n        }\n        else {\n            step = step.bytes[currentByte];\n        }\n        if (!step) {\n            return guessFile;\n        }\n        if (step && step.matches) {\n            guessFile = step.matches.slice(0);\n        }\n        index += 1;\n    }\n};\nexports.default = exports.filetypeinfo;\nconst filetypename = (bytes) => exports.filetypeinfo(bytes).map((e) => e.typename);\nexports.filetypename = filetypename;\nconst filetypemime = (bytes) => exports.filetypeinfo(bytes).map((e) => (e.mime ? e.mime : \"\"));\nexports.filetypemime = filetypemime;\nconst filetypeextension = (bytes) => exports.filetypeinfo(bytes).map((e) => (e.extension ? e.extension : \"\"));\nexports.filetypeextension = filetypeextension;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}