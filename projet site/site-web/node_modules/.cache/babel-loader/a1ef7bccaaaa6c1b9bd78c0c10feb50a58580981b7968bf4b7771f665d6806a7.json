{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  makeURLSearchParams\n} = require('@discordjs/rest');\nconst {\n  GuildScheduledEventEntityType,\n  Routes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst {\n  DiscordjsTypeError,\n  DiscordjsError,\n  ErrorCodes\n} = require('../errors');\nconst {\n  GuildScheduledEvent\n} = require('../structures/GuildScheduledEvent');\nconst DataResolver = require('../util/DataResolver');\n\n/**\n * Manages API methods for GuildScheduledEvents and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildScheduledEventManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, GuildScheduledEvent, iterable);\n\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The cache of this manager\n   * @type {Collection<Snowflake, GuildScheduledEvent>}\n   * @name GuildScheduledEventManager#cache\n   */\n\n  /**\n   * Data that resolves to give a GuildScheduledEvent object. This can be:\n   * * A Snowflake\n   * * A GuildScheduledEvent object\n   * @typedef {Snowflake|GuildScheduledEvent} GuildScheduledEventResolvable\n   */\n\n  /**\n   * Options used to create a guild scheduled event.\n   * @typedef {Object} GuildScheduledEventCreateOptions\n   * @property {string} name The name of the guild scheduled event\n   * @property {DateResolvable} scheduledStartTime The time to schedule the event at\n   * @property {DateResolvable} [scheduledEndTime] The time to end the event at\n   * <warn>This is required if `entityType` is {@link GuildScheduledEventEntityType.External}</warn>\n   * @property {GuildScheduledEventPrivacyLevel} privacyLevel The privacy level of the guild scheduled event\n   * @property {GuildScheduledEventEntityType} entityType The scheduled entity type of the event\n   * @property {string} [description] The description of the guild scheduled event\n   * @property {GuildVoiceChannelResolvable} [channel] The channel of the guild scheduled event\n   * <warn>This is required if `entityType` is {@link GuildScheduledEventEntityType.StageInstance} or\n   * {@link GuildScheduledEventEntityType.Voice}</warn>\n   * @property {GuildScheduledEventEntityMetadataOptions} [entityMetadata] The entity metadata of the\n   * guild scheduled event\n   * <warn>This is required if `entityType` is {@link GuildScheduledEventEntityType.External}</warn>\n   * @property {?(BufferResolvable|Base64Resolvable)} [image] The cover image of the guild scheduled event\n   * @property {string} [reason] The reason for creating the guild scheduled event\n   */\n\n  /**\n   * Options used to set entity metadata of a guild scheduled event.\n   * @typedef {Object} GuildScheduledEventEntityMetadataOptions\n   * @property {string} [location] The location of the guild scheduled event\n   * <warn>This is required if `entityType` is {@link GuildScheduledEventEntityType.External}</warn>\n   */\n\n  /**\n   * Creates a new guild scheduled event.\n   * @param {GuildScheduledEventCreateOptions} options Options for creating the guild scheduled event\n   * @returns {Promise<GuildScheduledEvent>}\n   */\n  async create(options) {\n    if (typeof options !== 'object') throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'options', 'object', true);\n    let {\n      privacyLevel,\n      entityType,\n      channel,\n      name,\n      scheduledStartTime,\n      description,\n      scheduledEndTime,\n      entityMetadata,\n      reason,\n      image\n    } = options;\n    let entity_metadata, channel_id;\n    if (entityType === GuildScheduledEventEntityType.External) {\n      channel_id = channel === undefined ? channel : null;\n      entity_metadata = {\n        location: entityMetadata?.location\n      };\n    } else {\n      channel_id = this.guild.channels.resolveId(channel);\n      if (!channel_id) throw new DiscordjsError(ErrorCodes.GuildVoiceChannelResolve);\n      entity_metadata = entityMetadata === undefined ? entityMetadata : null;\n    }\n    const data = await this.client.rest.post(Routes.guildScheduledEvents(this.guild.id), {\n      body: {\n        channel_id,\n        name,\n        privacy_level: privacyLevel,\n        scheduled_start_time: new Date(scheduledStartTime).toISOString(),\n        scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,\n        description,\n        entity_type: entityType,\n        entity_metadata,\n        image: image && (await DataResolver.resolveImage(image))\n      },\n      reason\n    });\n    return this._add(data);\n  }\n\n  /**\n   * Options used to fetch a single guild scheduled event from a guild.\n   * @typedef {BaseFetchOptions} FetchGuildScheduledEventOptions\n   * @property {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to fetch\n   * @property {boolean} [withUserCount=true] Whether to fetch the number of users subscribed to the scheduled event\n   */\n\n  /**\n   * Options used to fetch multiple guild scheduled events from a guild.\n   * @typedef {Object} FetchGuildScheduledEventsOptions\n   * @property {boolean} [cache] Whether or not to cache the fetched guild scheduled events\n   * @property {boolean} [withUserCount=true] Whether to fetch the number of users subscribed to each scheduled event\n   * should be returned\n   */\n\n  /**\n   * Obtains one or more guild scheduled events from Discord, or the guild cache if it's already available.\n   * @param {GuildScheduledEventResolvable|FetchGuildScheduledEventOptions|FetchGuildScheduledEventsOptions} [options]\n   * The id of the guild scheduled event or options\n   * @returns {Promise<GuildScheduledEvent|Collection<Snowflake, GuildScheduledEvent>>}\n   */\n  async fetch(options = {}) {\n    const id = this.resolveId(options.guildScheduledEvent ?? options);\n    if (id) {\n      if (!options.force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n      const data = await this.client.rest.get(Routes.guildScheduledEvent(this.guild.id, id), {\n        query: makeURLSearchParams({\n          with_user_count: options.withUserCount ?? true\n        })\n      });\n      return this._add(data, options.cache);\n    }\n    const data = await this.client.rest.get(Routes.guildScheduledEvents(this.guild.id), {\n      query: makeURLSearchParams({\n        with_user_count: options.withUserCount ?? true\n      })\n    });\n    return data.reduce((coll, rawGuildScheduledEventData) => coll.set(rawGuildScheduledEventData.id, this.guild.scheduledEvents._add(rawGuildScheduledEventData, options.cache)), new Collection());\n  }\n\n  /**\n   * Options used to edit a guild scheduled event.\n   * @typedef {Object} GuildScheduledEventEditOptions\n   * @property {string} [name] The name of the guild scheduled event\n   * @property {DateResolvable} [scheduledStartTime] The time to schedule the event at\n   * @property {DateResolvable} [scheduledEndTime] The time to end the event at\n   * @property {GuildScheduledEventPrivacyLevel} [privacyLevel] The privacy level of the guild scheduled event\n   * @property {GuildScheduledEventEntityType} [entityType] The scheduled entity type of the event\n   * @property {string} [description] The description of the guild scheduled event\n   * @property {?GuildVoiceChannelResolvable} [channel] The channel of the guild scheduled event\n   * @property {GuildScheduledEventStatus} [status] The status of the guild scheduled event\n   * @property {GuildScheduledEventEntityMetadataOptions} [entityMetadata] The entity metadata of the\n   * guild scheduled event\n   * <warn>This can be modified only if `entityType` of the `GuildScheduledEvent` to be edited is\n   * {@link GuildScheduledEventEntityType.External}</warn>\n   * @property {?(BufferResolvable|Base64Resolvable)} [image] The cover image of the guild scheduled event\n   * @property {string} [reason] The reason for editing the guild scheduled event\n   */\n\n  /**\n   * Edits a guild scheduled event.\n   * @param {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to edit\n   * @param {GuildScheduledEventEditOptions} options Options to edit the guild scheduled event\n   * @returns {Promise<GuildScheduledEvent>}\n   */\n  async edit(guildScheduledEvent, options) {\n    const guildScheduledEventId = this.resolveId(guildScheduledEvent);\n    if (!guildScheduledEventId) throw new DiscordjsError(ErrorCodes.GuildScheduledEventResolve);\n    if (typeof options !== 'object') throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'options', 'object', true);\n    let {\n      privacyLevel,\n      entityType,\n      channel,\n      status,\n      name,\n      scheduledStartTime,\n      description,\n      scheduledEndTime,\n      entityMetadata,\n      reason,\n      image\n    } = options;\n    let entity_metadata;\n    if (entityMetadata) {\n      entity_metadata = {\n        location: entityMetadata.location\n      };\n    }\n    const data = await this.client.rest.patch(Routes.guildScheduledEvent(this.guild.id, guildScheduledEventId), {\n      body: {\n        channel_id: channel === undefined ? channel : this.guild.channels.resolveId(channel),\n        name,\n        privacy_level: privacyLevel,\n        scheduled_start_time: scheduledStartTime ? new Date(scheduledStartTime).toISOString() : undefined,\n        scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,\n        description,\n        entity_type: entityType,\n        status,\n        image: image && (await DataResolver.resolveImage(image)),\n        entity_metadata\n      },\n      reason\n    });\n    return this._add(data);\n  }\n\n  /**\n   * Deletes a guild scheduled event.\n   * @param {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to delete\n   * @returns {Promise<void>}\n   */\n  async delete(guildScheduledEvent) {\n    const guildScheduledEventId = this.resolveId(guildScheduledEvent);\n    if (!guildScheduledEventId) throw new DiscordjsError(ErrorCodes.GuildScheduledEventResolve);\n    await this.client.rest.delete(Routes.guildScheduledEvent(this.guild.id, guildScheduledEventId));\n  }\n\n  /**\n   * Options used to fetch subscribers of a guild scheduled event\n   * @typedef {Object} FetchGuildScheduledEventSubscribersOptions\n   * @property {number} [limit] The maximum numbers of users to fetch\n   * @property {boolean} [withMember] Whether to fetch guild member data of the users\n   * @property {Snowflake} [before] Consider only users before this user id\n   * @property {Snowflake} [after] Consider only users after this user id\n   * <warn>If both `before` and `after` are provided, only `before` is respected</warn>\n   */\n\n  /**\n   * Represents a subscriber of a {@link GuildScheduledEvent}\n   * @typedef {Object} GuildScheduledEventUser\n   * @property {Snowflake} guildScheduledEventId The id of the guild scheduled event which the user subscribed to\n   * @property {User} user The user that subscribed to the guild scheduled event\n   * @property {?GuildMember} member The guild member associated with the user, if any\n   */\n\n  /**\n   * Fetches subscribers of a guild scheduled event.\n   * @param {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to fetch subscribers of\n   * @param {FetchGuildScheduledEventSubscribersOptions} [options={}] Options for fetching the subscribers\n   * @returns {Promise<Collection<Snowflake, GuildScheduledEventUser>>}\n   */\n  async fetchSubscribers(guildScheduledEvent, options = {}) {\n    const guildScheduledEventId = this.resolveId(guildScheduledEvent);\n    if (!guildScheduledEventId) throw new DiscordjsError(ErrorCodes.GuildScheduledEventResolve);\n    const query = makeURLSearchParams({\n      limit: options.limit,\n      with_member: options.withMember,\n      before: options.before,\n      after: options.after\n    });\n    const data = await this.client.rest.get(Routes.guildScheduledEventUsers(this.guild.id, guildScheduledEventId), {\n      query\n    });\n    return data.reduce((coll, rawData) => coll.set(rawData.user.id, {\n      guildScheduledEventId: rawData.guild_scheduled_event_id,\n      user: this.client.users._add(rawData.user),\n      member: rawData.member ? this.guild.members._add({\n        ...rawData.member,\n        user: rawData.user\n      }) : null\n    }), new Collection());\n  }\n}\nmodule.exports = GuildScheduledEventManager;","map":{"version":3,"names":["Collection","require","makeURLSearchParams","GuildScheduledEventEntityType","Routes","CachedManager","DiscordjsTypeError","DiscordjsError","ErrorCodes","GuildScheduledEvent","DataResolver","GuildScheduledEventManager","constructor","guild","iterable","client","create","options","InvalidType","privacyLevel","entityType","channel","name","scheduledStartTime","description","scheduledEndTime","entityMetadata","reason","image","entity_metadata","channel_id","External","undefined","location","channels","resolveId","GuildVoiceChannelResolve","data","rest","post","guildScheduledEvents","id","body","privacy_level","scheduled_start_time","Date","toISOString","scheduled_end_time","entity_type","resolveImage","_add","fetch","guildScheduledEvent","force","existing","cache","get","query","with_user_count","withUserCount","reduce","coll","rawGuildScheduledEventData","set","scheduledEvents","edit","guildScheduledEventId","GuildScheduledEventResolve","status","patch","delete","fetchSubscribers","limit","with_member","withMember","before","after","guildScheduledEventUsers","rawData","user","guild_scheduled_event_id","users","member","members","module","exports"],"sources":["C:/Users/hetit/node_modules/discord.js/src/managers/GuildScheduledEventManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst { makeURLSearchParams } = require('@discordjs/rest');\nconst { GuildScheduledEventEntityType, Routes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst { DiscordjsTypeError, DiscordjsError, ErrorCodes } = require('../errors');\nconst { GuildScheduledEvent } = require('../structures/GuildScheduledEvent');\nconst DataResolver = require('../util/DataResolver');\n\n/**\n * Manages API methods for GuildScheduledEvents and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildScheduledEventManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, GuildScheduledEvent, iterable);\n\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The cache of this manager\n   * @type {Collection<Snowflake, GuildScheduledEvent>}\n   * @name GuildScheduledEventManager#cache\n   */\n\n  /**\n   * Data that resolves to give a GuildScheduledEvent object. This can be:\n   * * A Snowflake\n   * * A GuildScheduledEvent object\n   * @typedef {Snowflake|GuildScheduledEvent} GuildScheduledEventResolvable\n   */\n\n  /**\n   * Options used to create a guild scheduled event.\n   * @typedef {Object} GuildScheduledEventCreateOptions\n   * @property {string} name The name of the guild scheduled event\n   * @property {DateResolvable} scheduledStartTime The time to schedule the event at\n   * @property {DateResolvable} [scheduledEndTime] The time to end the event at\n   * <warn>This is required if `entityType` is {@link GuildScheduledEventEntityType.External}</warn>\n   * @property {GuildScheduledEventPrivacyLevel} privacyLevel The privacy level of the guild scheduled event\n   * @property {GuildScheduledEventEntityType} entityType The scheduled entity type of the event\n   * @property {string} [description] The description of the guild scheduled event\n   * @property {GuildVoiceChannelResolvable} [channel] The channel of the guild scheduled event\n   * <warn>This is required if `entityType` is {@link GuildScheduledEventEntityType.StageInstance} or\n   * {@link GuildScheduledEventEntityType.Voice}</warn>\n   * @property {GuildScheduledEventEntityMetadataOptions} [entityMetadata] The entity metadata of the\n   * guild scheduled event\n   * <warn>This is required if `entityType` is {@link GuildScheduledEventEntityType.External}</warn>\n   * @property {?(BufferResolvable|Base64Resolvable)} [image] The cover image of the guild scheduled event\n   * @property {string} [reason] The reason for creating the guild scheduled event\n   */\n\n  /**\n   * Options used to set entity metadata of a guild scheduled event.\n   * @typedef {Object} GuildScheduledEventEntityMetadataOptions\n   * @property {string} [location] The location of the guild scheduled event\n   * <warn>This is required if `entityType` is {@link GuildScheduledEventEntityType.External}</warn>\n   */\n\n  /**\n   * Creates a new guild scheduled event.\n   * @param {GuildScheduledEventCreateOptions} options Options for creating the guild scheduled event\n   * @returns {Promise<GuildScheduledEvent>}\n   */\n  async create(options) {\n    if (typeof options !== 'object') throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'options', 'object', true);\n    let {\n      privacyLevel,\n      entityType,\n      channel,\n      name,\n      scheduledStartTime,\n      description,\n      scheduledEndTime,\n      entityMetadata,\n      reason,\n      image,\n    } = options;\n\n    let entity_metadata, channel_id;\n    if (entityType === GuildScheduledEventEntityType.External) {\n      channel_id = channel === undefined ? channel : null;\n      entity_metadata = { location: entityMetadata?.location };\n    } else {\n      channel_id = this.guild.channels.resolveId(channel);\n      if (!channel_id) throw new DiscordjsError(ErrorCodes.GuildVoiceChannelResolve);\n      entity_metadata = entityMetadata === undefined ? entityMetadata : null;\n    }\n\n    const data = await this.client.rest.post(Routes.guildScheduledEvents(this.guild.id), {\n      body: {\n        channel_id,\n        name,\n        privacy_level: privacyLevel,\n        scheduled_start_time: new Date(scheduledStartTime).toISOString(),\n        scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,\n        description,\n        entity_type: entityType,\n        entity_metadata,\n        image: image && (await DataResolver.resolveImage(image)),\n      },\n      reason,\n    });\n\n    return this._add(data);\n  }\n\n  /**\n   * Options used to fetch a single guild scheduled event from a guild.\n   * @typedef {BaseFetchOptions} FetchGuildScheduledEventOptions\n   * @property {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to fetch\n   * @property {boolean} [withUserCount=true] Whether to fetch the number of users subscribed to the scheduled event\n   */\n\n  /**\n   * Options used to fetch multiple guild scheduled events from a guild.\n   * @typedef {Object} FetchGuildScheduledEventsOptions\n   * @property {boolean} [cache] Whether or not to cache the fetched guild scheduled events\n   * @property {boolean} [withUserCount=true] Whether to fetch the number of users subscribed to each scheduled event\n   * should be returned\n   */\n\n  /**\n   * Obtains one or more guild scheduled events from Discord, or the guild cache if it's already available.\n   * @param {GuildScheduledEventResolvable|FetchGuildScheduledEventOptions|FetchGuildScheduledEventsOptions} [options]\n   * The id of the guild scheduled event or options\n   * @returns {Promise<GuildScheduledEvent|Collection<Snowflake, GuildScheduledEvent>>}\n   */\n  async fetch(options = {}) {\n    const id = this.resolveId(options.guildScheduledEvent ?? options);\n\n    if (id) {\n      if (!options.force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n\n      const data = await this.client.rest.get(Routes.guildScheduledEvent(this.guild.id, id), {\n        query: makeURLSearchParams({ with_user_count: options.withUserCount ?? true }),\n      });\n      return this._add(data, options.cache);\n    }\n\n    const data = await this.client.rest.get(Routes.guildScheduledEvents(this.guild.id), {\n      query: makeURLSearchParams({ with_user_count: options.withUserCount ?? true }),\n    });\n\n    return data.reduce(\n      (coll, rawGuildScheduledEventData) =>\n        coll.set(\n          rawGuildScheduledEventData.id,\n          this.guild.scheduledEvents._add(rawGuildScheduledEventData, options.cache),\n        ),\n      new Collection(),\n    );\n  }\n\n  /**\n   * Options used to edit a guild scheduled event.\n   * @typedef {Object} GuildScheduledEventEditOptions\n   * @property {string} [name] The name of the guild scheduled event\n   * @property {DateResolvable} [scheduledStartTime] The time to schedule the event at\n   * @property {DateResolvable} [scheduledEndTime] The time to end the event at\n   * @property {GuildScheduledEventPrivacyLevel} [privacyLevel] The privacy level of the guild scheduled event\n   * @property {GuildScheduledEventEntityType} [entityType] The scheduled entity type of the event\n   * @property {string} [description] The description of the guild scheduled event\n   * @property {?GuildVoiceChannelResolvable} [channel] The channel of the guild scheduled event\n   * @property {GuildScheduledEventStatus} [status] The status of the guild scheduled event\n   * @property {GuildScheduledEventEntityMetadataOptions} [entityMetadata] The entity metadata of the\n   * guild scheduled event\n   * <warn>This can be modified only if `entityType` of the `GuildScheduledEvent` to be edited is\n   * {@link GuildScheduledEventEntityType.External}</warn>\n   * @property {?(BufferResolvable|Base64Resolvable)} [image] The cover image of the guild scheduled event\n   * @property {string} [reason] The reason for editing the guild scheduled event\n   */\n\n  /**\n   * Edits a guild scheduled event.\n   * @param {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to edit\n   * @param {GuildScheduledEventEditOptions} options Options to edit the guild scheduled event\n   * @returns {Promise<GuildScheduledEvent>}\n   */\n  async edit(guildScheduledEvent, options) {\n    const guildScheduledEventId = this.resolveId(guildScheduledEvent);\n    if (!guildScheduledEventId) throw new DiscordjsError(ErrorCodes.GuildScheduledEventResolve);\n\n    if (typeof options !== 'object') throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'options', 'object', true);\n    let {\n      privacyLevel,\n      entityType,\n      channel,\n      status,\n      name,\n      scheduledStartTime,\n      description,\n      scheduledEndTime,\n      entityMetadata,\n      reason,\n      image,\n    } = options;\n\n    let entity_metadata;\n    if (entityMetadata) {\n      entity_metadata = {\n        location: entityMetadata.location,\n      };\n    }\n\n    const data = await this.client.rest.patch(Routes.guildScheduledEvent(this.guild.id, guildScheduledEventId), {\n      body: {\n        channel_id: channel === undefined ? channel : this.guild.channels.resolveId(channel),\n        name,\n        privacy_level: privacyLevel,\n        scheduled_start_time: scheduledStartTime ? new Date(scheduledStartTime).toISOString() : undefined,\n        scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,\n        description,\n        entity_type: entityType,\n        status,\n        image: image && (await DataResolver.resolveImage(image)),\n        entity_metadata,\n      },\n      reason,\n    });\n\n    return this._add(data);\n  }\n\n  /**\n   * Deletes a guild scheduled event.\n   * @param {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to delete\n   * @returns {Promise<void>}\n   */\n  async delete(guildScheduledEvent) {\n    const guildScheduledEventId = this.resolveId(guildScheduledEvent);\n    if (!guildScheduledEventId) throw new DiscordjsError(ErrorCodes.GuildScheduledEventResolve);\n\n    await this.client.rest.delete(Routes.guildScheduledEvent(this.guild.id, guildScheduledEventId));\n  }\n\n  /**\n   * Options used to fetch subscribers of a guild scheduled event\n   * @typedef {Object} FetchGuildScheduledEventSubscribersOptions\n   * @property {number} [limit] The maximum numbers of users to fetch\n   * @property {boolean} [withMember] Whether to fetch guild member data of the users\n   * @property {Snowflake} [before] Consider only users before this user id\n   * @property {Snowflake} [after] Consider only users after this user id\n   * <warn>If both `before` and `after` are provided, only `before` is respected</warn>\n   */\n\n  /**\n   * Represents a subscriber of a {@link GuildScheduledEvent}\n   * @typedef {Object} GuildScheduledEventUser\n   * @property {Snowflake} guildScheduledEventId The id of the guild scheduled event which the user subscribed to\n   * @property {User} user The user that subscribed to the guild scheduled event\n   * @property {?GuildMember} member The guild member associated with the user, if any\n   */\n\n  /**\n   * Fetches subscribers of a guild scheduled event.\n   * @param {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to fetch subscribers of\n   * @param {FetchGuildScheduledEventSubscribersOptions} [options={}] Options for fetching the subscribers\n   * @returns {Promise<Collection<Snowflake, GuildScheduledEventUser>>}\n   */\n  async fetchSubscribers(guildScheduledEvent, options = {}) {\n    const guildScheduledEventId = this.resolveId(guildScheduledEvent);\n    if (!guildScheduledEventId) throw new DiscordjsError(ErrorCodes.GuildScheduledEventResolve);\n\n    const query = makeURLSearchParams({\n      limit: options.limit,\n      with_member: options.withMember,\n      before: options.before,\n      after: options.after,\n    });\n\n    const data = await this.client.rest.get(Routes.guildScheduledEventUsers(this.guild.id, guildScheduledEventId), {\n      query,\n    });\n\n    return data.reduce(\n      (coll, rawData) =>\n        coll.set(rawData.user.id, {\n          guildScheduledEventId: rawData.guild_scheduled_event_id,\n          user: this.client.users._add(rawData.user),\n          member: rawData.member ? this.guild.members._add({ ...rawData.member, user: rawData.user }) : null,\n        }),\n      new Collection(),\n    );\n  }\n}\n\nmodule.exports = GuildScheduledEventManager;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}