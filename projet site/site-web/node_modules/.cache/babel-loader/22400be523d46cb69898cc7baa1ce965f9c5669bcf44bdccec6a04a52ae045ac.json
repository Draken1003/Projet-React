{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __name = (target, value) => __defProp(target, \"name\", {\n  value,\n  configurable: true\n});\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// src/web.ts\nvar web_exports = {};\n__export(web_exports, {\n  ALLOWED_EXTENSIONS: () => ALLOWED_EXTENSIONS,\n  ALLOWED_SIZES: () => ALLOWED_SIZES,\n  ALLOWED_STICKER_EXTENSIONS: () => ALLOWED_STICKER_EXTENSIONS,\n  BurstHandlerMajorIdKey: () => BurstHandlerMajorIdKey,\n  CDN: () => CDN,\n  DefaultRestOptions: () => DefaultRestOptions,\n  DefaultUserAgent: () => DefaultUserAgent,\n  DefaultUserAgentAppendix: () => DefaultUserAgentAppendix,\n  DiscordAPIError: () => DiscordAPIError,\n  HTTPError: () => HTTPError,\n  OverwrittenMimeTypes: () => OverwrittenMimeTypes,\n  REST: () => REST,\n  RESTEvents: () => RESTEvents,\n  RateLimitError: () => RateLimitError,\n  RequestMethod: () => RequestMethod,\n  calculateUserDefaultAvatarIndex: () => calculateUserDefaultAvatarIndex,\n  makeURLSearchParams: () => makeURLSearchParams,\n  parseResponse: () => parseResponse,\n  version: () => version\n});\nmodule.exports = __toCommonJS(web_exports);\n\n// src/environment.ts\nvar defaultStrategy;\nfunction setDefaultStrategy(newStrategy) {\n  defaultStrategy = newStrategy;\n}\n__name(setDefaultStrategy, \"setDefaultStrategy\");\nfunction getDefaultStrategy() {\n  return defaultStrategy;\n}\n__name(getDefaultStrategy, \"getDefaultStrategy\");\n\n// src/lib/utils/constants.ts\nvar import_util = require(\"@discordjs/util\");\nvar import_v10 = require(\"discord-api-types/v10\");\nvar DefaultUserAgent = `DiscordBot (https://discord.js.org, 2.0.1)`;\nvar DefaultUserAgentAppendix = (0, import_util.getUserAgentAppendix)();\nvar DefaultRestOptions = {\n  agent: null,\n  api: \"https://discord.com/api\",\n  authPrefix: \"Bot\",\n  cdn: \"https://cdn.discordapp.com\",\n  headers: {},\n  invalidRequestWarningInterval: 0,\n  globalRequestsPerSecond: 50,\n  offset: 50,\n  rejectOnRateLimit: null,\n  retries: 3,\n  timeout: 15e3,\n  userAgentAppendix: DefaultUserAgentAppendix,\n  version: import_v10.APIVersion,\n  hashSweepInterval: 144e5,\n  // 4 Hours\n  hashLifetime: 864e5,\n  // 24 Hours\n  handlerSweepInterval: 36e5,\n  // 1 Hour\n  async makeRequest(...args) {\n    return getDefaultStrategy()(...args);\n  }\n};\nvar RESTEvents = /* @__PURE__ */(RESTEvents2 => {\n  RESTEvents2[\"Debug\"] = \"restDebug\";\n  RESTEvents2[\"HandlerSweep\"] = \"handlerSweep\";\n  RESTEvents2[\"HashSweep\"] = \"hashSweep\";\n  RESTEvents2[\"InvalidRequestWarning\"] = \"invalidRequestWarning\";\n  RESTEvents2[\"RateLimited\"] = \"rateLimited\";\n  RESTEvents2[\"Response\"] = \"response\";\n  return RESTEvents2;\n})(RESTEvents || {});\nvar ALLOWED_EXTENSIONS = [\"webp\", \"png\", \"jpg\", \"jpeg\", \"gif\"];\nvar ALLOWED_STICKER_EXTENSIONS = [\"png\", \"json\", \"gif\"];\nvar ALLOWED_SIZES = [16, 32, 64, 128, 256, 512, 1024, 2048, 4096];\nvar OverwrittenMimeTypes = {\n  // https://github.com/discordjs/discord.js/issues/8557\n  \"image/apng\": \"image/png\"\n};\nvar BurstHandlerMajorIdKey = \"burst\";\n\n// src/lib/CDN.ts\nvar CDN = class {\n  constructor(base = DefaultRestOptions.cdn) {\n    this.base = base;\n  }\n  static {\n    __name(this, \"CDN\");\n  }\n  /**\n   * Generates an app asset URL for a client's asset.\n   *\n   * @param clientId - The client id that has the asset\n   * @param assetHash - The hash provided by Discord for this asset\n   * @param options - Optional options for the asset\n   */\n  appAsset(clientId, assetHash, options) {\n    return this.makeURL(`/app-assets/${clientId}/${assetHash}`, options);\n  }\n  /**\n   * Generates an app icon URL for a client's icon.\n   *\n   * @param clientId - The client id that has the icon\n   * @param iconHash - The hash provided by Discord for this icon\n   * @param options - Optional options for the icon\n   */\n  appIcon(clientId, iconHash, options) {\n    return this.makeURL(`/app-icons/${clientId}/${iconHash}`, options);\n  }\n  /**\n   * Generates an avatar URL, e.g. for a user or a webhook.\n   *\n   * @param id - The id that has the icon\n   * @param avatarHash - The hash provided by Discord for this avatar\n   * @param options - Optional options for the avatar\n   */\n  avatar(id, avatarHash, options) {\n    return this.dynamicMakeURL(`/avatars/${id}/${avatarHash}`, avatarHash, options);\n  }\n  /**\n   * Generates a user avatar decoration URL.\n   *\n   * @param userId - The id of the user\n   * @param userAvatarDecoration - The hash provided by Discord for this avatar decoration\n   * @param options - Optional options for the avatar decoration\n   */\n  avatarDecoration(userId, userAvatarDecoration, options) {\n    return this.makeURL(`/avatar-decorations/${userId}/${userAvatarDecoration}`, options);\n  }\n  /**\n   * Generates a banner URL, e.g. for a user or a guild.\n   *\n   * @param id - The id that has the banner splash\n   * @param bannerHash - The hash provided by Discord for this banner\n   * @param options - Optional options for the banner\n   */\n  banner(id, bannerHash, options) {\n    return this.dynamicMakeURL(`/banners/${id}/${bannerHash}`, bannerHash, options);\n  }\n  /**\n   * Generates an icon URL for a channel, e.g. a group DM.\n   *\n   * @param channelId - The channel id that has the icon\n   * @param iconHash - The hash provided by Discord for this channel\n   * @param options - Optional options for the icon\n   */\n  channelIcon(channelId, iconHash, options) {\n    return this.makeURL(`/channel-icons/${channelId}/${iconHash}`, options);\n  }\n  /**\n   * Generates a default avatar URL\n   *\n   * @param index - The default avatar index\n   * @remarks\n   * To calculate the index for a user do `(userId >> 22) % 6`,\n   * or `discriminator % 5` if they're using the legacy username system.\n   */\n  defaultAvatar(index) {\n    return this.makeURL(`/embed/avatars/${index}`, {\n      extension: \"png\"\n    });\n  }\n  /**\n   * Generates a discovery splash URL for a guild's discovery splash.\n   *\n   * @param guildId - The guild id that has the discovery splash\n   * @param splashHash - The hash provided by Discord for this splash\n   * @param options - Optional options for the splash\n   */\n  discoverySplash(guildId, splashHash, options) {\n    return this.makeURL(`/discovery-splashes/${guildId}/${splashHash}`, options);\n  }\n  /**\n   * Generates an emoji's URL for an emoji.\n   *\n   * @param emojiId - The emoji id\n   * @param extension - The extension of the emoji\n   */\n  emoji(emojiId, extension) {\n    return this.makeURL(`/emojis/${emojiId}`, {\n      extension\n    });\n  }\n  /**\n   * Generates a guild member avatar URL.\n   *\n   * @param guildId - The id of the guild\n   * @param userId - The id of the user\n   * @param avatarHash - The hash provided by Discord for this avatar\n   * @param options - Optional options for the avatar\n   */\n  guildMemberAvatar(guildId, userId, avatarHash, options) {\n    return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/avatars/${avatarHash}`, avatarHash, options);\n  }\n  /**\n   * Generates a guild member banner URL.\n   *\n   * @param guildId - The id of the guild\n   * @param userId - The id of the user\n   * @param bannerHash - The hash provided by Discord for this banner\n   * @param options - Optional options for the banner\n   */\n  guildMemberBanner(guildId, userId, bannerHash, options) {\n    return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/banner`, bannerHash, options);\n  }\n  /**\n   * Generates an icon URL, e.g. for a guild.\n   *\n   * @param id - The id that has the icon splash\n   * @param iconHash - The hash provided by Discord for this icon\n   * @param options - Optional options for the icon\n   */\n  icon(id, iconHash, options) {\n    return this.dynamicMakeURL(`/icons/${id}/${iconHash}`, iconHash, options);\n  }\n  /**\n   * Generates a URL for the icon of a role\n   *\n   * @param roleId - The id of the role that has the icon\n   * @param roleIconHash - The hash provided by Discord for this role icon\n   * @param options - Optional options for the role icon\n   */\n  roleIcon(roleId, roleIconHash, options) {\n    return this.makeURL(`/role-icons/${roleId}/${roleIconHash}`, options);\n  }\n  /**\n   * Generates a guild invite splash URL for a guild's invite splash.\n   *\n   * @param guildId - The guild id that has the invite splash\n   * @param splashHash - The hash provided by Discord for this splash\n   * @param options - Optional options for the splash\n   */\n  splash(guildId, splashHash, options) {\n    return this.makeURL(`/splashes/${guildId}/${splashHash}`, options);\n  }\n  /**\n   * Generates a sticker URL.\n   *\n   * @param stickerId - The sticker id\n   * @param extension - The extension of the sticker\n   * @privateRemarks\n   * Stickers cannot have a `.webp` extension, so we default to a `.png`\n   */\n  sticker(stickerId, extension = \"png\") {\n    return this.makeURL(`/stickers/${stickerId}`, {\n      allowedExtensions: ALLOWED_STICKER_EXTENSIONS,\n      extension\n    });\n  }\n  /**\n   * Generates a sticker pack banner URL.\n   *\n   * @param bannerId - The banner id\n   * @param options - Optional options for the banner\n   */\n  stickerPackBanner(bannerId, options) {\n    return this.makeURL(`/app-assets/710982414301790216/store/${bannerId}`, options);\n  }\n  /**\n   * Generates a team icon URL for a team's icon.\n   *\n   * @param teamId - The team id that has the icon\n   * @param iconHash - The hash provided by Discord for this icon\n   * @param options - Optional options for the icon\n   */\n  teamIcon(teamId, iconHash, options) {\n    return this.makeURL(`/team-icons/${teamId}/${iconHash}`, options);\n  }\n  /**\n   * Generates a cover image for a guild scheduled event.\n   *\n   * @param scheduledEventId - The scheduled event id\n   * @param coverHash - The hash provided by discord for this cover image\n   * @param options - Optional options for the cover image\n   */\n  guildScheduledEventCover(scheduledEventId, coverHash, options) {\n    return this.makeURL(`/guild-events/${scheduledEventId}/${coverHash}`, options);\n  }\n  /**\n   * Constructs the URL for the resource, checking whether or not `hash` starts with `a_` if `dynamic` is set to `true`.\n   *\n   * @param route - The base cdn route\n   * @param hash - The hash provided by Discord for this icon\n   * @param options - Optional options for the link\n   */\n  dynamicMakeURL(route, hash, {\n    forceStatic = false,\n    ...options\n  } = {}) {\n    return this.makeURL(route, !forceStatic && hash.startsWith(\"a_\") ? {\n      ...options,\n      extension: \"gif\"\n    } : options);\n  }\n  /**\n   * Constructs the URL for the resource\n   *\n   * @param route - The base cdn route\n   * @param options - The extension/size options for the link\n   */\n  makeURL(route, {\n    allowedExtensions = ALLOWED_EXTENSIONS,\n    extension = \"webp\",\n    size\n  } = {}) {\n    extension = String(extension).toLowerCase();\n    if (!allowedExtensions.includes(extension)) {\n      throw new RangeError(`Invalid extension provided: ${extension}\nMust be one of: ${allowedExtensions.join(\", \")}`);\n    }\n    if (size && !ALLOWED_SIZES.includes(size)) {\n      throw new RangeError(`Invalid size provided: ${size}\nMust be one of: ${ALLOWED_SIZES.join(\", \")}`);\n    }\n    const url = new URL(`${this.base}${route}.${extension}`);\n    if (size) {\n      url.searchParams.set(\"size\", String(size));\n    }\n    return url.toString();\n  }\n};\n\n// src/lib/errors/DiscordAPIError.ts\nfunction isErrorGroupWrapper(error) {\n  return Reflect.has(error, \"_errors\");\n}\n__name(isErrorGroupWrapper, \"isErrorGroupWrapper\");\nfunction isErrorResponse(error) {\n  return typeof Reflect.get(error, \"message\") === \"string\";\n}\n__name(isErrorResponse, \"isErrorResponse\");\nvar DiscordAPIError = class _DiscordAPIError extends Error {\n  /**\n   * @param rawError - The error reported by Discord\n   * @param code - The error code reported by Discord\n   * @param status - The status code of the response\n   * @param method - The method of the request that erred\n   * @param url - The url of the request that erred\n   * @param bodyData - The unparsed data for the request that errored\n   */\n  constructor(rawError, code, status, method, url, bodyData) {\n    super(_DiscordAPIError.getMessage(rawError));\n    this.rawError = rawError;\n    this.code = code;\n    this.status = status;\n    this.method = method;\n    this.url = url;\n    this.requestBody = {\n      files: bodyData.files,\n      json: bodyData.body\n    };\n  }\n  static {\n    __name(this, \"DiscordAPIError\");\n  }\n  requestBody;\n  /**\n   * The name of the error\n   */\n  get name() {\n    return `${_DiscordAPIError.name}[${this.code}]`;\n  }\n  static getMessage(error) {\n    let flattened = \"\";\n    if (\"code\" in error) {\n      if (error.errors) {\n        flattened = [...this.flattenDiscordError(error.errors)].join(\"\\n\");\n      }\n      return error.message && flattened ? `${error.message}\n${flattened}` : error.message || flattened || \"Unknown Error\";\n    }\n    return error.error_description ?? \"No Description\";\n  }\n  static *flattenDiscordError(obj, key = \"\") {\n    if (isErrorResponse(obj)) {\n      return yield `${key.length ? `${key}[${obj.code}]` : `${obj.code}`}: ${obj.message}`.trim();\n    }\n    for (const [otherKey, val] of Object.entries(obj)) {\n      const nextKey = otherKey.startsWith(\"_\") ? key : key ? Number.isNaN(Number(otherKey)) ? `${key}.${otherKey}` : `${key}[${otherKey}]` : otherKey;\n      if (typeof val === \"string\") {\n        yield val;\n      } else if (isErrorGroupWrapper(val)) {\n        for (const error of val._errors) {\n          yield* this.flattenDiscordError(error, nextKey);\n        }\n      } else {\n        yield* this.flattenDiscordError(val, nextKey);\n      }\n    }\n  }\n};\n\n// src/lib/errors/HTTPError.ts\nvar HTTPError = class _HTTPError extends Error {\n  /**\n   * @param status - The status code of the response\n   * @param statusText - The status text of the response\n   * @param method - The method of the request that erred\n   * @param url - The url of the request that erred\n   * @param bodyData - The unparsed data for the request that errored\n   */\n  constructor(status, statusText, method, url, bodyData) {\n    super(statusText);\n    this.status = status;\n    this.method = method;\n    this.url = url;\n    this.requestBody = {\n      files: bodyData.files,\n      json: bodyData.body\n    };\n  }\n  static {\n    __name(this, \"HTTPError\");\n  }\n  requestBody;\n  name = _HTTPError.name;\n};\n\n// src/lib/errors/RateLimitError.ts\nvar RateLimitError = class _RateLimitError extends Error {\n  static {\n    __name(this, \"RateLimitError\");\n  }\n  timeToReset;\n  limit;\n  method;\n  hash;\n  url;\n  route;\n  majorParameter;\n  global;\n  constructor({\n    timeToReset,\n    limit,\n    method,\n    hash,\n    url,\n    route,\n    majorParameter,\n    global\n  }) {\n    super();\n    this.timeToReset = timeToReset;\n    this.limit = limit;\n    this.method = method;\n    this.hash = hash;\n    this.url = url;\n    this.route = route;\n    this.majorParameter = majorParameter;\n    this.global = global;\n  }\n  /**\n   * The name of the error\n   */\n  get name() {\n    return `${_RateLimitError.name}[${this.route}]`;\n  }\n};\n\n// src/lib/REST.ts\nvar import_collection = require(\"@discordjs/collection\");\nvar import_snowflake = require(\"@sapphire/snowflake\");\nvar import_async_event_emitter = require(\"@vladfrangu/async_event_emitter\");\nvar import_magic_bytes = require(\"magic-bytes.js\");\n\n// src/lib/utils/types.ts\nvar RequestMethod = /* @__PURE__ */(RequestMethod2 => {\n  RequestMethod2[\"Delete\"] = \"DELETE\";\n  RequestMethod2[\"Get\"] = \"GET\";\n  RequestMethod2[\"Patch\"] = \"PATCH\";\n  RequestMethod2[\"Post\"] = \"POST\";\n  RequestMethod2[\"Put\"] = \"PUT\";\n  return RequestMethod2;\n})(RequestMethod || {});\n\n// src/lib/utils/utils.ts\nfunction serializeSearchParam(value) {\n  switch (typeof value) {\n    case \"string\":\n      return value;\n    case \"number\":\n    case \"bigint\":\n    case \"boolean\":\n      return value.toString();\n    case \"object\":\n      if (value === null) return null;\n      if (value instanceof Date) {\n        return Number.isNaN(value.getTime()) ? null : value.toISOString();\n      }\n      if (typeof value.toString === \"function\" && value.toString !== Object.prototype.toString) return value.toString();\n      return null;\n    default:\n      return null;\n  }\n}\n__name(serializeSearchParam, \"serializeSearchParam\");\nfunction makeURLSearchParams(options) {\n  const params = new URLSearchParams();\n  if (!options) return params;\n  for (const [key, value] of Object.entries(options)) {\n    const serialized = serializeSearchParam(value);\n    if (serialized !== null) params.append(key, serialized);\n  }\n  return params;\n}\n__name(makeURLSearchParams, \"makeURLSearchParams\");\nasync function parseResponse(res) {\n  if (res.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n    return res.json();\n  }\n  return res.arrayBuffer();\n}\n__name(parseResponse, \"parseResponse\");\nfunction hasSublimit(bucketRoute, body, method) {\n  if (bucketRoute === \"/channels/:id\") {\n    if (typeof body !== \"object\" || body === null) return false;\n    if (method !== \"PATCH\" /* Patch */) return false;\n    const castedBody = body;\n    return [\"name\", \"topic\"].some(key => Reflect.has(castedBody, key));\n  }\n  return true;\n}\n__name(hasSublimit, \"hasSublimit\");\nfunction shouldRetry(error) {\n  if (error.name === \"AbortError\") return true;\n  return \"code\" in error && error.code === \"ECONNRESET\" || error.message.includes(\"ECONNRESET\");\n}\n__name(shouldRetry, \"shouldRetry\");\nasync function onRateLimit(manager, rateLimitData) {\n  const {\n    options\n  } = manager;\n  if (!options.rejectOnRateLimit) return;\n  const shouldThrow = typeof options.rejectOnRateLimit === \"function\" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some(route => rateLimitData.route.startsWith(route.toLowerCase()));\n  if (shouldThrow) {\n    throw new RateLimitError(rateLimitData);\n  }\n}\n__name(onRateLimit, \"onRateLimit\");\nfunction calculateUserDefaultAvatarIndex(userId) {\n  return Number(BigInt(userId) >> 22n) % 6;\n}\n__name(calculateUserDefaultAvatarIndex, \"calculateUserDefaultAvatarIndex\");\nasync function sleep(ms) {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(), ms);\n  });\n}\n__name(sleep, \"sleep\");\nfunction isBufferLike(value) {\n  return value instanceof ArrayBuffer || value instanceof Uint8Array || value instanceof Uint8ClampedArray;\n}\n__name(isBufferLike, \"isBufferLike\");\n\n// src/lib/handlers/Shared.ts\nvar invalidCount = 0;\nvar invalidCountResetTime = null;\nfunction incrementInvalidCount(manager) {\n  if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {\n    invalidCountResetTime = Date.now() + 1e3 * 60 * 10;\n    invalidCount = 0;\n  }\n  invalidCount++;\n  const emitInvalid = manager.options.invalidRequestWarningInterval > 0 && invalidCount % manager.options.invalidRequestWarningInterval === 0;\n  if (emitInvalid) {\n    manager.emit(\"invalidRequestWarning\" /* InvalidRequestWarning */, {\n      count: invalidCount,\n      remainingTime: invalidCountResetTime - Date.now()\n    });\n  }\n}\n__name(incrementInvalidCount, \"incrementInvalidCount\");\nasync function makeNetworkRequest(manager, routeId, url, options, requestData, retries) {\n  const controller = new AbortController();\n  const timeout = setTimeout(() => controller.abort(), manager.options.timeout);\n  if (requestData.signal) {\n    if (requestData.signal.aborted) controller.abort();else requestData.signal.addEventListener(\"abort\", () => controller.abort());\n  }\n  let res;\n  try {\n    res = await manager.options.makeRequest(url, {\n      ...options,\n      signal: controller.signal\n    });\n  } catch (error) {\n    if (!(error instanceof Error)) throw error;\n    if (shouldRetry(error) && retries !== manager.options.retries) {\n      return null;\n    }\n    throw error;\n  } finally {\n    clearTimeout(timeout);\n  }\n  if (manager.listenerCount(\"response\" /* Response */)) {\n    manager.emit(\"response\" /* Response */, {\n      method: options.method ?? \"get\",\n      path: routeId.original,\n      route: routeId.bucketRoute,\n      options,\n      data: requestData,\n      retries\n    }, res instanceof Response ? res.clone() : {\n      ...res\n    });\n  }\n  return res;\n}\n__name(makeNetworkRequest, \"makeNetworkRequest\");\nasync function handleErrors(manager, res, method, url, requestData, retries) {\n  const status = res.status;\n  if (status >= 500 && status < 600) {\n    if (retries !== manager.options.retries) {\n      return null;\n    }\n    throw new HTTPError(status, res.statusText, method, url, requestData);\n  } else {\n    if (status >= 400 && status < 500) {\n      if (status === 401 && requestData.auth) {\n        manager.setToken(null);\n      }\n      const data = await parseResponse(res);\n      throw new DiscordAPIError(data, \"code\" in data ? data.code : data.error, status, method, url, requestData);\n    }\n    return res;\n  }\n}\n__name(handleErrors, \"handleErrors\");\n\n// src/lib/handlers/BurstHandler.ts\nvar BurstHandler = class {\n  /**\n   * @param manager - The request manager\n   * @param hash - The hash that this RequestHandler handles\n   * @param majorParameter - The major parameter for this handler\n   */\n  constructor(manager, hash, majorParameter) {\n    this.manager = manager;\n    this.hash = hash;\n    this.majorParameter = majorParameter;\n    this.id = `${hash}:${majorParameter}`;\n  }\n  static {\n    __name(this, \"BurstHandler\");\n  }\n  /**\n   * {@inheritdoc IHandler.id}\n   */\n  id;\n  /**\n   * {@inheritDoc IHandler.inactive}\n   */\n  inactive = false;\n  /**\n   * Emits a debug message\n   *\n   * @param message - The message to debug\n   */\n  debug(message) {\n    this.manager.emit(\"restDebug\" /* Debug */, `[REST ${this.id}] ${message}`);\n  }\n  /**\n   * {@inheritDoc IHandler.queueRequest}\n   */\n  async queueRequest(routeId, url, options, requestData) {\n    return this.runRequest(routeId, url, options, requestData);\n  }\n  /**\n   * The method that actually makes the request to the API, and updates info about the bucket accordingly\n   *\n   * @param routeId - The generalized API route with literal ids for major parameters\n   * @param url - The fully resolved URL to make the request to\n   * @param options - The fetch options needed to make the request\n   * @param requestData - Extra data from the user's request needed for errors and additional processing\n   * @param retries - The number of retries this request has already attempted (recursion)\n   */\n  async runRequest(routeId, url, options, requestData, retries = 0) {\n    const method = options.method ?? \"get\";\n    const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);\n    if (res === null) {\n      return this.runRequest(routeId, url, options, requestData, ++retries);\n    }\n    const status = res.status;\n    let retryAfter = 0;\n    const retry = res.headers.get(\"Retry-After\");\n    if (retry) retryAfter = Number(retry) * 1e3 + this.manager.options.offset;\n    if (status === 401 || status === 403 || status === 429) {\n      incrementInvalidCount(this.manager);\n    }\n    if (status >= 200 && status < 300) {\n      return res;\n    } else if (status === 429) {\n      const isGlobal = res.headers.has(\"X-RateLimit-Global\");\n      await onRateLimit(this.manager, {\n        timeToReset: retryAfter,\n        limit: Number.POSITIVE_INFINITY,\n        method,\n        hash: this.hash,\n        url,\n        route: routeId.bucketRoute,\n        majorParameter: this.majorParameter,\n        global: isGlobal\n      });\n      this.debug([\"Encountered unexpected 429 rate limit\", `  Global         : ${isGlobal}`, `  Method         : ${method}`, `  URL            : ${url}`, `  Bucket         : ${routeId.bucketRoute}`, `  Major parameter: ${routeId.majorParameter}`, `  Hash           : ${this.hash}`, `  Limit          : ${Number.POSITIVE_INFINITY}`, `  Retry After    : ${retryAfter}ms`, `  Sublimit       : None`].join(\"\\n\"));\n      await sleep(retryAfter);\n      return this.runRequest(routeId, url, options, requestData, retries);\n    } else {\n      const handled = await handleErrors(this.manager, res, method, url, requestData, retries);\n      if (handled === null) {\n        return this.runRequest(routeId, url, options, requestData, ++retries);\n      }\n      return handled;\n    }\n  }\n};\n\n// src/lib/handlers/SequentialHandler.ts\nvar import_async_queue = require(\"@sapphire/async-queue\");\nvar SequentialHandler = class {\n  /**\n   * @param manager - The request manager\n   * @param hash - The hash that this RequestHandler handles\n   * @param majorParameter - The major parameter for this handler\n   */\n  constructor(manager, hash, majorParameter) {\n    this.manager = manager;\n    this.hash = hash;\n    this.majorParameter = majorParameter;\n    this.id = `${hash}:${majorParameter}`;\n  }\n  static {\n    __name(this, \"SequentialHandler\");\n  }\n  /**\n   * {@inheritDoc IHandler.id}\n   */\n  id;\n  /**\n   * The time this rate limit bucket will reset\n   */\n  reset = -1;\n  /**\n   * The remaining requests that can be made before we are rate limited\n   */\n  remaining = 1;\n  /**\n   * The total number of requests that can be made before we are rate limited\n   */\n  limit = Number.POSITIVE_INFINITY;\n  /**\n   * The interface used to sequence async requests sequentially\n   */\n  #asyncQueue = new import_async_queue.AsyncQueue();\n  /**\n   * The interface used to sequence sublimited async requests sequentially\n   */\n  #sublimitedQueue = null;\n  /**\n   * A promise wrapper for when the sublimited queue is finished being processed or null when not being processed\n   */\n  #sublimitPromise = null;\n  /**\n   * Whether the sublimit queue needs to be shifted in the finally block\n   */\n  #shiftSublimit = false;\n  /**\n   * {@inheritDoc IHandler.inactive}\n   */\n  get inactive() {\n    return this.#asyncQueue.remaining === 0 && (this.#sublimitedQueue === null || this.#sublimitedQueue.remaining === 0) && !this.limited;\n  }\n  /**\n   * If the rate limit bucket is currently limited by the global limit\n   */\n  get globalLimited() {\n    return this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;\n  }\n  /**\n   * If the rate limit bucket is currently limited by its limit\n   */\n  get localLimited() {\n    return this.remaining <= 0 && Date.now() < this.reset;\n  }\n  /**\n   * If the rate limit bucket is currently limited\n   */\n  get limited() {\n    return this.globalLimited || this.localLimited;\n  }\n  /**\n   * The time until queued requests can continue\n   */\n  get timeToReset() {\n    return this.reset + this.manager.options.offset - Date.now();\n  }\n  /**\n   * Emits a debug message\n   *\n   * @param message - The message to debug\n   */\n  debug(message) {\n    this.manager.emit(\"restDebug\" /* Debug */, `[REST ${this.id}] ${message}`);\n  }\n  /**\n   * Delay all requests for the specified amount of time, handling global rate limits\n   *\n   * @param time - The amount of time to delay all requests for\n   */\n  async globalDelayFor(time) {\n    await sleep(time);\n    this.manager.globalDelay = null;\n  }\n  /**\n   * {@inheritDoc IHandler.queueRequest}\n   */\n  async queueRequest(routeId, url, options, requestData) {\n    let queue = this.#asyncQueue;\n    let queueType = 0 /* Standard */;\n    if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {\n      queue = this.#sublimitedQueue;\n      queueType = 1 /* Sublimit */;\n    }\n    await queue.wait({\n      signal: requestData.signal\n    });\n    if (queueType === 0 /* Standard */) {\n      if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {\n        queue = this.#sublimitedQueue;\n        const wait = queue.wait();\n        this.#asyncQueue.shift();\n        await wait;\n      } else if (this.#sublimitPromise) {\n        await this.#sublimitPromise.promise;\n      }\n    }\n    try {\n      return await this.runRequest(routeId, url, options, requestData);\n    } finally {\n      queue.shift();\n      if (this.#shiftSublimit) {\n        this.#shiftSublimit = false;\n        this.#sublimitedQueue?.shift();\n      }\n      if (this.#sublimitedQueue?.remaining === 0) {\n        this.#sublimitPromise?.resolve();\n        this.#sublimitedQueue = null;\n      }\n    }\n  }\n  /**\n   * The method that actually makes the request to the api, and updates info about the bucket accordingly\n   *\n   * @param routeId - The generalized api route with literal ids for major parameters\n   * @param url - The fully resolved url to make the request to\n   * @param options - The fetch options needed to make the request\n   * @param requestData - Extra data from the user's request needed for errors and additional processing\n   * @param retries - The number of retries this request has already attempted (recursion)\n   */\n  async runRequest(routeId, url, options, requestData, retries = 0) {\n    while (this.limited) {\n      const isGlobal = this.globalLimited;\n      let limit2;\n      let timeout;\n      let delay;\n      if (isGlobal) {\n        limit2 = this.manager.options.globalRequestsPerSecond;\n        timeout = this.manager.globalReset + this.manager.options.offset - Date.now();\n        if (!this.manager.globalDelay) {\n          this.manager.globalDelay = this.globalDelayFor(timeout);\n        }\n        delay = this.manager.globalDelay;\n      } else {\n        limit2 = this.limit;\n        timeout = this.timeToReset;\n        delay = sleep(timeout);\n      }\n      const rateLimitData = {\n        timeToReset: timeout,\n        limit: limit2,\n        method: options.method ?? \"get\",\n        hash: this.hash,\n        url,\n        route: routeId.bucketRoute,\n        majorParameter: this.majorParameter,\n        global: isGlobal\n      };\n      this.manager.emit(\"rateLimited\" /* RateLimited */, rateLimitData);\n      await onRateLimit(this.manager, rateLimitData);\n      if (isGlobal) {\n        this.debug(`Global rate limit hit, blocking all requests for ${timeout}ms`);\n      } else {\n        this.debug(`Waiting ${timeout}ms for rate limit to pass`);\n      }\n      await delay;\n    }\n    if (!this.manager.globalReset || this.manager.globalReset < Date.now()) {\n      this.manager.globalReset = Date.now() + 1e3;\n      this.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;\n    }\n    this.manager.globalRemaining--;\n    const method = options.method ?? \"get\";\n    const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);\n    if (res === null) {\n      return this.runRequest(routeId, url, options, requestData, ++retries);\n    }\n    const status = res.status;\n    let retryAfter = 0;\n    const limit = res.headers.get(\"X-RateLimit-Limit\");\n    const remaining = res.headers.get(\"X-RateLimit-Remaining\");\n    const reset = res.headers.get(\"X-RateLimit-Reset-After\");\n    const hash = res.headers.get(\"X-RateLimit-Bucket\");\n    const retry = res.headers.get(\"Retry-After\");\n    this.limit = limit ? Number(limit) : Number.POSITIVE_INFINITY;\n    this.remaining = remaining ? Number(remaining) : 1;\n    this.reset = reset ? Number(reset) * 1e3 + Date.now() + this.manager.options.offset : Date.now();\n    if (retry) retryAfter = Number(retry) * 1e3 + this.manager.options.offset;\n    if (hash && hash !== this.hash) {\n      this.debug([\"Received bucket hash update\", `  Old Hash  : ${this.hash}`, `  New Hash  : ${hash}`].join(\"\\n\"));\n      this.manager.hashes.set(`${method}:${routeId.bucketRoute}`, {\n        value: hash,\n        lastAccess: Date.now()\n      });\n    } else if (hash) {\n      const hashData = this.manager.hashes.get(`${method}:${routeId.bucketRoute}`);\n      if (hashData) {\n        hashData.lastAccess = Date.now();\n      }\n    }\n    let sublimitTimeout = null;\n    if (retryAfter > 0) {\n      if (res.headers.has(\"X-RateLimit-Global\")) {\n        this.manager.globalRemaining = 0;\n        this.manager.globalReset = Date.now() + retryAfter;\n      } else if (!this.localLimited) {\n        sublimitTimeout = retryAfter;\n      }\n    }\n    if (status === 401 || status === 403 || status === 429) {\n      incrementInvalidCount(this.manager);\n    }\n    if (res.ok) {\n      return res;\n    } else if (status === 429) {\n      const isGlobal = this.globalLimited;\n      let limit2;\n      let timeout;\n      if (isGlobal) {\n        limit2 = this.manager.options.globalRequestsPerSecond;\n        timeout = this.manager.globalReset + this.manager.options.offset - Date.now();\n      } else {\n        limit2 = this.limit;\n        timeout = this.timeToReset;\n      }\n      await onRateLimit(this.manager, {\n        timeToReset: timeout,\n        limit: limit2,\n        method,\n        hash: this.hash,\n        url,\n        route: routeId.bucketRoute,\n        majorParameter: this.majorParameter,\n        global: isGlobal\n      });\n      this.debug([\"Encountered unexpected 429 rate limit\", `  Global         : ${isGlobal.toString()}`, `  Method         : ${method}`, `  URL            : ${url}`, `  Bucket         : ${routeId.bucketRoute}`, `  Major parameter: ${routeId.majorParameter}`, `  Hash           : ${this.hash}`, `  Limit          : ${limit2}`, `  Retry After    : ${retryAfter}ms`, `  Sublimit       : ${sublimitTimeout ? `${sublimitTimeout}ms` : \"None\"}`].join(\"\\n\"));\n      if (sublimitTimeout) {\n        const firstSublimit = !this.#sublimitedQueue;\n        if (firstSublimit) {\n          this.#sublimitedQueue = new import_async_queue.AsyncQueue();\n          void this.#sublimitedQueue.wait();\n          this.#asyncQueue.shift();\n        }\n        this.#sublimitPromise?.resolve();\n        this.#sublimitPromise = null;\n        await sleep(sublimitTimeout);\n        let resolve;\n        const promise = new Promise(res2 => resolve = res2);\n        this.#sublimitPromise = {\n          promise,\n          resolve\n        };\n        if (firstSublimit) {\n          await this.#asyncQueue.wait();\n          this.#shiftSublimit = true;\n        }\n      }\n      return this.runRequest(routeId, url, options, requestData, retries);\n    } else {\n      const handled = await handleErrors(this.manager, res, method, url, requestData, retries);\n      if (handled === null) {\n        return this.runRequest(routeId, url, options, requestData, ++retries);\n      }\n      return handled;\n    }\n  }\n};\n\n// src/lib/REST.ts\nvar REST = class _REST extends import_async_event_emitter.AsyncEventEmitter {\n  static {\n    __name(this, \"REST\");\n  }\n  /**\n   * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests\n   * performed by this manager.\n   */\n  agent = null;\n  cdn;\n  /**\n   * The number of requests remaining in the global bucket\n   */\n  globalRemaining;\n  /**\n   * The promise used to wait out the global rate limit\n   */\n  globalDelay = null;\n  /**\n   * The timestamp at which the global bucket resets\n   */\n  globalReset = -1;\n  /**\n   * API bucket hashes that are cached from provided routes\n   */\n  hashes = new import_collection.Collection();\n  /**\n   * Request handlers created from the bucket hash and the major parameters\n   */\n  handlers = new import_collection.Collection();\n  #token = null;\n  hashTimer;\n  handlerTimer;\n  options;\n  constructor(options = {}) {\n    super();\n    this.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn);\n    this.options = {\n      ...DefaultRestOptions,\n      ...options\n    };\n    this.options.offset = Math.max(0, this.options.offset);\n    this.globalRemaining = Math.max(1, this.options.globalRequestsPerSecond);\n    this.agent = options.agent ?? null;\n    this.setupSweepers();\n  }\n  setupSweepers() {\n    const validateMaxInterval = /* @__PURE__ */__name(interval => {\n      if (interval > 144e5) {\n        throw new Error(\"Cannot set an interval greater than 4 hours\");\n      }\n    }, \"validateMaxInterval\");\n    if (this.options.hashSweepInterval !== 0 && this.options.hashSweepInterval !== Number.POSITIVE_INFINITY) {\n      validateMaxInterval(this.options.hashSweepInterval);\n      this.hashTimer = setInterval(() => {\n        const sweptHashes = new import_collection.Collection();\n        const currentDate = Date.now();\n        this.hashes.sweep((val, key) => {\n          if (val.lastAccess === -1) return false;\n          const shouldSweep = Math.floor(currentDate - val.lastAccess) > this.options.hashLifetime;\n          if (shouldSweep) {\n            sweptHashes.set(key, val);\n            this.emit(\"restDebug\" /* Debug */, `Hash ${val.value} for ${key} swept due to lifetime being exceeded`);\n          }\n          return shouldSweep;\n        });\n        this.emit(\"hashSweep\" /* HashSweep */, sweptHashes);\n      }, this.options.hashSweepInterval);\n      this.hashTimer.unref?.();\n    }\n    if (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {\n      validateMaxInterval(this.options.handlerSweepInterval);\n      this.handlerTimer = setInterval(() => {\n        const sweptHandlers = new import_collection.Collection();\n        this.handlers.sweep((val, key) => {\n          const {\n            inactive\n          } = val;\n          if (inactive) {\n            sweptHandlers.set(key, val);\n            this.emit(\"restDebug\" /* Debug */, `Handler ${val.id} for ${key} swept due to being inactive`);\n          }\n          return inactive;\n        });\n        this.emit(\"handlerSweep\" /* HandlerSweep */, sweptHandlers);\n      }, this.options.handlerSweepInterval);\n      this.handlerTimer.unref?.();\n    }\n  }\n  /**\n   * Runs a get request from the api\n   *\n   * @param fullRoute - The full route to query\n   * @param options - Optional request options\n   */\n  async get(fullRoute, options = {}) {\n    return this.request({\n      ...options,\n      fullRoute,\n      method: \"GET\" /* Get */\n    });\n  }\n  /**\n   * Runs a delete request from the api\n   *\n   * @param fullRoute - The full route to query\n   * @param options - Optional request options\n   */\n  async delete(fullRoute, options = {}) {\n    return this.request({\n      ...options,\n      fullRoute,\n      method: \"DELETE\" /* Delete */\n    });\n  }\n  /**\n   * Runs a post request from the api\n   *\n   * @param fullRoute - The full route to query\n   * @param options - Optional request options\n   */\n  async post(fullRoute, options = {}) {\n    return this.request({\n      ...options,\n      fullRoute,\n      method: \"POST\" /* Post */\n    });\n  }\n  /**\n   * Runs a put request from the api\n   *\n   * @param fullRoute - The full route to query\n   * @param options - Optional request options\n   */\n  async put(fullRoute, options = {}) {\n    return this.request({\n      ...options,\n      fullRoute,\n      method: \"PUT\" /* Put */\n    });\n  }\n  /**\n   * Runs a patch request from the api\n   *\n   * @param fullRoute - The full route to query\n   * @param options - Optional request options\n   */\n  async patch(fullRoute, options = {}) {\n    return this.request({\n      ...options,\n      fullRoute,\n      method: \"PATCH\" /* Patch */\n    });\n  }\n  /**\n   * Runs a request from the api\n   *\n   * @param options - Request options\n   */\n  async request(options) {\n    const response = await this.queueRequest(options);\n    return parseResponse(response);\n  }\n  /**\n   * Sets the default agent to use for requests performed by this manager\n   *\n   * @param agent - The agent to use\n   */\n  setAgent(agent) {\n    this.agent = agent;\n    return this;\n  }\n  /**\n   * Sets the authorization token that should be used for requests\n   *\n   * @param token - The authorization token to use\n   */\n  setToken(token) {\n    this.#token = token;\n    return this;\n  }\n  /**\n   * Queues a request to be sent\n   *\n   * @param request - All the information needed to make a request\n   * @returns The response from the api request\n   */\n  async queueRequest(request) {\n    const routeId = _REST.generateRouteData(request.fullRoute, request.method);\n    const hash = this.hashes.get(`${request.method}:${routeId.bucketRoute}`) ?? {\n      value: `Global(${request.method}:${routeId.bucketRoute})`,\n      lastAccess: -1\n    };\n    const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);\n    const {\n      url,\n      fetchOptions\n    } = await this.resolveRequest(request);\n    return handler.queueRequest(routeId, url, fetchOptions, {\n      body: request.body,\n      files: request.files,\n      auth: request.auth !== false,\n      signal: request.signal\n    });\n  }\n  /**\n   * Creates a new rate limit handler from a hash, based on the hash and the major parameter\n   *\n   * @param hash - The hash for the route\n   * @param majorParameter - The major parameter for this handler\n   * @internal\n   */\n  createHandler(hash, majorParameter) {\n    const queue = majorParameter === BurstHandlerMajorIdKey ? new BurstHandler(this, hash, majorParameter) : new SequentialHandler(this, hash, majorParameter);\n    this.handlers.set(queue.id, queue);\n    return queue;\n  }\n  /**\n   * Formats the request data to a usable format for fetch\n   *\n   * @param request - The request data\n   */\n  async resolveRequest(request) {\n    const {\n      options\n    } = this;\n    let query = \"\";\n    if (request.query) {\n      const resolvedQuery = request.query.toString();\n      if (resolvedQuery !== \"\") {\n        query = `?${resolvedQuery}`;\n      }\n    }\n    const headers = {\n      ...this.options.headers,\n      \"User-Agent\": `${DefaultUserAgent} ${options.userAgentAppendix}`.trim()\n    };\n    if (request.auth !== false) {\n      if (!this.#token) {\n        throw new Error(\"Expected token to be set for this request, but none was present\");\n      }\n      headers.Authorization = `${request.authPrefix ?? this.options.authPrefix} ${this.#token}`;\n    }\n    if (request.reason?.length) {\n      headers[\"X-Audit-Log-Reason\"] = encodeURIComponent(request.reason);\n    }\n    const url = `${options.api}${request.versioned === false ? \"\" : `/v${options.version}`}${request.fullRoute}${query}`;\n    let finalBody;\n    let additionalHeaders = {};\n    if (request.files?.length) {\n      const formData = new FormData();\n      for (const [index, file] of request.files.entries()) {\n        const fileKey = file.key ?? `files[${index}]`;\n        if (isBufferLike(file.data)) {\n          let contentType = file.contentType;\n          if (!contentType) {\n            const [parsedType] = (0, import_magic_bytes.filetypeinfo)(file.data);\n            if (parsedType) {\n              contentType = OverwrittenMimeTypes[parsedType.mime] ?? parsedType.mime ?? \"application/octet-stream\";\n            }\n          }\n          formData.append(fileKey, new Blob([file.data], {\n            type: contentType\n          }), file.name);\n        } else {\n          formData.append(fileKey, new Blob([`${file.data}`], {\n            type: file.contentType\n          }), file.name);\n        }\n      }\n      if (request.body != null) {\n        if (request.appendToFormData) {\n          for (const [key, value] of Object.entries(request.body)) {\n            formData.append(key, value);\n          }\n        } else {\n          formData.append(\"payload_json\", JSON.stringify(request.body));\n        }\n      }\n      finalBody = formData;\n    } else if (request.body != null) {\n      if (request.passThroughBody) {\n        finalBody = request.body;\n      } else {\n        finalBody = JSON.stringify(request.body);\n        additionalHeaders = {\n          \"Content-Type\": \"application/json\"\n        };\n      }\n    }\n    const method = request.method.toUpperCase();\n    const fetchOptions = {\n      // Set body to null on get / head requests. This does not follow fetch spec (likely because it causes subtle bugs) but is aligned with what request was doing\n      body: [\"GET\", \"HEAD\"].includes(method) ? null : finalBody,\n      headers: {\n        ...request.headers,\n        ...additionalHeaders,\n        ...headers\n      },\n      method,\n      // Prioritize setting an agent per request, use the agent for this instance otherwise.\n      dispatcher: request.dispatcher ?? this.agent ?? void 0\n    };\n    return {\n      url,\n      fetchOptions\n    };\n  }\n  /**\n   * Stops the hash sweeping interval\n   */\n  clearHashSweeper() {\n    clearInterval(this.hashTimer);\n  }\n  /**\n   * Stops the request handler sweeping interval\n   */\n  clearHandlerSweeper() {\n    clearInterval(this.handlerTimer);\n  }\n  /**\n   * Generates route data for an endpoint:method\n   *\n   * @param endpoint - The raw endpoint to generalize\n   * @param method - The HTTP method this endpoint is called without\n   * @internal\n   */\n  static generateRouteData(endpoint, method) {\n    if (endpoint.startsWith(\"/interactions/\") && endpoint.endsWith(\"/callback\")) {\n      return {\n        majorParameter: BurstHandlerMajorIdKey,\n        bucketRoute: \"/interactions/:id/:token/callback\",\n        original: endpoint\n      };\n    }\n    const majorIdMatch = /^\\/(?:channels|guilds|webhooks)\\/(\\d{17,19})/.exec(endpoint);\n    const majorId = majorIdMatch?.[1] ?? \"global\";\n    const baseRoute = endpoint.replaceAll(/\\d{17,19}/g, \":id\").replace(/\\/reactions\\/(.*)/, \"/reactions/:reaction\");\n    let exceptions = \"\";\n    if (method === \"DELETE\" /* Delete */ && baseRoute === \"/channels/:id/messages/:id\") {\n      const id = /\\d{17,19}$/.exec(endpoint)[0];\n      const timestamp = import_snowflake.DiscordSnowflake.timestampFrom(id);\n      if (Date.now() - timestamp > 1e3 * 60 * 60 * 24 * 14) {\n        exceptions += \"/Delete Old Message\";\n      }\n    }\n    return {\n      majorParameter: majorId,\n      bucketRoute: baseRoute + exceptions,\n      original: endpoint\n    };\n  }\n};\n\n// src/shared.ts\nvar version = \"2.0.1\";\n\n// src/web.ts\nsetDefaultStrategy(fetch);\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  ALLOWED_EXTENSIONS,\n  ALLOWED_SIZES,\n  ALLOWED_STICKER_EXTENSIONS,\n  BurstHandlerMajorIdKey,\n  CDN,\n  DefaultRestOptions,\n  DefaultUserAgent,\n  DefaultUserAgentAppendix,\n  DiscordAPIError,\n  HTTPError,\n  OverwrittenMimeTypes,\n  REST,\n  RESTEvents,\n  RateLimitError,\n  RequestMethod,\n  calculateUserDefaultAvatarIndex,\n  makeURLSearchParams,\n  parseResponse,\n  version\n});","map":{"version":3,"names":["web_exports","__export","ALLOWED_EXTENSIONS","ALLOWED_SIZES","ALLOWED_STICKER_EXTENSIONS","BurstHandlerMajorIdKey","CDN","DefaultRestOptions","DefaultUserAgent","DefaultUserAgentAppendix","DiscordAPIError","HTTPError","OverwrittenMimeTypes","REST","RESTEvents","RateLimitError","RequestMethod","calculateUserDefaultAvatarIndex","makeURLSearchParams","parseResponse","version","module","exports","__toCommonJS","defaultStrategy","setDefaultStrategy","newStrategy","__name","getDefaultStrategy","import_util","require","import_v10","getUserAgentAppendix","agent","api","authPrefix","cdn","headers","invalidRequestWarningInterval","globalRequestsPerSecond","offset","rejectOnRateLimit","retries","timeout","userAgentAppendix","APIVersion","hashSweepInterval","hashLifetime","handlerSweepInterval","makeRequest","args","RESTEvents2","constructor","base","appAsset","clientId","assetHash","options","makeURL","appIcon","iconHash","avatar","id","avatarHash","dynamicMakeURL","avatarDecoration","userId","userAvatarDecoration","banner","bannerHash","channelIcon","channelId","defaultAvatar","index","extension","discoverySplash","guildId","splashHash","emoji","emojiId","guildMemberAvatar","guildMemberBanner","icon","roleIcon","roleId","roleIconHash","splash","sticker","stickerId","allowedExtensions","stickerPackBanner","bannerId","teamIcon","teamId","guildScheduledEventCover","scheduledEventId","coverHash","route","hash","forceStatic","startsWith","size","String","toLowerCase","includes","RangeError","join","url","URL","searchParams","set","toString","isErrorGroupWrapper","error","Reflect","has","isErrorResponse","get","_DiscordAPIError","Error","rawError","code","status","method","bodyData","getMessage","requestBody","files","json","body","name","flattened","errors","flattenDiscordError","message","error_description","obj","key","length","trim","otherKey","val","Object","entries","nextKey","Number","isNaN","_errors","_HTTPError","statusText","_RateLimitError","timeToReset","limit","majorParameter","global","import_collection","import_snowflake","import_async_event_emitter","import_magic_bytes","RequestMethod2","serializeSearchParam","value","Date","getTime","toISOString","prototype","params","URLSearchParams","serialized","append","res","arrayBuffer","hasSublimit","bucketRoute","castedBody","some","shouldRetry","onRateLimit","manager","rateLimitData","shouldThrow","BigInt","sleep","ms","Promise","resolve","setTimeout","isBufferLike","ArrayBuffer","Uint8Array","Uint8ClampedArray","invalidCount","invalidCountResetTime","incrementInvalidCount","now","emitInvalid","emit","count","remainingTime","makeNetworkRequest","routeId","requestData","controller","AbortController","abort","signal","aborted","addEventListener","clearTimeout","listenerCount","path","original","data","Response","clone","handleErrors","auth","setToken","BurstHandler","inactive","debug","queueRequest","runRequest","retryAfter","retry","isGlobal","POSITIVE_INFINITY","handled","import_async_queue","SequentialHandler","reset","remaining","asyncQueue","AsyncQueue","sublimitedQueue","sublimitPromise","shiftSublimit","limited","globalLimited","globalRemaining","globalReset","localLimited","globalDelayFor","time","globalDelay","queue","queueType","wait","shift","promise","limit2","delay","hashes","lastAccess","hashData","sublimitTimeout","ok","firstSublimit","res2","_REST","AsyncEventEmitter","Collection","handlers","token","hashTimer","handlerTimer","Math","max","setupSweepers","validateMaxInterval","interval","setInterval","sweptHashes","currentDate","sweep","shouldSweep","floor","unref","sweptHandlers","fullRoute","request","delete","post","put","patch","response","setAgent","generateRouteData","handler","createHandler","fetchOptions","resolveRequest","query","resolvedQuery","Authorization","reason","encodeURIComponent","versioned","finalBody","additionalHeaders","formData","FormData","file","fileKey","contentType","parsedType","filetypeinfo","mime","Blob","type","appendToFormData","JSON","stringify","passThroughBody","toUpperCase","dispatcher","clearHashSweeper","clearInterval","clearHandlerSweeper","endpoint","endsWith","majorIdMatch","exec","majorId","baseRoute","replaceAll","replace","exceptions","timestamp","DiscordSnowflake","timestampFrom","fetch"],"sources":["C:\\Users\\hetit\\node_modules\\@discordjs\\rest\\src\\web.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\rest\\src\\environment.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\rest\\src\\lib\\utils\\constants.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\rest\\src\\lib\\CDN.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\rest\\src\\lib\\errors\\DiscordAPIError.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\rest\\src\\lib\\errors\\HTTPError.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\rest\\src\\lib\\errors\\RateLimitError.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\rest\\src\\lib\\REST.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\rest\\src\\lib\\utils\\types.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\rest\\src\\lib\\utils\\utils.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\rest\\src\\lib\\handlers\\Shared.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\rest\\src\\lib\\handlers\\BurstHandler.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\rest\\src\\lib\\handlers\\SequentialHandler.ts","C:\\Users\\hetit\\node_modules\\@discordjs\\rest\\src\\shared.ts"],"sourcesContent":["import { setDefaultStrategy } from './environment.js';\n\nsetDefaultStrategy(fetch);\n\nexport * from './shared.js';\n","import type { RESTOptions } from './shared.js';\n\nlet defaultStrategy: RESTOptions['makeRequest'];\n\nexport function setDefaultStrategy(newStrategy: RESTOptions['makeRequest']) {\n\tdefaultStrategy = newStrategy;\n}\n\nexport function getDefaultStrategy() {\n\treturn defaultStrategy;\n}\n","import { getUserAgentAppendix } from '@discordjs/util';\nimport { APIVersion } from 'discord-api-types/v10';\nimport { getDefaultStrategy } from '../../environment.js';\nimport type { RESTOptions, ResponseLike } from './types.js';\n\nexport const DefaultUserAgent =\n\t`DiscordBot (https://discord.js.org, 2.0.1)` as `DiscordBot (https://discord.js.org, ${string})`;\n\n/**\n * The default string to append onto the user agent.\n */\nexport const DefaultUserAgentAppendix = getUserAgentAppendix();\n\nexport const DefaultRestOptions = {\n\tagent: null,\n\tapi: 'https://discord.com/api',\n\tauthPrefix: 'Bot',\n\tcdn: 'https://cdn.discordapp.com',\n\theaders: {},\n\tinvalidRequestWarningInterval: 0,\n\tglobalRequestsPerSecond: 50,\n\toffset: 50,\n\trejectOnRateLimit: null,\n\tretries: 3,\n\ttimeout: 15_000,\n\tuserAgentAppendix: DefaultUserAgentAppendix,\n\tversion: APIVersion,\n\thashSweepInterval: 14_400_000, // 4 Hours\n\thashLifetime: 86_400_000, // 24 Hours\n\thandlerSweepInterval: 3_600_000, // 1 Hour\n\tasync makeRequest(...args): Promise<ResponseLike> {\n\t\treturn getDefaultStrategy()(...args);\n\t},\n} as const satisfies Required<RESTOptions>;\n\n/**\n * The events that the REST manager emits\n */\nexport enum RESTEvents {\n\tDebug = 'restDebug',\n\tHandlerSweep = 'handlerSweep',\n\tHashSweep = 'hashSweep',\n\tInvalidRequestWarning = 'invalidRequestWarning',\n\tRateLimited = 'rateLimited',\n\tResponse = 'response',\n}\n\nexport const ALLOWED_EXTENSIONS = ['webp', 'png', 'jpg', 'jpeg', 'gif'] as const satisfies readonly string[];\nexport const ALLOWED_STICKER_EXTENSIONS = ['png', 'json', 'gif'] as const satisfies readonly string[];\nexport const ALLOWED_SIZES = [16, 32, 64, 128, 256, 512, 1_024, 2_048, 4_096] as const satisfies readonly number[];\n\nexport type ImageExtension = (typeof ALLOWED_EXTENSIONS)[number];\nexport type StickerExtension = (typeof ALLOWED_STICKER_EXTENSIONS)[number];\nexport type ImageSize = (typeof ALLOWED_SIZES)[number];\n\nexport const OverwrittenMimeTypes = {\n\t// https://github.com/discordjs/discord.js/issues/8557\n\t'image/apng': 'image/png',\n} as const satisfies Readonly<Record<string, string>>;\n\nexport const BurstHandlerMajorIdKey = 'burst';\n","/* eslint-disable jsdoc/check-param-names */\nimport {\n\tALLOWED_EXTENSIONS,\n\tALLOWED_SIZES,\n\tALLOWED_STICKER_EXTENSIONS,\n\tDefaultRestOptions,\n\ttype ImageExtension,\n\ttype ImageSize,\n\ttype StickerExtension,\n} from './utils/constants.js';\n\n/**\n * The options used for image URLs\n */\nexport interface BaseImageURLOptions {\n\t/**\n\t * The extension to use for the image URL\n\t *\n\t * @defaultValue `'webp'`\n\t */\n\textension?: ImageExtension;\n\t/**\n\t * The size specified in the image URL\n\t */\n\tsize?: ImageSize;\n}\n\n/**\n * The options used for image URLs with animated content\n */\nexport interface ImageURLOptions extends BaseImageURLOptions {\n\t/**\n\t * Whether or not to prefer the static version of an image asset.\n\t */\n\tforceStatic?: boolean;\n}\n\n/**\n * The options to use when making a CDN URL\n */\nexport interface MakeURLOptions {\n\t/**\n\t * The allowed extensions that can be used\n\t */\n\tallowedExtensions?: readonly string[];\n\t/**\n\t * The extension to use for the image URL\n\t *\n\t * @defaultValue `'webp'`\n\t */\n\textension?: string | undefined;\n\t/**\n\t * The size specified in the image URL\n\t */\n\tsize?: ImageSize;\n}\n\n/**\n * The CDN link builder\n */\nexport class CDN {\n\tpublic constructor(private readonly base: string = DefaultRestOptions.cdn) {}\n\n\t/**\n\t * Generates an app asset URL for a client's asset.\n\t *\n\t * @param clientId - The client id that has the asset\n\t * @param assetHash - The hash provided by Discord for this asset\n\t * @param options - Optional options for the asset\n\t */\n\tpublic appAsset(clientId: string, assetHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/app-assets/${clientId}/${assetHash}`, options);\n\t}\n\n\t/**\n\t * Generates an app icon URL for a client's icon.\n\t *\n\t * @param clientId - The client id that has the icon\n\t * @param iconHash - The hash provided by Discord for this icon\n\t * @param options - Optional options for the icon\n\t */\n\tpublic appIcon(clientId: string, iconHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/app-icons/${clientId}/${iconHash}`, options);\n\t}\n\n\t/**\n\t * Generates an avatar URL, e.g. for a user or a webhook.\n\t *\n\t * @param id - The id that has the icon\n\t * @param avatarHash - The hash provided by Discord for this avatar\n\t * @param options - Optional options for the avatar\n\t */\n\tpublic avatar(id: string, avatarHash: string, options?: Readonly<ImageURLOptions>): string {\n\t\treturn this.dynamicMakeURL(`/avatars/${id}/${avatarHash}`, avatarHash, options);\n\t}\n\n\t/**\n\t * Generates a user avatar decoration URL.\n\t *\n\t * @param userId - The id of the user\n\t * @param userAvatarDecoration - The hash provided by Discord for this avatar decoration\n\t * @param options - Optional options for the avatar decoration\n\t */\n\tpublic avatarDecoration(\n\t\tuserId: string,\n\t\tuserAvatarDecoration: string,\n\t\toptions?: Readonly<BaseImageURLOptions>,\n\t): string {\n\t\treturn this.makeURL(`/avatar-decorations/${userId}/${userAvatarDecoration}`, options);\n\t}\n\n\t/**\n\t * Generates a banner URL, e.g. for a user or a guild.\n\t *\n\t * @param id - The id that has the banner splash\n\t * @param bannerHash - The hash provided by Discord for this banner\n\t * @param options - Optional options for the banner\n\t */\n\tpublic banner(id: string, bannerHash: string, options?: Readonly<ImageURLOptions>): string {\n\t\treturn this.dynamicMakeURL(`/banners/${id}/${bannerHash}`, bannerHash, options);\n\t}\n\n\t/**\n\t * Generates an icon URL for a channel, e.g. a group DM.\n\t *\n\t * @param channelId - The channel id that has the icon\n\t * @param iconHash - The hash provided by Discord for this channel\n\t * @param options - Optional options for the icon\n\t */\n\tpublic channelIcon(channelId: string, iconHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/channel-icons/${channelId}/${iconHash}`, options);\n\t}\n\n\t/**\n\t * Generates a default avatar URL\n\t *\n\t * @param index - The default avatar index\n\t * @remarks\n\t * To calculate the index for a user do `(userId >> 22) % 6`,\n\t * or `discriminator % 5` if they're using the legacy username system.\n\t */\n\tpublic defaultAvatar(index: number): string {\n\t\treturn this.makeURL(`/embed/avatars/${index}`, { extension: 'png' });\n\t}\n\n\t/**\n\t * Generates a discovery splash URL for a guild's discovery splash.\n\t *\n\t * @param guildId - The guild id that has the discovery splash\n\t * @param splashHash - The hash provided by Discord for this splash\n\t * @param options - Optional options for the splash\n\t */\n\tpublic discoverySplash(guildId: string, splashHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/discovery-splashes/${guildId}/${splashHash}`, options);\n\t}\n\n\t/**\n\t * Generates an emoji's URL for an emoji.\n\t *\n\t * @param emojiId - The emoji id\n\t * @param extension - The extension of the emoji\n\t */\n\tpublic emoji(emojiId: string, extension?: ImageExtension): string {\n\t\treturn this.makeURL(`/emojis/${emojiId}`, { extension });\n\t}\n\n\t/**\n\t * Generates a guild member avatar URL.\n\t *\n\t * @param guildId - The id of the guild\n\t * @param userId - The id of the user\n\t * @param avatarHash - The hash provided by Discord for this avatar\n\t * @param options - Optional options for the avatar\n\t */\n\tpublic guildMemberAvatar(\n\t\tguildId: string,\n\t\tuserId: string,\n\t\tavatarHash: string,\n\t\toptions?: Readonly<ImageURLOptions>,\n\t): string {\n\t\treturn this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/avatars/${avatarHash}`, avatarHash, options);\n\t}\n\n\t/**\n\t * Generates a guild member banner URL.\n\t *\n\t * @param guildId - The id of the guild\n\t * @param userId - The id of the user\n\t * @param bannerHash - The hash provided by Discord for this banner\n\t * @param options - Optional options for the banner\n\t */\n\tpublic guildMemberBanner(\n\t\tguildId: string,\n\t\tuserId: string,\n\t\tbannerHash: string,\n\t\toptions?: Readonly<ImageURLOptions>,\n\t): string {\n\t\treturn this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/banner`, bannerHash, options);\n\t}\n\n\t/**\n\t * Generates an icon URL, e.g. for a guild.\n\t *\n\t * @param id - The id that has the icon splash\n\t * @param iconHash - The hash provided by Discord for this icon\n\t * @param options - Optional options for the icon\n\t */\n\tpublic icon(id: string, iconHash: string, options?: Readonly<ImageURLOptions>): string {\n\t\treturn this.dynamicMakeURL(`/icons/${id}/${iconHash}`, iconHash, options);\n\t}\n\n\t/**\n\t * Generates a URL for the icon of a role\n\t *\n\t * @param roleId - The id of the role that has the icon\n\t * @param roleIconHash - The hash provided by Discord for this role icon\n\t * @param options - Optional options for the role icon\n\t */\n\tpublic roleIcon(roleId: string, roleIconHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/role-icons/${roleId}/${roleIconHash}`, options);\n\t}\n\n\t/**\n\t * Generates a guild invite splash URL for a guild's invite splash.\n\t *\n\t * @param guildId - The guild id that has the invite splash\n\t * @param splashHash - The hash provided by Discord for this splash\n\t * @param options - Optional options for the splash\n\t */\n\tpublic splash(guildId: string, splashHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/splashes/${guildId}/${splashHash}`, options);\n\t}\n\n\t/**\n\t * Generates a sticker URL.\n\t *\n\t * @param stickerId - The sticker id\n\t * @param extension - The extension of the sticker\n\t * @privateRemarks\n\t * Stickers cannot have a `.webp` extension, so we default to a `.png`\n\t */\n\tpublic sticker(stickerId: string, extension: StickerExtension = 'png'): string {\n\t\treturn this.makeURL(`/stickers/${stickerId}`, { allowedExtensions: ALLOWED_STICKER_EXTENSIONS, extension });\n\t}\n\n\t/**\n\t * Generates a sticker pack banner URL.\n\t *\n\t * @param bannerId - The banner id\n\t * @param options - Optional options for the banner\n\t */\n\tpublic stickerPackBanner(bannerId: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/app-assets/710982414301790216/store/${bannerId}`, options);\n\t}\n\n\t/**\n\t * Generates a team icon URL for a team's icon.\n\t *\n\t * @param teamId - The team id that has the icon\n\t * @param iconHash - The hash provided by Discord for this icon\n\t * @param options - Optional options for the icon\n\t */\n\tpublic teamIcon(teamId: string, iconHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/team-icons/${teamId}/${iconHash}`, options);\n\t}\n\n\t/**\n\t * Generates a cover image for a guild scheduled event.\n\t *\n\t * @param scheduledEventId - The scheduled event id\n\t * @param coverHash - The hash provided by discord for this cover image\n\t * @param options - Optional options for the cover image\n\t */\n\tpublic guildScheduledEventCover(\n\t\tscheduledEventId: string,\n\t\tcoverHash: string,\n\t\toptions?: Readonly<BaseImageURLOptions>,\n\t): string {\n\t\treturn this.makeURL(`/guild-events/${scheduledEventId}/${coverHash}`, options);\n\t}\n\n\t/**\n\t * Constructs the URL for the resource, checking whether or not `hash` starts with `a_` if `dynamic` is set to `true`.\n\t *\n\t * @param route - The base cdn route\n\t * @param hash - The hash provided by Discord for this icon\n\t * @param options - Optional options for the link\n\t */\n\tprivate dynamicMakeURL(\n\t\troute: string,\n\t\thash: string,\n\t\t{ forceStatic = false, ...options }: Readonly<ImageURLOptions> = {},\n\t): string {\n\t\treturn this.makeURL(route, !forceStatic && hash.startsWith('a_') ? { ...options, extension: 'gif' } : options);\n\t}\n\n\t/**\n\t * Constructs the URL for the resource\n\t *\n\t * @param route - The base cdn route\n\t * @param options - The extension/size options for the link\n\t */\n\tprivate makeURL(\n\t\troute: string,\n\t\t{ allowedExtensions = ALLOWED_EXTENSIONS, extension = 'webp', size }: Readonly<MakeURLOptions> = {},\n\t): string {\n\t\t// eslint-disable-next-line no-param-reassign\n\t\textension = String(extension).toLowerCase();\n\n\t\tif (!allowedExtensions.includes(extension)) {\n\t\t\tthrow new RangeError(`Invalid extension provided: ${extension}\\nMust be one of: ${allowedExtensions.join(', ')}`);\n\t\t}\n\n\t\tif (size && !ALLOWED_SIZES.includes(size)) {\n\t\t\tthrow new RangeError(`Invalid size provided: ${size}\\nMust be one of: ${ALLOWED_SIZES.join(', ')}`);\n\t\t}\n\n\t\tconst url = new URL(`${this.base}${route}.${extension}`);\n\n\t\tif (size) {\n\t\t\turl.searchParams.set('size', String(size));\n\t\t}\n\n\t\treturn url.toString();\n\t}\n}\n","import type { InternalRequest, RawFile } from '../utils/types.js';\n\ninterface DiscordErrorFieldInformation {\n\tcode: string;\n\tmessage: string;\n}\n\ninterface DiscordErrorGroupWrapper {\n\t_errors: DiscordError[];\n}\n\ntype DiscordError = DiscordErrorFieldInformation | DiscordErrorGroupWrapper | string | { [k: string]: DiscordError };\n\nexport interface DiscordErrorData {\n\tcode: number;\n\terrors?: DiscordError;\n\tmessage: string;\n}\n\nexport interface OAuthErrorData {\n\terror: string;\n\terror_description?: string;\n}\n\nexport interface RequestBody {\n\tfiles: RawFile[] | undefined;\n\tjson: unknown | undefined;\n}\n\nfunction isErrorGroupWrapper(error: DiscordError): error is DiscordErrorGroupWrapper {\n\treturn Reflect.has(error as Record<string, unknown>, '_errors');\n}\n\nfunction isErrorResponse(error: DiscordError): error is DiscordErrorFieldInformation {\n\treturn typeof Reflect.get(error as Record<string, unknown>, 'message') === 'string';\n}\n\n/**\n * Represents an API error returned by Discord\n */\nexport class DiscordAPIError extends Error {\n\tpublic requestBody: RequestBody;\n\n\t/**\n\t * @param rawError - The error reported by Discord\n\t * @param code - The error code reported by Discord\n\t * @param status - The status code of the response\n\t * @param method - The method of the request that erred\n\t * @param url - The url of the request that erred\n\t * @param bodyData - The unparsed data for the request that errored\n\t */\n\tpublic constructor(\n\t\tpublic rawError: DiscordErrorData | OAuthErrorData,\n\t\tpublic code: number | string,\n\t\tpublic status: number,\n\t\tpublic method: string,\n\t\tpublic url: string,\n\t\tbodyData: Pick<InternalRequest, 'body' | 'files'>,\n\t) {\n\t\tsuper(DiscordAPIError.getMessage(rawError));\n\n\t\tthis.requestBody = { files: bodyData.files, json: bodyData.body };\n\t}\n\n\t/**\n\t * The name of the error\n\t */\n\tpublic override get name(): string {\n\t\treturn `${DiscordAPIError.name}[${this.code}]`;\n\t}\n\n\tprivate static getMessage(error: DiscordErrorData | OAuthErrorData) {\n\t\tlet flattened = '';\n\t\tif ('code' in error) {\n\t\t\tif (error.errors) {\n\t\t\t\tflattened = [...this.flattenDiscordError(error.errors)].join('\\n');\n\t\t\t}\n\n\t\t\treturn error.message && flattened\n\t\t\t\t? `${error.message}\\n${flattened}`\n\t\t\t\t: error.message || flattened || 'Unknown Error';\n\t\t}\n\n\t\treturn error.error_description ?? 'No Description';\n\t}\n\n\tprivate static *flattenDiscordError(obj: DiscordError, key = ''): IterableIterator<string> {\n\t\tif (isErrorResponse(obj)) {\n\t\t\treturn yield `${key.length ? `${key}[${obj.code}]` : `${obj.code}`}: ${obj.message}`.trim();\n\t\t}\n\n\t\tfor (const [otherKey, val] of Object.entries(obj)) {\n\t\t\tconst nextKey = otherKey.startsWith('_')\n\t\t\t\t? key\n\t\t\t\t: key\n\t\t\t\t? Number.isNaN(Number(otherKey))\n\t\t\t\t\t? `${key}.${otherKey}`\n\t\t\t\t\t: `${key}[${otherKey}]`\n\t\t\t\t: otherKey;\n\n\t\t\tif (typeof val === 'string') {\n\t\t\t\tyield val;\n\t\t\t} else if (isErrorGroupWrapper(val)) {\n\t\t\t\tfor (const error of val._errors) {\n\t\t\t\t\tyield* this.flattenDiscordError(error, nextKey);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tyield* this.flattenDiscordError(val, nextKey);\n\t\t\t}\n\t\t}\n\t}\n}\n","import type { InternalRequest } from '../utils/types.js';\nimport type { RequestBody } from './DiscordAPIError.js';\n\n/**\n * Represents a HTTP error\n */\nexport class HTTPError extends Error {\n\tpublic requestBody: RequestBody;\n\n\tpublic override name = HTTPError.name;\n\n\t/**\n\t * @param status - The status code of the response\n\t * @param statusText - The status text of the response\n\t * @param method - The method of the request that erred\n\t * @param url - The url of the request that erred\n\t * @param bodyData - The unparsed data for the request that errored\n\t */\n\tpublic constructor(\n\t\tpublic status: number,\n\t\tstatusText: string,\n\t\tpublic method: string,\n\t\tpublic url: string,\n\t\tbodyData: Pick<InternalRequest, 'body' | 'files'>,\n\t) {\n\t\tsuper(statusText);\n\t\tthis.requestBody = { files: bodyData.files, json: bodyData.body };\n\t}\n}\n","import type { RateLimitData } from '../utils/types.js';\n\nexport class RateLimitError extends Error implements RateLimitData {\n\tpublic timeToReset: number;\n\n\tpublic limit: number;\n\n\tpublic method: string;\n\n\tpublic hash: string;\n\n\tpublic url: string;\n\n\tpublic route: string;\n\n\tpublic majorParameter: string;\n\n\tpublic global: boolean;\n\n\tpublic constructor({ timeToReset, limit, method, hash, url, route, majorParameter, global }: RateLimitData) {\n\t\tsuper();\n\t\tthis.timeToReset = timeToReset;\n\t\tthis.limit = limit;\n\t\tthis.method = method;\n\t\tthis.hash = hash;\n\t\tthis.url = url;\n\t\tthis.route = route;\n\t\tthis.majorParameter = majorParameter;\n\t\tthis.global = global;\n\t}\n\n\t/**\n\t * The name of the error\n\t */\n\tpublic override get name(): string {\n\t\treturn `${RateLimitError.name}[${this.route}]`;\n\t}\n}\n","import { Collection } from '@discordjs/collection';\nimport { DiscordSnowflake } from '@sapphire/snowflake';\nimport { AsyncEventEmitter } from '@vladfrangu/async_event_emitter';\nimport { filetypeinfo } from 'magic-bytes.js';\nimport type { RequestInit, BodyInit, Dispatcher } from 'undici';\nimport { CDN } from './CDN.js';\nimport { BurstHandler } from './handlers/BurstHandler.js';\nimport { SequentialHandler } from './handlers/SequentialHandler.js';\nimport type { IHandler } from './interfaces/Handler.js';\nimport {\n\tBurstHandlerMajorIdKey,\n\tDefaultRestOptions,\n\tDefaultUserAgent,\n\tOverwrittenMimeTypes,\n\tRESTEvents,\n} from './utils/constants.js';\nimport { RequestMethod } from './utils/types.js';\nimport type {\n\tRESTOptions,\n\tResponseLike,\n\tRestEventsMap,\n\tHashData,\n\tInternalRequest,\n\tRouteLike,\n\tRequestHeaders,\n\tRouteData,\n\tRequestData,\n} from './utils/types.js';\nimport { isBufferLike, parseResponse } from './utils/utils.js';\n\n/**\n * Represents the class that manages handlers for endpoints\n */\nexport class REST extends AsyncEventEmitter<RestEventsMap> {\n\t/**\n\t * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests\n\t * performed by this manager.\n\t */\n\tpublic agent: Dispatcher | null = null;\n\n\tpublic readonly cdn: CDN;\n\n\t/**\n\t * The number of requests remaining in the global bucket\n\t */\n\tpublic globalRemaining: number;\n\n\t/**\n\t * The promise used to wait out the global rate limit\n\t */\n\tpublic globalDelay: Promise<void> | null = null;\n\n\t/**\n\t * The timestamp at which the global bucket resets\n\t */\n\tpublic globalReset = -1;\n\n\t/**\n\t * API bucket hashes that are cached from provided routes\n\t */\n\tpublic readonly hashes = new Collection<string, HashData>();\n\n\t/**\n\t * Request handlers created from the bucket hash and the major parameters\n\t */\n\tpublic readonly handlers = new Collection<string, IHandler>();\n\n\t#token: string | null = null;\n\n\tprivate hashTimer!: NodeJS.Timer | number;\n\n\tprivate handlerTimer!: NodeJS.Timer | number;\n\n\tpublic readonly options: RESTOptions;\n\n\tpublic constructor(options: Partial<RESTOptions> = {}) {\n\t\tsuper();\n\t\tthis.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn);\n\t\tthis.options = { ...DefaultRestOptions, ...options };\n\t\tthis.options.offset = Math.max(0, this.options.offset);\n\t\tthis.globalRemaining = Math.max(1, this.options.globalRequestsPerSecond);\n\t\tthis.agent = options.agent ?? null;\n\n\t\t// Start sweepers\n\t\tthis.setupSweepers();\n\t}\n\n\tprivate setupSweepers() {\n\t\t// eslint-disable-next-line unicorn/consistent-function-scoping\n\t\tconst validateMaxInterval = (interval: number) => {\n\t\t\tif (interval > 14_400_000) {\n\t\t\t\tthrow new Error('Cannot set an interval greater than 4 hours');\n\t\t\t}\n\t\t};\n\n\t\tif (this.options.hashSweepInterval !== 0 && this.options.hashSweepInterval !== Number.POSITIVE_INFINITY) {\n\t\t\tvalidateMaxInterval(this.options.hashSweepInterval);\n\t\t\tthis.hashTimer = setInterval(() => {\n\t\t\t\tconst sweptHashes = new Collection<string, HashData>();\n\t\t\t\tconst currentDate = Date.now();\n\n\t\t\t\t// Begin sweeping hash based on lifetimes\n\t\t\t\tthis.hashes.sweep((val, key) => {\n\t\t\t\t\t// `-1` indicates a global hash\n\t\t\t\t\tif (val.lastAccess === -1) return false;\n\n\t\t\t\t\t// Check if lifetime has been exceeded\n\t\t\t\t\tconst shouldSweep = Math.floor(currentDate - val.lastAccess) > this.options.hashLifetime;\n\n\t\t\t\t\t// Add hash to collection of swept hashes\n\t\t\t\t\tif (shouldSweep) {\n\t\t\t\t\t\t// Add to swept hashes\n\t\t\t\t\t\tsweptHashes.set(key, val);\n\n\t\t\t\t\t\t// Emit debug information\n\t\t\t\t\t\tthis.emit(RESTEvents.Debug, `Hash ${val.value} for ${key} swept due to lifetime being exceeded`);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn shouldSweep;\n\t\t\t\t});\n\n\t\t\t\t// Fire event\n\t\t\t\tthis.emit(RESTEvents.HashSweep, sweptHashes);\n\t\t\t}, this.options.hashSweepInterval);\n\n\t\t\tthis.hashTimer.unref?.();\n\t\t}\n\n\t\tif (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {\n\t\t\tvalidateMaxInterval(this.options.handlerSweepInterval);\n\t\t\tthis.handlerTimer = setInterval(() => {\n\t\t\t\tconst sweptHandlers = new Collection<string, IHandler>();\n\n\t\t\t\t// Begin sweeping handlers based on activity\n\t\t\t\tthis.handlers.sweep((val, key) => {\n\t\t\t\t\tconst { inactive } = val;\n\n\t\t\t\t\t// Collect inactive handlers\n\t\t\t\t\tif (inactive) {\n\t\t\t\t\t\tsweptHandlers.set(key, val);\n\t\t\t\t\t\tthis.emit(RESTEvents.Debug, `Handler ${val.id} for ${key} swept due to being inactive`);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn inactive;\n\t\t\t\t});\n\n\t\t\t\t// Fire event\n\t\t\t\tthis.emit(RESTEvents.HandlerSweep, sweptHandlers);\n\t\t\t}, this.options.handlerSweepInterval);\n\n\t\t\tthis.handlerTimer.unref?.();\n\t\t}\n\t}\n\n\t/**\n\t * Runs a get request from the api\n\t *\n\t * @param fullRoute - The full route to query\n\t * @param options - Optional request options\n\t */\n\tpublic async get(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Get });\n\t}\n\n\t/**\n\t * Runs a delete request from the api\n\t *\n\t * @param fullRoute - The full route to query\n\t * @param options - Optional request options\n\t */\n\tpublic async delete(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Delete });\n\t}\n\n\t/**\n\t * Runs a post request from the api\n\t *\n\t * @param fullRoute - The full route to query\n\t * @param options - Optional request options\n\t */\n\tpublic async post(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Post });\n\t}\n\n\t/**\n\t * Runs a put request from the api\n\t *\n\t * @param fullRoute - The full route to query\n\t * @param options - Optional request options\n\t */\n\tpublic async put(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Put });\n\t}\n\n\t/**\n\t * Runs a patch request from the api\n\t *\n\t * @param fullRoute - The full route to query\n\t * @param options - Optional request options\n\t */\n\tpublic async patch(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Patch });\n\t}\n\n\t/**\n\t * Runs a request from the api\n\t *\n\t * @param options - Request options\n\t */\n\tpublic async request(options: InternalRequest) {\n\t\tconst response = await this.queueRequest(options);\n\t\treturn parseResponse(response);\n\t}\n\n\t/**\n\t * Sets the default agent to use for requests performed by this manager\n\t *\n\t * @param agent - The agent to use\n\t */\n\tpublic setAgent(agent: Dispatcher) {\n\t\tthis.agent = agent;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the authorization token that should be used for requests\n\t *\n\t * @param token - The authorization token to use\n\t */\n\tpublic setToken(token: string) {\n\t\tthis.#token = token;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Queues a request to be sent\n\t *\n\t * @param request - All the information needed to make a request\n\t * @returns The response from the api request\n\t */\n\tpublic async queueRequest(request: InternalRequest): Promise<ResponseLike> {\n\t\t// Generalize the endpoint to its route data\n\t\tconst routeId = REST.generateRouteData(request.fullRoute, request.method);\n\t\t// Get the bucket hash for the generic route, or point to a global route otherwise\n\t\tconst hash = this.hashes.get(`${request.method}:${routeId.bucketRoute}`) ?? {\n\t\t\tvalue: `Global(${request.method}:${routeId.bucketRoute})`,\n\t\t\tlastAccess: -1,\n\t\t};\n\n\t\t// Get the request handler for the obtained hash, with its major parameter\n\t\tconst handler =\n\t\t\tthis.handlers.get(`${hash.value}:${routeId.majorParameter}`) ??\n\t\t\tthis.createHandler(hash.value, routeId.majorParameter);\n\n\t\t// Resolve the request into usable fetch options\n\t\tconst { url, fetchOptions } = await this.resolveRequest(request);\n\n\t\t// Queue the request\n\t\treturn handler.queueRequest(routeId, url, fetchOptions, {\n\t\t\tbody: request.body,\n\t\t\tfiles: request.files,\n\t\t\tauth: request.auth !== false,\n\t\t\tsignal: request.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Creates a new rate limit handler from a hash, based on the hash and the major parameter\n\t *\n\t * @param hash - The hash for the route\n\t * @param majorParameter - The major parameter for this handler\n\t * @internal\n\t */\n\tprivate createHandler(hash: string, majorParameter: string) {\n\t\t// Create the async request queue to handle requests\n\t\tconst queue =\n\t\t\tmajorParameter === BurstHandlerMajorIdKey\n\t\t\t\t? new BurstHandler(this, hash, majorParameter)\n\t\t\t\t: new SequentialHandler(this, hash, majorParameter);\n\t\t// Save the queue based on its id\n\t\tthis.handlers.set(queue.id, queue);\n\n\t\treturn queue;\n\t}\n\n\t/**\n\t * Formats the request data to a usable format for fetch\n\t *\n\t * @param request - The request data\n\t */\n\tprivate async resolveRequest(request: InternalRequest): Promise<{ fetchOptions: RequestInit; url: string }> {\n\t\tconst { options } = this;\n\n\t\tlet query = '';\n\n\t\t// If a query option is passed, use it\n\t\tif (request.query) {\n\t\t\tconst resolvedQuery = request.query.toString();\n\t\t\tif (resolvedQuery !== '') {\n\t\t\t\tquery = `?${resolvedQuery}`;\n\t\t\t}\n\t\t}\n\n\t\t// Create the required headers\n\t\tconst headers: RequestHeaders = {\n\t\t\t...this.options.headers,\n\t\t\t'User-Agent': `${DefaultUserAgent} ${options.userAgentAppendix}`.trim(),\n\t\t};\n\n\t\t// If this request requires authorization (allowing non-\"authorized\" requests for webhooks)\n\t\tif (request.auth !== false) {\n\t\t\t// If we haven't received a token, throw an error\n\t\t\tif (!this.#token) {\n\t\t\t\tthrow new Error('Expected token to be set for this request, but none was present');\n\t\t\t}\n\n\t\t\theaders.Authorization = `${request.authPrefix ?? this.options.authPrefix} ${this.#token}`;\n\t\t}\n\n\t\t// If a reason was set, set it's appropriate header\n\t\tif (request.reason?.length) {\n\t\t\theaders['X-Audit-Log-Reason'] = encodeURIComponent(request.reason);\n\t\t}\n\n\t\t// Format the full request URL (api base, optional version, endpoint, optional querystring)\n\t\tconst url = `${options.api}${request.versioned === false ? '' : `/v${options.version}`}${\n\t\t\trequest.fullRoute\n\t\t}${query}`;\n\n\t\tlet finalBody: RequestInit['body'];\n\t\tlet additionalHeaders: Record<string, string> = {};\n\n\t\tif (request.files?.length) {\n\t\t\tconst formData = new FormData();\n\n\t\t\t// Attach all files to the request\n\t\t\tfor (const [index, file] of request.files.entries()) {\n\t\t\t\tconst fileKey = file.key ?? `files[${index}]`;\n\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/FormData/append#parameters\n\t\t\t\t// FormData.append only accepts a string or Blob.\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob#parameters\n\t\t\t\t// The Blob constructor accepts TypedArray/ArrayBuffer, strings, and Blobs.\n\t\t\t\tif (isBufferLike(file.data)) {\n\t\t\t\t\t// Try to infer the content type from the buffer if one isn't passed\n\t\t\t\t\tlet contentType = file.contentType;\n\n\t\t\t\t\tif (!contentType) {\n\t\t\t\t\t\tconst [parsedType] = filetypeinfo(file.data);\n\n\t\t\t\t\t\tif (parsedType) {\n\t\t\t\t\t\t\tcontentType =\n\t\t\t\t\t\t\t\tOverwrittenMimeTypes[parsedType.mime as keyof typeof OverwrittenMimeTypes] ??\n\t\t\t\t\t\t\t\tparsedType.mime ??\n\t\t\t\t\t\t\t\t'application/octet-stream';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tformData.append(fileKey, new Blob([file.data], { type: contentType }), file.name);\n\t\t\t\t} else {\n\t\t\t\t\tformData.append(fileKey, new Blob([`${file.data}`], { type: file.contentType }), file.name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If a JSON body was added as well, attach it to the form data, using payload_json unless otherwise specified\n\t\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\t\tif (request.body != null) {\n\t\t\t\tif (request.appendToFormData) {\n\t\t\t\t\tfor (const [key, value] of Object.entries(request.body as Record<string, unknown>)) {\n\t\t\t\t\t\tformData.append(key, value);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tformData.append('payload_json', JSON.stringify(request.body));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the final body to the form data\n\t\t\tfinalBody = formData;\n\n\t\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\t} else if (request.body != null) {\n\t\t\tif (request.passThroughBody) {\n\t\t\t\tfinalBody = request.body as BodyInit;\n\t\t\t} else {\n\t\t\t\t// Stringify the JSON data\n\t\t\t\tfinalBody = JSON.stringify(request.body);\n\t\t\t\t// Set the additional headers to specify the content-type\n\t\t\t\tadditionalHeaders = { 'Content-Type': 'application/json' };\n\t\t\t}\n\t\t}\n\n\t\tconst method = request.method.toUpperCase();\n\n\t\t// The non null assertions in the following block are due to exactOptionalPropertyTypes, they have been tested to work with undefined\n\t\tconst fetchOptions: RequestInit = {\n\t\t\t// Set body to null on get / head requests. This does not follow fetch spec (likely because it causes subtle bugs) but is aligned with what request was doing\n\t\t\tbody: ['GET', 'HEAD'].includes(method) ? null : finalBody!,\n\t\t\theaders: { ...request.headers, ...additionalHeaders, ...headers } as Record<string, string>,\n\t\t\tmethod,\n\t\t\t// Prioritize setting an agent per request, use the agent for this instance otherwise.\n\t\t\tdispatcher: request.dispatcher ?? this.agent ?? undefined!,\n\t\t};\n\n\t\treturn { url, fetchOptions };\n\t}\n\n\t/**\n\t * Stops the hash sweeping interval\n\t */\n\tpublic clearHashSweeper() {\n\t\tclearInterval(this.hashTimer);\n\t}\n\n\t/**\n\t * Stops the request handler sweeping interval\n\t */\n\tpublic clearHandlerSweeper() {\n\t\tclearInterval(this.handlerTimer);\n\t}\n\n\t/**\n\t * Generates route data for an endpoint:method\n\t *\n\t * @param endpoint - The raw endpoint to generalize\n\t * @param method - The HTTP method this endpoint is called without\n\t * @internal\n\t */\n\tprivate static generateRouteData(endpoint: RouteLike, method: RequestMethod): RouteData {\n\t\tif (endpoint.startsWith('/interactions/') && endpoint.endsWith('/callback')) {\n\t\t\treturn {\n\t\t\t\tmajorParameter: BurstHandlerMajorIdKey,\n\t\t\t\tbucketRoute: '/interactions/:id/:token/callback',\n\t\t\t\toriginal: endpoint,\n\t\t\t};\n\t\t}\n\n\t\tconst majorIdMatch = /^\\/(?:channels|guilds|webhooks)\\/(\\d{17,19})/.exec(endpoint);\n\n\t\t// Get the major id for this route - global otherwise\n\t\tconst majorId = majorIdMatch?.[1] ?? 'global';\n\n\t\tconst baseRoute = endpoint\n\t\t\t// Strip out all ids\n\t\t\t.replaceAll(/\\d{17,19}/g, ':id')\n\t\t\t// Strip out reaction as they fall under the same bucket\n\t\t\t.replace(/\\/reactions\\/(.*)/, '/reactions/:reaction');\n\n\t\tlet exceptions = '';\n\n\t\t// Hard-Code Old Message Deletion Exception (2 week+ old messages are a different bucket)\n\t\t// https://github.com/discord/discord-api-docs/issues/1295\n\t\tif (method === RequestMethod.Delete && baseRoute === '/channels/:id/messages/:id') {\n\t\t\tconst id = /\\d{17,19}$/.exec(endpoint)![0]!;\n\t\t\tconst timestamp = DiscordSnowflake.timestampFrom(id);\n\t\t\tif (Date.now() - timestamp > 1_000 * 60 * 60 * 24 * 14) {\n\t\t\t\texceptions += '/Delete Old Message';\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tmajorParameter: majorId,\n\t\t\tbucketRoute: baseRoute + exceptions,\n\t\t\toriginal: endpoint,\n\t\t};\n\t}\n}\n","import type { Readable } from 'node:stream';\nimport type { ReadableStream } from 'node:stream/web';\nimport type { Collection } from '@discordjs/collection';\nimport type { Agent, Dispatcher, RequestInit, BodyInit, Response } from 'undici';\nimport type { IHandler } from '../interfaces/Handler.js';\n\nexport interface RestEvents {\n\thandlerSweep: [sweptHandlers: Collection<string, IHandler>];\n\thashSweep: [sweptHashes: Collection<string, HashData>];\n\tinvalidRequestWarning: [invalidRequestInfo: InvalidRequestWarningData];\n\trateLimited: [rateLimitInfo: RateLimitData];\n\tresponse: [request: APIRequest, response: ResponseLike];\n\trestDebug: [info: string];\n}\n\nexport type RestEventsMap = {\n\t[K in keyof RestEvents]: RestEvents[K];\n};\n\n/**\n * Options to be passed when creating the REST instance\n */\nexport interface RESTOptions {\n\t/**\n\t * The agent to set globally\n\t */\n\tagent: Dispatcher | null;\n\t/**\n\t * The base api path, without version\n\t *\n\t * @defaultValue `'https://discord.com/api'`\n\t */\n\tapi: string;\n\t/**\n\t * The authorization prefix to use for requests, useful if you want to use\n\t * bearer tokens\n\t *\n\t * @defaultValue `'Bot'`\n\t */\n\tauthPrefix: 'Bearer' | 'Bot';\n\t/**\n\t * The cdn path\n\t *\n\t * @defaultValue `'https://cdn.discordapp.com'`\n\t */\n\tcdn: string;\n\t/**\n\t * How many requests to allow sending per second (Infinity for unlimited, 50 for the standard global limit used by Discord)\n\t *\n\t * @defaultValue `50`\n\t */\n\tglobalRequestsPerSecond: number;\n\t/**\n\t * The amount of time in milliseconds that passes between each hash sweep. (defaults to 1h)\n\t *\n\t * @defaultValue `3_600_000`\n\t */\n\thandlerSweepInterval: number;\n\t/**\n\t * The maximum amount of time a hash can exist in milliseconds without being hit with a request (defaults to 24h)\n\t *\n\t * @defaultValue `86_400_000`\n\t */\n\thashLifetime: number;\n\t/**\n\t * The amount of time in milliseconds that passes between each hash sweep. (defaults to 4h)\n\t *\n\t * @defaultValue `14_400_000`\n\t */\n\thashSweepInterval: number;\n\t/**\n\t * Additional headers to send for all API requests\n\t *\n\t * @defaultValue `{}`\n\t */\n\theaders: Record<string, string>;\n\t/**\n\t * The number of invalid REST requests (those that return 401, 403, or 429) in a 10 minute window between emitted warnings (0 for no warnings).\n\t * That is, if set to 500, warnings will be emitted at invalid request number 500, 1000, 1500, and so on.\n\t *\n\t * @defaultValue `0`\n\t */\n\tinvalidRequestWarningInterval: number;\n\t/**\n\t * The method called to perform the actual HTTP request given a url and web `fetch` options\n\t * For example, to use global fetch, simply provide `makeRequest: fetch`\n\t */\n\tmakeRequest(url: string, init: RequestInit): Promise<ResponseLike>;\n\t/**\n\t * The extra offset to add to rate limits in milliseconds\n\t *\n\t * @defaultValue `50`\n\t */\n\toffset: number;\n\t/**\n\t * Determines how rate limiting and pre-emptive throttling should be handled.\n\t * When an array of strings, each element is treated as a prefix for the request route\n\t * (e.g. `/channels` to match any route starting with `/channels` such as `/channels/:id/messages`)\n\t * for which to throw {@link RateLimitError}s. All other request routes will be queued normally\n\t *\n\t * @defaultValue `null`\n\t */\n\trejectOnRateLimit: RateLimitQueueFilter | string[] | null;\n\t/**\n\t * The number of retries for errors with the 500 code, or errors\n\t * that timeout\n\t *\n\t * @defaultValue `3`\n\t */\n\tretries: number;\n\t/**\n\t * The time to wait in milliseconds before a request is aborted\n\t *\n\t * @defaultValue `15_000`\n\t */\n\ttimeout: number;\n\t/**\n\t * Extra information to add to the user agent\n\t *\n\t * @defaultValue DefaultUserAgentAppendix\n\t */\n\tuserAgentAppendix: string;\n\t/**\n\t * The version of the API to use\n\t *\n\t * @defaultValue `'10'`\n\t */\n\tversion: string;\n}\n\n/**\n * Data emitted on `RESTEvents.RateLimited`\n */\nexport interface RateLimitData {\n\t/**\n\t * Whether the rate limit that was reached was the global limit\n\t */\n\tglobal: boolean;\n\t/**\n\t * The bucket hash for this request\n\t */\n\thash: string;\n\t/**\n\t * The amount of requests we can perform before locking requests\n\t */\n\tlimit: number;\n\t/**\n\t * The major parameter of the route\n\t *\n\t * For example, in `/channels/x`, this will be `x`.\n\t * If there is no major parameter (e.g: `/bot/gateway`) this will be `global`.\n\t */\n\tmajorParameter: string;\n\t/**\n\t * The HTTP method being performed\n\t */\n\tmethod: string;\n\t/**\n\t * The route being hit in this request\n\t */\n\troute: string;\n\t/**\n\t * The time, in milliseconds, until the request-lock is reset\n\t */\n\ttimeToReset: number;\n\t/**\n\t * The full URL for this request\n\t */\n\turl: string;\n}\n\n/**\n * A function that determines whether the rate limit hit should throw an Error\n */\nexport type RateLimitQueueFilter = (rateLimitData: RateLimitData) => Promise<boolean> | boolean;\n\nexport interface APIRequest {\n\t/**\n\t * The data that was used to form the body of this request\n\t */\n\tdata: HandlerRequestData;\n\t/**\n\t * The HTTP method used in this request\n\t */\n\tmethod: string;\n\t/**\n\t * Additional HTTP options for this request\n\t */\n\toptions: RequestInit;\n\t/**\n\t * The full path used to make the request\n\t */\n\tpath: RouteLike;\n\t/**\n\t * The number of times this request has been attempted\n\t */\n\tretries: number;\n\t/**\n\t * The API route identifying the ratelimit for this request\n\t */\n\troute: string;\n}\n\nexport interface ResponseLike\n\textends Pick<Response, 'arrayBuffer' | 'bodyUsed' | 'headers' | 'json' | 'ok' | 'status' | 'statusText' | 'text'> {\n\tbody: Readable | ReadableStream | null;\n}\n\nexport interface InvalidRequestWarningData {\n\t/**\n\t * Number of invalid requests that have been made in the window\n\t */\n\tcount: number;\n\t/**\n\t * Time in milliseconds remaining before the count resets\n\t */\n\tremainingTime: number;\n}\n\n/**\n * Represents a file to be added to the request\n */\nexport interface RawFile {\n\t/**\n\t * Content-Type of the file\n\t */\n\tcontentType?: string;\n\t/**\n\t * The actual data for the file\n\t */\n\tdata: Buffer | Uint8Array | boolean | number | string;\n\t/**\n\t * An explicit key to use for key of the formdata field for this file.\n\t * When not provided, the index of the file in the files array is used in the form `files[${index}]`.\n\t * If you wish to alter the placeholder snowflake, you must provide this property in the same form (`files[${placeholder}]`)\n\t */\n\tkey?: string;\n\t/**\n\t * The name of the file\n\t */\n\tname: string;\n}\n\n/**\n * Represents possible data to be given to an endpoint\n */\nexport interface RequestData {\n\t/**\n\t * Whether to append JSON data to form data instead of `payload_json` when sending files\n\t */\n\tappendToFormData?: boolean;\n\t/**\n\t * If this request needs the `Authorization` header\n\t *\n\t * @defaultValue `true`\n\t */\n\tauth?: boolean;\n\t/**\n\t * The authorization prefix to use for this request, useful if you use this with bearer tokens\n\t *\n\t * @defaultValue `'Bot'`\n\t */\n\tauthPrefix?: 'Bearer' | 'Bot';\n\t/**\n\t * The body to send to this request.\n\t * If providing as BodyInit, set `passThroughBody: true`\n\t */\n\tbody?: BodyInit | unknown;\n\t/**\n\t * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} to use for the request.\n\t */\n\tdispatcher?: Agent;\n\t/**\n\t * Files to be attached to this request\n\t */\n\tfiles?: RawFile[] | undefined;\n\t/**\n\t * Additional headers to add to this request\n\t */\n\theaders?: Record<string, string>;\n\t/**\n\t * Whether to pass-through the body property directly to `fetch()`.\n\t * <warn>This only applies when files is NOT present</warn>\n\t */\n\tpassThroughBody?: boolean;\n\t/**\n\t * Query string parameters to append to the called endpoint\n\t */\n\tquery?: URLSearchParams;\n\t/**\n\t * Reason to show in the audit logs\n\t */\n\treason?: string | undefined;\n\t/**\n\t * The signal to abort the queue entry or the REST call, where applicable\n\t */\n\tsignal?: AbortSignal | undefined;\n\t/**\n\t * If this request should be versioned\n\t *\n\t * @defaultValue `true`\n\t */\n\tversioned?: boolean;\n}\n\n/**\n * Possible headers for an API call\n */\nexport interface RequestHeaders {\n\tAuthorization?: string;\n\t'User-Agent': string;\n\t'X-Audit-Log-Reason'?: string;\n}\n\n/**\n * Possible API methods to be used when doing requests\n */\nexport enum RequestMethod {\n\tDelete = 'DELETE',\n\tGet = 'GET',\n\tPatch = 'PATCH',\n\tPost = 'POST',\n\tPut = 'PUT',\n}\n\nexport type RouteLike = `/${string}`;\n\n/**\n * Internal request options\n *\n * @internal\n */\nexport interface InternalRequest extends RequestData {\n\tfullRoute: RouteLike;\n\tmethod: RequestMethod;\n}\n\nexport type HandlerRequestData = Pick<InternalRequest, 'auth' | 'body' | 'files' | 'signal'>;\n\n/**\n * Parsed route data for an endpoint\n *\n * @internal\n */\nexport interface RouteData {\n\tbucketRoute: string;\n\tmajorParameter: string;\n\toriginal: RouteLike;\n}\n\n/**\n * Represents a hash and its associated fields\n *\n * @internal\n */\nexport interface HashData {\n\tlastAccess: number;\n\tvalue: string;\n}\n","import type { RESTPatchAPIChannelJSONBody, Snowflake } from 'discord-api-types/v10';\nimport type { REST } from '../REST.js';\nimport { RateLimitError } from '../errors/RateLimitError.js';\nimport { RequestMethod, type RateLimitData, type ResponseLike } from './types.js';\n\nfunction serializeSearchParam(value: unknown): string | null {\n\tswitch (typeof value) {\n\t\tcase 'string':\n\t\t\treturn value;\n\t\tcase 'number':\n\t\tcase 'bigint':\n\t\tcase 'boolean':\n\t\t\treturn value.toString();\n\t\tcase 'object':\n\t\t\tif (value === null) return null;\n\t\t\tif (value instanceof Date) {\n\t\t\t\treturn Number.isNaN(value.getTime()) ? null : value.toISOString();\n\t\t\t}\n\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-base-to-string\n\t\t\tif (typeof value.toString === 'function' && value.toString !== Object.prototype.toString) return value.toString();\n\t\t\treturn null;\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\n/**\n * Creates and populates an URLSearchParams instance from an object, stripping\n * out null and undefined values, while also coercing non-strings to strings.\n *\n * @param options - The options to use\n * @returns A populated URLSearchParams instance\n */\nexport function makeURLSearchParams<T extends object>(options?: Readonly<T>) {\n\tconst params = new URLSearchParams();\n\tif (!options) return params;\n\n\tfor (const [key, value] of Object.entries(options)) {\n\t\tconst serialized = serializeSearchParam(value);\n\t\tif (serialized !== null) params.append(key, serialized);\n\t}\n\n\treturn params;\n}\n\n/**\n * Converts the response to usable data\n *\n * @param res - The fetch response\n */\nexport async function parseResponse(res: ResponseLike): Promise<unknown> {\n\tif (res.headers.get('Content-Type')?.startsWith('application/json')) {\n\t\treturn res.json();\n\t}\n\n\treturn res.arrayBuffer();\n}\n\n/**\n * Check whether a request falls under a sublimit\n *\n * @param bucketRoute - The buckets route identifier\n * @param body - The options provided as JSON data\n * @param method - The HTTP method that will be used to make the request\n * @returns Whether the request falls under a sublimit\n */\nexport function hasSublimit(bucketRoute: string, body?: unknown, method?: string): boolean {\n\t// TODO: Update for new sublimits\n\t// Currently known sublimits:\n\t// Editing channel `name` or `topic`\n\tif (bucketRoute === '/channels/:id') {\n\t\tif (typeof body !== 'object' || body === null) return false;\n\t\t// This should never be a POST body, but just in case\n\t\tif (method !== RequestMethod.Patch) return false;\n\t\tconst castedBody = body as RESTPatchAPIChannelJSONBody;\n\t\treturn ['name', 'topic'].some((key) => Reflect.has(castedBody, key));\n\t}\n\n\t// If we are checking if a request has a sublimit on a route not checked above, sublimit all requests to avoid a flood of 429s\n\treturn true;\n}\n\n/**\n * Check whether an error indicates that a retry can be attempted\n *\n * @param error - The error thrown by the network request\n * @returns Whether the error indicates a retry should be attempted\n */\nexport function shouldRetry(error: Error | NodeJS.ErrnoException) {\n\t// Retry for possible timed out requests\n\tif (error.name === 'AbortError') return true;\n\t// Downlevel ECONNRESET to retry as it may be recoverable\n\treturn ('code' in error && error.code === 'ECONNRESET') || error.message.includes('ECONNRESET');\n}\n\n/**\n * Determines whether the request should be queued or whether a RateLimitError should be thrown\n *\n * @internal\n */\nexport async function onRateLimit(manager: REST, rateLimitData: RateLimitData) {\n\tconst { options } = manager;\n\tif (!options.rejectOnRateLimit) return;\n\n\tconst shouldThrow =\n\t\ttypeof options.rejectOnRateLimit === 'function'\n\t\t\t? await options.rejectOnRateLimit(rateLimitData)\n\t\t\t: options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));\n\tif (shouldThrow) {\n\t\tthrow new RateLimitError(rateLimitData);\n\t}\n}\n\n/**\n * Calculates the default avatar index for a given user id.\n *\n * @param userId - The user id to calculate the default avatar index for\n */\nexport function calculateUserDefaultAvatarIndex(userId: Snowflake) {\n\treturn Number(BigInt(userId) >> 22n) % 6;\n}\n\n/**\n * Sleeps for a given amount of time.\n *\n * @param ms - The amount of time (in milliseconds) to sleep for\n */\nexport async function sleep(ms: number): Promise<void> {\n\treturn new Promise<void>((resolve) => {\n\t\tsetTimeout(() => resolve(), ms);\n\t});\n}\n\n/**\n * Verifies that a value is a buffer-like object.\n *\n * @param value - The value to check\n */\nexport function isBufferLike(value: unknown): value is ArrayBuffer | Buffer | Uint8Array | Uint8ClampedArray {\n\treturn value instanceof ArrayBuffer || value instanceof Uint8Array || value instanceof Uint8ClampedArray;\n}\n","import type { RequestInit } from 'undici';\nimport type { REST } from '../REST.js';\nimport type { DiscordErrorData, OAuthErrorData } from '../errors/DiscordAPIError.js';\nimport { DiscordAPIError } from '../errors/DiscordAPIError.js';\nimport { HTTPError } from '../errors/HTTPError.js';\nimport { RESTEvents } from '../utils/constants.js';\nimport type { ResponseLike, HandlerRequestData, RouteData } from '../utils/types.js';\nimport { parseResponse, shouldRetry } from '../utils/utils.js';\n\n/**\n * Invalid request limiting is done on a per-IP basis, not a per-token basis.\n * The best we can do is track invalid counts process-wide (on the theory that\n * users could have multiple bots run from one process) rather than per-bot.\n * Therefore, store these at file scope here rather than in the client's\n * RESTManager object.\n */\nlet invalidCount = 0;\nlet invalidCountResetTime: number | null = null;\n\n/**\n * Increment the invalid request count and emit warning if necessary\n *\n * @internal\n */\nexport function incrementInvalidCount(manager: REST) {\n\tif (!invalidCountResetTime || invalidCountResetTime < Date.now()) {\n\t\tinvalidCountResetTime = Date.now() + 1_000 * 60 * 10;\n\t\tinvalidCount = 0;\n\t}\n\n\tinvalidCount++;\n\n\tconst emitInvalid =\n\t\tmanager.options.invalidRequestWarningInterval > 0 &&\n\t\tinvalidCount % manager.options.invalidRequestWarningInterval === 0;\n\tif (emitInvalid) {\n\t\t// Let library users know periodically about invalid requests\n\t\tmanager.emit(RESTEvents.InvalidRequestWarning, {\n\t\t\tcount: invalidCount,\n\t\t\tremainingTime: invalidCountResetTime - Date.now(),\n\t\t});\n\t}\n}\n\n/**\n * Performs the actual network request for a request handler\n *\n * @param manager - The manager that holds options and emits informational events\n * @param routeId - The generalized api route with literal ids for major parameters\n * @param url - The fully resolved url to make the request to\n * @param options - The fetch options needed to make the request\n * @param requestData - Extra data from the user's request needed for errors and additional processing\n * @param retries - The number of retries this request has already attempted (recursion occurs on the handler)\n * @returns The respond from the network or `null` when the request should be retried\n * @internal\n */\nexport async function makeNetworkRequest(\n\tmanager: REST,\n\trouteId: RouteData,\n\turl: string,\n\toptions: RequestInit,\n\trequestData: HandlerRequestData,\n\tretries: number,\n) {\n\tconst controller = new AbortController();\n\tconst timeout = setTimeout(() => controller.abort(), manager.options.timeout);\n\tif (requestData.signal) {\n\t\t// If the user signal was aborted, abort the controller, else abort the local signal.\n\t\t// The reason why we don't re-use the user's signal, is because users may use the same signal for multiple\n\t\t// requests, and we do not want to cause unexpected side-effects.\n\t\tif (requestData.signal.aborted) controller.abort();\n\t\telse requestData.signal.addEventListener('abort', () => controller.abort());\n\t}\n\n\tlet res: ResponseLike;\n\ttry {\n\t\tres = await manager.options.makeRequest(url, { ...options, signal: controller.signal });\n\t} catch (error: unknown) {\n\t\tif (!(error instanceof Error)) throw error;\n\t\t// Retry the specified number of times if needed\n\t\tif (shouldRetry(error) && retries !== manager.options.retries) {\n\t\t\t// Retry is handled by the handler upon receiving null\n\t\t\treturn null;\n\t\t}\n\n\t\tthrow error;\n\t} finally {\n\t\tclearTimeout(timeout);\n\t}\n\n\tif (manager.listenerCount(RESTEvents.Response)) {\n\t\tmanager.emit(\n\t\t\tRESTEvents.Response,\n\t\t\t{\n\t\t\t\tmethod: options.method ?? 'get',\n\t\t\t\tpath: routeId.original,\n\t\t\t\troute: routeId.bucketRoute,\n\t\t\t\toptions,\n\t\t\t\tdata: requestData,\n\t\t\t\tretries,\n\t\t\t},\n\t\t\tres instanceof Response ? res.clone() : { ...res },\n\t\t);\n\t}\n\n\treturn res;\n}\n\n/**\n * Handles 5xx and 4xx errors (not 429's) conventionally. 429's should be handled before calling this function\n *\n * @param manager - The manager that holds options and emits informational events\n * @param res - The response received from {@link makeNetworkRequest}\n * @param method - The method used to make the request\n * @param url - The fully resolved url to make the request to\n * @param requestData - Extra data from the user's request needed for errors and additional processing\n * @param retries - The number of retries this request has already attempted (recursion occurs on the handler)\n * @returns - The response if the status code is not handled or null to request a retry\n */\nexport async function handleErrors(\n\tmanager: REST,\n\tres: ResponseLike,\n\tmethod: string,\n\turl: string,\n\trequestData: HandlerRequestData,\n\tretries: number,\n) {\n\tconst status = res.status;\n\tif (status >= 500 && status < 600) {\n\t\t// Retry the specified number of times for possible server side issues\n\t\tif (retries !== manager.options.retries) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// We are out of retries, throw an error\n\t\tthrow new HTTPError(status, res.statusText, method, url, requestData);\n\t} else {\n\t\t// Handle possible malformed requests\n\t\tif (status >= 400 && status < 500) {\n\t\t\t// If we receive this status code, it means the token we had is no longer valid.\n\t\t\tif (status === 401 && requestData.auth) {\n\t\t\t\tmanager.setToken(null!);\n\t\t\t}\n\n\t\t\t// The request will not succeed for some reason, parse the error returned from the api\n\t\t\tconst data = (await parseResponse(res)) as DiscordErrorData | OAuthErrorData;\n\t\t\t// throw the API error\n\t\t\tthrow new DiscordAPIError(data, 'code' in data ? data.code : data.error, status, method, url, requestData);\n\t\t}\n\n\t\treturn res;\n\t}\n}\n","import type { RequestInit } from 'undici';\nimport type { REST } from '../REST.js';\nimport type { IHandler } from '../interfaces/Handler.js';\nimport { RESTEvents } from '../utils/constants.js';\nimport type { ResponseLike, HandlerRequestData, RouteData } from '../utils/types.js';\nimport { onRateLimit, sleep } from '../utils/utils.js';\nimport { handleErrors, incrementInvalidCount, makeNetworkRequest } from './Shared.js';\n\n/**\n * The structure used to handle burst requests for a given bucket.\n * Burst requests have no ratelimit handling but allow for pre- and post-processing\n * of data in the same manner as sequentially queued requests.\n *\n * @remarks\n * This queue may still emit a rate limit error if an unexpected 429 is hit\n */\nexport class BurstHandler implements IHandler {\n\t/**\n\t * {@inheritdoc IHandler.id}\n\t */\n\tpublic readonly id: string;\n\n\t/**\n\t * {@inheritDoc IHandler.inactive}\n\t */\n\tpublic inactive = false;\n\n\t/**\n\t * @param manager - The request manager\n\t * @param hash - The hash that this RequestHandler handles\n\t * @param majorParameter - The major parameter for this handler\n\t */\n\tpublic constructor(\n\t\tprivate readonly manager: REST,\n\t\tprivate readonly hash: string,\n\t\tprivate readonly majorParameter: string,\n\t) {\n\t\tthis.id = `${hash}:${majorParameter}`;\n\t}\n\n\t/**\n\t * Emits a debug message\n\t *\n\t * @param message - The message to debug\n\t */\n\tprivate debug(message: string) {\n\t\tthis.manager.emit(RESTEvents.Debug, `[REST ${this.id}] ${message}`);\n\t}\n\n\t/**\n\t * {@inheritDoc IHandler.queueRequest}\n\t */\n\tpublic async queueRequest(\n\t\trouteId: RouteData,\n\t\turl: string,\n\t\toptions: RequestInit,\n\t\trequestData: HandlerRequestData,\n\t): Promise<ResponseLike> {\n\t\treturn this.runRequest(routeId, url, options, requestData);\n\t}\n\n\t/**\n\t * The method that actually makes the request to the API, and updates info about the bucket accordingly\n\t *\n\t * @param routeId - The generalized API route with literal ids for major parameters\n\t * @param url - The fully resolved URL to make the request to\n\t * @param options - The fetch options needed to make the request\n\t * @param requestData - Extra data from the user's request needed for errors and additional processing\n\t * @param retries - The number of retries this request has already attempted (recursion)\n\t */\n\tprivate async runRequest(\n\t\trouteId: RouteData,\n\t\turl: string,\n\t\toptions: RequestInit,\n\t\trequestData: HandlerRequestData,\n\t\tretries = 0,\n\t): Promise<ResponseLike> {\n\t\tconst method = options.method ?? 'get';\n\n\t\tconst res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);\n\n\t\t// Retry requested\n\t\tif (res === null) {\n\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\treturn this.runRequest(routeId, url, options, requestData, ++retries);\n\t\t}\n\n\t\tconst status = res.status;\n\t\tlet retryAfter = 0;\n\t\tconst retry = res.headers.get('Retry-After');\n\n\t\t// Amount of time in milliseconds until we should retry if rate limited (globally or otherwise)\n\t\tif (retry) retryAfter = Number(retry) * 1_000 + this.manager.options.offset;\n\n\t\t// Count the invalid requests\n\t\tif (status === 401 || status === 403 || status === 429) {\n\t\t\tincrementInvalidCount(this.manager);\n\t\t}\n\n\t\tif (status >= 200 && status < 300) {\n\t\t\treturn res;\n\t\t} else if (status === 429) {\n\t\t\t// Unexpected ratelimit\n\t\t\tconst isGlobal = res.headers.has('X-RateLimit-Global');\n\t\t\tawait onRateLimit(this.manager, {\n\t\t\t\ttimeToReset: retryAfter,\n\t\t\t\tlimit: Number.POSITIVE_INFINITY,\n\t\t\t\tmethod,\n\t\t\t\thash: this.hash,\n\t\t\t\turl,\n\t\t\t\troute: routeId.bucketRoute,\n\t\t\t\tmajorParameter: this.majorParameter,\n\t\t\t\tglobal: isGlobal,\n\t\t\t});\n\t\t\tthis.debug(\n\t\t\t\t[\n\t\t\t\t\t'Encountered unexpected 429 rate limit',\n\t\t\t\t\t`  Global         : ${isGlobal}`,\n\t\t\t\t\t`  Method         : ${method}`,\n\t\t\t\t\t`  URL            : ${url}`,\n\t\t\t\t\t`  Bucket         : ${routeId.bucketRoute}`,\n\t\t\t\t\t`  Major parameter: ${routeId.majorParameter}`,\n\t\t\t\t\t`  Hash           : ${this.hash}`,\n\t\t\t\t\t`  Limit          : ${Number.POSITIVE_INFINITY}`,\n\t\t\t\t\t`  Retry After    : ${retryAfter}ms`,\n\t\t\t\t\t`  Sublimit       : None`,\n\t\t\t\t].join('\\n'),\n\t\t\t);\n\n\t\t\t// We are bypassing all other limits, but an encountered limit should be respected (it's probably a non-punished rate limit anyways)\n\t\t\tawait sleep(retryAfter);\n\n\t\t\t// Since this is not a server side issue, the next request should pass, so we don't bump the retries counter\n\t\t\treturn this.runRequest(routeId, url, options, requestData, retries);\n\t\t} else {\n\t\t\tconst handled = await handleErrors(this.manager, res, method, url, requestData, retries);\n\t\t\tif (handled === null) {\n\t\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\t\treturn this.runRequest(routeId, url, options, requestData, ++retries);\n\t\t\t}\n\n\t\t\treturn handled;\n\t\t}\n\t}\n}\n","import { AsyncQueue } from '@sapphire/async-queue';\nimport type { RequestInit } from 'undici';\nimport type { REST } from '../REST.js';\nimport type { IHandler } from '../interfaces/Handler.js';\nimport { RESTEvents } from '../utils/constants.js';\nimport type { RateLimitData, ResponseLike, HandlerRequestData, RouteData } from '../utils/types.js';\nimport { hasSublimit, onRateLimit, sleep } from '../utils/utils.js';\nimport { handleErrors, incrementInvalidCount, makeNetworkRequest } from './Shared.js';\n\nconst enum QueueType {\n\tStandard,\n\tSublimit,\n}\n\n/**\n * The structure used to handle sequential requests for a given bucket\n */\nexport class SequentialHandler implements IHandler {\n\t/**\n\t * {@inheritDoc IHandler.id}\n\t */\n\tpublic readonly id: string;\n\n\t/**\n\t * The time this rate limit bucket will reset\n\t */\n\tprivate reset = -1;\n\n\t/**\n\t * The remaining requests that can be made before we are rate limited\n\t */\n\tprivate remaining = 1;\n\n\t/**\n\t * The total number of requests that can be made before we are rate limited\n\t */\n\tprivate limit = Number.POSITIVE_INFINITY;\n\n\t/**\n\t * The interface used to sequence async requests sequentially\n\t */\n\t#asyncQueue = new AsyncQueue();\n\n\t/**\n\t * The interface used to sequence sublimited async requests sequentially\n\t */\n\t#sublimitedQueue: AsyncQueue | null = null;\n\n\t/**\n\t * A promise wrapper for when the sublimited queue is finished being processed or null when not being processed\n\t */\n\t#sublimitPromise: { promise: Promise<void>; resolve(): void } | null = null;\n\n\t/**\n\t * Whether the sublimit queue needs to be shifted in the finally block\n\t */\n\t#shiftSublimit = false;\n\n\t/**\n\t * @param manager - The request manager\n\t * @param hash - The hash that this RequestHandler handles\n\t * @param majorParameter - The major parameter for this handler\n\t */\n\tpublic constructor(\n\t\tprivate readonly manager: REST,\n\t\tprivate readonly hash: string,\n\t\tprivate readonly majorParameter: string,\n\t) {\n\t\tthis.id = `${hash}:${majorParameter}`;\n\t}\n\n\t/**\n\t * {@inheritDoc IHandler.inactive}\n\t */\n\tpublic get inactive(): boolean {\n\t\treturn (\n\t\t\tthis.#asyncQueue.remaining === 0 &&\n\t\t\t(this.#sublimitedQueue === null || this.#sublimitedQueue.remaining === 0) &&\n\t\t\t!this.limited\n\t\t);\n\t}\n\n\t/**\n\t * If the rate limit bucket is currently limited by the global limit\n\t */\n\tprivate get globalLimited(): boolean {\n\t\treturn this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;\n\t}\n\n\t/**\n\t * If the rate limit bucket is currently limited by its limit\n\t */\n\tprivate get localLimited(): boolean {\n\t\treturn this.remaining <= 0 && Date.now() < this.reset;\n\t}\n\n\t/**\n\t * If the rate limit bucket is currently limited\n\t */\n\tprivate get limited(): boolean {\n\t\treturn this.globalLimited || this.localLimited;\n\t}\n\n\t/**\n\t * The time until queued requests can continue\n\t */\n\tprivate get timeToReset(): number {\n\t\treturn this.reset + this.manager.options.offset - Date.now();\n\t}\n\n\t/**\n\t * Emits a debug message\n\t *\n\t * @param message - The message to debug\n\t */\n\tprivate debug(message: string) {\n\t\tthis.manager.emit(RESTEvents.Debug, `[REST ${this.id}] ${message}`);\n\t}\n\n\t/**\n\t * Delay all requests for the specified amount of time, handling global rate limits\n\t *\n\t * @param time - The amount of time to delay all requests for\n\t */\n\tprivate async globalDelayFor(time: number): Promise<void> {\n\t\tawait sleep(time);\n\t\tthis.manager.globalDelay = null;\n\t}\n\n\t/**\n\t * {@inheritDoc IHandler.queueRequest}\n\t */\n\tpublic async queueRequest(\n\t\trouteId: RouteData,\n\t\turl: string,\n\t\toptions: RequestInit,\n\t\trequestData: HandlerRequestData,\n\t): Promise<ResponseLike> {\n\t\tlet queue = this.#asyncQueue;\n\t\tlet queueType = QueueType.Standard;\n\t\t// Separate sublimited requests when already sublimited\n\t\tif (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {\n\t\t\tqueue = this.#sublimitedQueue!;\n\t\t\tqueueType = QueueType.Sublimit;\n\t\t}\n\n\t\t// Wait for any previous requests to be completed before this one is run\n\t\tawait queue.wait({ signal: requestData.signal });\n\t\t// This set handles retroactively sublimiting requests\n\t\tif (queueType === QueueType.Standard) {\n\t\t\tif (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {\n\t\t\t\t/**\n\t\t\t\t * Remove the request from the standard queue, it should never be possible to get here while processing the\n\t\t\t\t * sublimit queue so there is no need to worry about shifting the wrong request\n\t\t\t\t */\n\t\t\t\tqueue = this.#sublimitedQueue!;\n\t\t\t\tconst wait = queue.wait();\n\t\t\t\tthis.#asyncQueue.shift();\n\t\t\t\tawait wait;\n\t\t\t} else if (this.#sublimitPromise) {\n\t\t\t\t// Stall requests while the sublimit queue gets processed\n\t\t\t\tawait this.#sublimitPromise.promise;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\t// Make the request, and return the results\n\t\t\treturn await this.runRequest(routeId, url, options, requestData);\n\t\t} finally {\n\t\t\t// Allow the next request to fire\n\t\t\tqueue.shift();\n\t\t\tif (this.#shiftSublimit) {\n\t\t\t\tthis.#shiftSublimit = false;\n\t\t\t\tthis.#sublimitedQueue?.shift();\n\t\t\t}\n\n\t\t\t// If this request is the last request in a sublimit\n\t\t\tif (this.#sublimitedQueue?.remaining === 0) {\n\t\t\t\tthis.#sublimitPromise?.resolve();\n\t\t\t\tthis.#sublimitedQueue = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The method that actually makes the request to the api, and updates info about the bucket accordingly\n\t *\n\t * @param routeId - The generalized api route with literal ids for major parameters\n\t * @param url - The fully resolved url to make the request to\n\t * @param options - The fetch options needed to make the request\n\t * @param requestData - Extra data from the user's request needed for errors and additional processing\n\t * @param retries - The number of retries this request has already attempted (recursion)\n\t */\n\tprivate async runRequest(\n\t\trouteId: RouteData,\n\t\turl: string,\n\t\toptions: RequestInit,\n\t\trequestData: HandlerRequestData,\n\t\tretries = 0,\n\t): Promise<ResponseLike> {\n\t\t/*\n\t\t * After calculations have been done, pre-emptively stop further requests\n\t\t * Potentially loop until this task can run if e.g. the global rate limit is hit twice\n\t\t */\n\t\twhile (this.limited) {\n\t\t\tconst isGlobal = this.globalLimited;\n\t\t\tlet limit: number;\n\t\t\tlet timeout: number;\n\t\t\tlet delay: Promise<void>;\n\n\t\t\tif (isGlobal) {\n\t\t\t\t// Set RateLimitData based on the global limit\n\t\t\t\tlimit = this.manager.options.globalRequestsPerSecond;\n\t\t\t\ttimeout = this.manager.globalReset + this.manager.options.offset - Date.now();\n\t\t\t\t// If this is the first task to reach the global timeout, set the global delay\n\t\t\t\tif (!this.manager.globalDelay) {\n\t\t\t\t\t// The global delay function clears the global delay state when it is resolved\n\t\t\t\t\tthis.manager.globalDelay = this.globalDelayFor(timeout);\n\t\t\t\t}\n\n\t\t\t\tdelay = this.manager.globalDelay;\n\t\t\t} else {\n\t\t\t\t// Set RateLimitData based on the route-specific limit\n\t\t\t\tlimit = this.limit;\n\t\t\t\ttimeout = this.timeToReset;\n\t\t\t\tdelay = sleep(timeout);\n\t\t\t}\n\n\t\t\tconst rateLimitData: RateLimitData = {\n\t\t\t\ttimeToReset: timeout,\n\t\t\t\tlimit,\n\t\t\t\tmethod: options.method ?? 'get',\n\t\t\t\thash: this.hash,\n\t\t\t\turl,\n\t\t\t\troute: routeId.bucketRoute,\n\t\t\t\tmajorParameter: this.majorParameter,\n\t\t\t\tglobal: isGlobal,\n\t\t\t};\n\t\t\t// Let library users know they have hit a rate limit\n\t\t\tthis.manager.emit(RESTEvents.RateLimited, rateLimitData);\n\t\t\t// Determine whether a RateLimitError should be thrown\n\t\t\tawait onRateLimit(this.manager, rateLimitData);\n\t\t\t// When not erroring, emit debug for what is happening\n\t\t\tif (isGlobal) {\n\t\t\t\tthis.debug(`Global rate limit hit, blocking all requests for ${timeout}ms`);\n\t\t\t} else {\n\t\t\t\tthis.debug(`Waiting ${timeout}ms for rate limit to pass`);\n\t\t\t}\n\n\t\t\t// Wait the remaining time left before the rate limit resets\n\t\t\tawait delay;\n\t\t}\n\n\t\t// As the request goes out, update the global usage information\n\t\tif (!this.manager.globalReset || this.manager.globalReset < Date.now()) {\n\t\t\tthis.manager.globalReset = Date.now() + 1_000;\n\t\t\tthis.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;\n\t\t}\n\n\t\tthis.manager.globalRemaining--;\n\n\t\tconst method = options.method ?? 'get';\n\n\t\tconst res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);\n\n\t\t// Retry requested\n\t\tif (res === null) {\n\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\treturn this.runRequest(routeId, url, options, requestData, ++retries);\n\t\t}\n\n\t\tconst status = res.status;\n\t\tlet retryAfter = 0;\n\n\t\tconst limit = res.headers.get('X-RateLimit-Limit');\n\t\tconst remaining = res.headers.get('X-RateLimit-Remaining');\n\t\tconst reset = res.headers.get('X-RateLimit-Reset-After');\n\t\tconst hash = res.headers.get('X-RateLimit-Bucket');\n\t\tconst retry = res.headers.get('Retry-After');\n\n\t\t// Update the total number of requests that can be made before the rate limit resets\n\t\tthis.limit = limit ? Number(limit) : Number.POSITIVE_INFINITY;\n\t\t// Update the number of remaining requests that can be made before the rate limit resets\n\t\tthis.remaining = remaining ? Number(remaining) : 1;\n\t\t// Update the time when this rate limit resets (reset-after is in seconds)\n\t\tthis.reset = reset ? Number(reset) * 1_000 + Date.now() + this.manager.options.offset : Date.now();\n\n\t\t// Amount of time in milliseconds until we should retry if rate limited (globally or otherwise)\n\t\tif (retry) retryAfter = Number(retry) * 1_000 + this.manager.options.offset;\n\n\t\t// Handle buckets via the hash header retroactively\n\t\tif (hash && hash !== this.hash) {\n\t\t\t// Let library users know when rate limit buckets have been updated\n\t\t\tthis.debug(['Received bucket hash update', `  Old Hash  : ${this.hash}`, `  New Hash  : ${hash}`].join('\\n'));\n\t\t\t// This queue will eventually be eliminated via attrition\n\t\t\tthis.manager.hashes.set(`${method}:${routeId.bucketRoute}`, { value: hash, lastAccess: Date.now() });\n\t\t} else if (hash) {\n\t\t\t// Handle the case where hash value doesn't change\n\t\t\t// Fetch the hash data from the manager\n\t\t\tconst hashData = this.manager.hashes.get(`${method}:${routeId.bucketRoute}`);\n\n\t\t\t// When fetched, update the last access of the hash\n\t\t\tif (hashData) {\n\t\t\t\thashData.lastAccess = Date.now();\n\t\t\t}\n\t\t}\n\n\t\t// Handle retryAfter, which means we have actually hit a rate limit\n\t\tlet sublimitTimeout: number | null = null;\n\t\tif (retryAfter > 0) {\n\t\t\tif (res.headers.has('X-RateLimit-Global')) {\n\t\t\t\tthis.manager.globalRemaining = 0;\n\t\t\t\tthis.manager.globalReset = Date.now() + retryAfter;\n\t\t\t} else if (!this.localLimited) {\n\t\t\t\t/*\n\t\t\t\t * This is a sublimit (e.g. 2 channel name changes/10 minutes) since the headers don't indicate a\n\t\t\t\t * route-wide rate limit. Don't update remaining or reset to avoid rate limiting the whole\n\t\t\t\t * endpoint, just set a reset time on the request itself to avoid retrying too soon.\n\t\t\t\t */\n\t\t\t\tsublimitTimeout = retryAfter;\n\t\t\t}\n\t\t}\n\n\t\t// Count the invalid requests\n\t\tif (status === 401 || status === 403 || status === 429) {\n\t\t\tincrementInvalidCount(this.manager);\n\t\t}\n\n\t\tif (res.ok) {\n\t\t\treturn res;\n\t\t} else if (status === 429) {\n\t\t\t// A rate limit was hit - this may happen if the route isn't associated with an official bucket hash yet, or when first globally rate limited\n\t\t\tconst isGlobal = this.globalLimited;\n\t\t\tlet limit: number;\n\t\t\tlet timeout: number;\n\n\t\t\tif (isGlobal) {\n\t\t\t\t// Set RateLimitData based on the global limit\n\t\t\t\tlimit = this.manager.options.globalRequestsPerSecond;\n\t\t\t\ttimeout = this.manager.globalReset + this.manager.options.offset - Date.now();\n\t\t\t} else {\n\t\t\t\t// Set RateLimitData based on the route-specific limit\n\t\t\t\tlimit = this.limit;\n\t\t\t\ttimeout = this.timeToReset;\n\t\t\t}\n\n\t\t\tawait onRateLimit(this.manager, {\n\t\t\t\ttimeToReset: timeout,\n\t\t\t\tlimit,\n\t\t\t\tmethod,\n\t\t\t\thash: this.hash,\n\t\t\t\turl,\n\t\t\t\troute: routeId.bucketRoute,\n\t\t\t\tmajorParameter: this.majorParameter,\n\t\t\t\tglobal: isGlobal,\n\t\t\t});\n\t\t\tthis.debug(\n\t\t\t\t[\n\t\t\t\t\t'Encountered unexpected 429 rate limit',\n\t\t\t\t\t`  Global         : ${isGlobal.toString()}`,\n\t\t\t\t\t`  Method         : ${method}`,\n\t\t\t\t\t`  URL            : ${url}`,\n\t\t\t\t\t`  Bucket         : ${routeId.bucketRoute}`,\n\t\t\t\t\t`  Major parameter: ${routeId.majorParameter}`,\n\t\t\t\t\t`  Hash           : ${this.hash}`,\n\t\t\t\t\t`  Limit          : ${limit}`,\n\t\t\t\t\t`  Retry After    : ${retryAfter}ms`,\n\t\t\t\t\t`  Sublimit       : ${sublimitTimeout ? `${sublimitTimeout}ms` : 'None'}`,\n\t\t\t\t].join('\\n'),\n\t\t\t);\n\t\t\t// If caused by a sublimit, wait it out here so other requests on the route can be handled\n\t\t\tif (sublimitTimeout) {\n\t\t\t\t// Normally the sublimit queue will not exist, however, if a sublimit is hit while in the sublimit queue, it will\n\t\t\t\tconst firstSublimit = !this.#sublimitedQueue;\n\t\t\t\tif (firstSublimit) {\n\t\t\t\t\tthis.#sublimitedQueue = new AsyncQueue();\n\t\t\t\t\tvoid this.#sublimitedQueue.wait();\n\t\t\t\t\tthis.#asyncQueue.shift();\n\t\t\t\t}\n\n\t\t\t\tthis.#sublimitPromise?.resolve();\n\t\t\t\tthis.#sublimitPromise = null;\n\t\t\t\tawait sleep(sublimitTimeout);\n\t\t\t\tlet resolve: () => void;\n\t\t\t\t// eslint-disable-next-line promise/param-names, no-promise-executor-return\n\t\t\t\tconst promise = new Promise<void>((res) => (resolve = res));\n\t\t\t\tthis.#sublimitPromise = { promise, resolve: resolve! };\n\t\t\t\tif (firstSublimit) {\n\t\t\t\t\t// Re-queue this request so it can be shifted by the finally\n\t\t\t\t\tawait this.#asyncQueue.wait();\n\t\t\t\t\tthis.#shiftSublimit = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Since this is not a server side issue, the next request should pass, so we don't bump the retries counter\n\t\t\treturn this.runRequest(routeId, url, options, requestData, retries);\n\t\t} else {\n\t\t\tconst handled = await handleErrors(this.manager, res, method, url, requestData, retries);\n\t\t\tif (handled === null) {\n\t\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\t\treturn this.runRequest(routeId, url, options, requestData, ++retries);\n\t\t\t}\n\n\t\t\treturn handled;\n\t\t}\n\t}\n}\n","export * from './lib/CDN.js';\nexport * from './lib/errors/DiscordAPIError.js';\nexport * from './lib/errors/HTTPError.js';\nexport * from './lib/errors/RateLimitError.js';\nexport * from './lib/REST.js';\nexport * from './lib/utils/constants.js';\nexport * from './lib/utils/types.js';\nexport { calculateUserDefaultAvatarIndex, makeURLSearchParams, parseResponse } from './lib/utils/utils.js';\n\n/**\n * The {@link https://github.com/discordjs/discord.js/blob/main/packages/rest/#readme | @discordjs/rest} version\n * that you are currently using.\n */\n// This needs to explicitly be `string` so it is not typed as a \"const string\" that gets injected by esbuild\nexport const version = '2.0.1' as string;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAAA,WAAA;AAAAC,QAAA,CAAAD,WAAA;EAAAE,kBAAA,EAAAA,CAAA,KAAAA,kBAAA;EAAAC,aAAA,EAAAA,CAAA,KAAAA,aAAA;EAAAC,0BAAA,EAAAA,CAAA,KAAAA,0BAAA;EAAAC,sBAAA,EAAAA,CAAA,KAAAA,sBAAA;EAAAC,GAAA,EAAAA,CAAA,KAAAA,GAAA;EAAAC,kBAAA,EAAAA,CAAA,KAAAA,kBAAA;EAAAC,gBAAA,EAAAA,CAAA,KAAAA,gBAAA;EAAAC,wBAAA,EAAAA,CAAA,KAAAA,wBAAA;EAAAC,eAAA,EAAAA,CAAA,KAAAA,eAAA;EAAAC,SAAA,EAAAA,CAAA,KAAAA,SAAA;EAAAC,oBAAA,EAAAA,CAAA,KAAAA,oBAAA;EAAAC,IAAA,EAAAA,CAAA,KAAAA,IAAA;EAAAC,UAAA,EAAAA,CAAA,KAAAA,UAAA;EAAAC,cAAA,EAAAA,CAAA,KAAAA,cAAA;EAAAC,aAAA,EAAAA,CAAA,KAAAA,aAAA;EAAAC,+BAAA,EAAAA,CAAA,KAAAA,+BAAA;EAAAC,mBAAA,EAAAA,CAAA,KAAAA,mBAAA;EAAAC,aAAA,EAAAA,CAAA,KAAAA,aAAA;EAAAC,OAAA,EAAAA,CAAA,KAAAA;AAAA;AAAAC,MAAA,CAAAC,OAAA,GAAAC,YAAA,CAAAvB,WAAA;;;ACEA,IAAIwB,eAAA;AAEG,SAASC,mBAAmBC,WAAA,EAAyC;EAC3EF,eAAA,GAAkBE,WAAA;AACnB;AAFgBC,MAAA,CAAAF,kBAAA;AAIT,SAASG,mBAAA,EAAqB;EACpC,OAAOJ,eAAA;AACR;AAFgBG,MAAA,CAAAC,kBAAA;;;ACRhB,IAAAC,WAAA,GAAqCC,OAAA;AACrC,IAAAC,UAAA,GAA2BD,OAAA;AAIpB,IAAMtB,gBAAA,GACZ;AAKM,IAAMC,wBAAA,OAA2BoB,WAAA,CAAAG,oBAAA,EAAqB;AAEtD,IAAMzB,kBAAA,GAAqB;EACjC0B,KAAA,EAAO;EACPC,GAAA,EAAK;EACLC,UAAA,EAAY;EACZC,GAAA,EAAK;EACLC,OAAA,EAAS,CAAC;EACVC,6BAAA,EAA+B;EAC/BC,uBAAA,EAAyB;EACzBC,MAAA,EAAQ;EACRC,iBAAA,EAAmB;EACnBC,OAAA,EAAS;EACTC,OAAA,EAAS;EACTC,iBAAA,EAAmBnC,wBAAA;EACnBW,OAAA,EAASW,UAAA,CAAAc,UAAA;EACTC,iBAAA,EAAmB;EAAA;EACnBC,YAAA,EAAc;EAAA;EACdC,oBAAA,EAAsB;EAAA;EACtB,MAAMC,YAAA,GAAeC,IAAA,EAA6B;IACjD,OAAOtB,kBAAA,CAAmB,EAAE,GAAGsB,IAAI;EACpC;AACD;AAKO,IAAKpC,UAAA,GAAL,gBAAKqC,WAAA,IAAL;EACNA,WAAA,YAAQ;EACRA,WAAA,mBAAe;EACfA,WAAA,gBAAY;EACZA,WAAA,4BAAwB;EACxBA,WAAA,kBAAc;EACdA,WAAA,eAAW;EANA,OAAAA,WAAA;AAAA,GAAArC,UAAA;AASL,IAAMZ,kBAAA,GAAqB,CAAC,QAAQ,OAAO,OAAO,QAAQ,KAAK;AAC/D,IAAME,0BAAA,GAA6B,CAAC,OAAO,QAAQ,KAAK;AACxD,IAAMD,aAAA,GAAgB,CAAC,IAAI,IAAI,IAAI,KAAK,KAAK,KAAK,MAAO,MAAO,IAAK;AAMrE,IAAMS,oBAAA,GAAuB;EAAA;EAEnC,cAAc;AACf;AAEO,IAAMP,sBAAA,GAAyB;;;ACA/B,IAAMC,GAAA,GAAN,MAAU;EACT8C,YAA6BC,IAAA,GAAe9C,kBAAA,CAAmB6B,GAAA,EAAK;IAAvC,KAAAiB,IAAA,GAAAA,IAAA;EAAwC;EA7D7E;IA4DiB1B,MAAA;EAAA;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAUT2B,SAASC,QAAA,EAAkBC,SAAA,EAAmBC,OAAA,EAAiD;IACrG,OAAO,KAAKC,OAAA,CAAQ,eAAeH,QAAQ,IAAIC,SAAS,IAAIC,OAAO;EACpE;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASOE,QAAQJ,QAAA,EAAkBK,QAAA,EAAkBH,OAAA,EAAiD;IACnG,OAAO,KAAKC,OAAA,CAAQ,cAAcH,QAAQ,IAAIK,QAAQ,IAAIH,OAAO;EAClE;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASOI,OAAOC,EAAA,EAAYC,UAAA,EAAoBN,OAAA,EAA6C;IAC1F,OAAO,KAAKO,cAAA,CAAe,YAAYF,EAAE,IAAIC,UAAU,IAAIA,UAAA,EAAYN,OAAO;EAC/E;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASOQ,iBACNC,MAAA,EACAC,oBAAA,EACAV,OAAA,EACS;IACT,OAAO,KAAKC,OAAA,CAAQ,uBAAuBQ,MAAM,IAAIC,oBAAoB,IAAIV,OAAO;EACrF;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASOW,OAAON,EAAA,EAAYO,UAAA,EAAoBZ,OAAA,EAA6C;IAC1F,OAAO,KAAKO,cAAA,CAAe,YAAYF,EAAE,IAAIO,UAAU,IAAIA,UAAA,EAAYZ,OAAO;EAC/E;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASOa,YAAYC,SAAA,EAAmBX,QAAA,EAAkBH,OAAA,EAAiD;IACxG,OAAO,KAAKC,OAAA,CAAQ,kBAAkBa,SAAS,IAAIX,QAAQ,IAAIH,OAAO;EACvE;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAUOe,cAAcC,KAAA,EAAuB;IAC3C,OAAO,KAAKf,OAAA,CAAQ,kBAAkBe,KAAK,IAAI;MAAEC,SAAA,EAAW;IAAM,CAAC;EACpE;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASOC,gBAAgBC,OAAA,EAAiBC,UAAA,EAAoBpB,OAAA,EAAiD;IAC5G,OAAO,KAAKC,OAAA,CAAQ,uBAAuBkB,OAAO,IAAIC,UAAU,IAAIpB,OAAO;EAC5E;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAQOqB,MAAMC,OAAA,EAAiBL,SAAA,EAAoC;IACjE,OAAO,KAAKhB,OAAA,CAAQ,WAAWqB,OAAO,IAAI;MAAEL;IAAU,CAAC;EACxD;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAUOM,kBACNJ,OAAA,EACAV,MAAA,EACAH,UAAA,EACAN,OAAA,EACS;IACT,OAAO,KAAKO,cAAA,CAAe,WAAWY,OAAO,UAAUV,MAAM,YAAYH,UAAU,IAAIA,UAAA,EAAYN,OAAO;EAC3G;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAUOwB,kBACNL,OAAA,EACAV,MAAA,EACAG,UAAA,EACAZ,OAAA,EACS;IACT,OAAO,KAAKO,cAAA,CAAe,WAAWY,OAAO,UAAUV,MAAM,WAAWG,UAAA,EAAYZ,OAAO;EAC5F;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASOyB,KAAKpB,EAAA,EAAYF,QAAA,EAAkBH,OAAA,EAA6C;IACtF,OAAO,KAAKO,cAAA,CAAe,UAAUF,EAAE,IAAIF,QAAQ,IAAIA,QAAA,EAAUH,OAAO;EACzE;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASO0B,SAASC,MAAA,EAAgBC,YAAA,EAAsB5B,OAAA,EAAiD;IACtG,OAAO,KAAKC,OAAA,CAAQ,eAAe0B,MAAM,IAAIC,YAAY,IAAI5B,OAAO;EACrE;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASO6B,OAAOV,OAAA,EAAiBC,UAAA,EAAoBpB,OAAA,EAAiD;IACnG,OAAO,KAAKC,OAAA,CAAQ,aAAakB,OAAO,IAAIC,UAAU,IAAIpB,OAAO;EAClE;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAUO8B,QAAQC,SAAA,EAAmBd,SAAA,GAA8B,OAAe;IAC9E,OAAO,KAAKhB,OAAA,CAAQ,aAAa8B,SAAS,IAAI;MAAEC,iBAAA,EAAmBrF,0BAAA;MAA4BsE;IAAU,CAAC;EAC3G;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAQOgB,kBAAkBC,QAAA,EAAkBlC,OAAA,EAAiD;IAC3F,OAAO,KAAKC,OAAA,CAAQ,wCAAwCiC,QAAQ,IAAIlC,OAAO;EAChF;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASOmC,SAASC,MAAA,EAAgBjC,QAAA,EAAkBH,OAAA,EAAiD;IAClG,OAAO,KAAKC,OAAA,CAAQ,eAAemC,MAAM,IAAIjC,QAAQ,IAAIH,OAAO;EACjE;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASOqC,yBACNC,gBAAA,EACAC,SAAA,EACAvC,OAAA,EACS;IACT,OAAO,KAAKC,OAAA,CAAQ,iBAAiBqC,gBAAgB,IAAIC,SAAS,IAAIvC,OAAO;EAC9E;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASQO,eACPiC,KAAA,EACAC,IAAA,EACA;IAAEC,WAAA,GAAc;IAAO,GAAG1C;EAAQ,IAA+B,CAAC,GACzD;IACT,OAAO,KAAKC,OAAA,CAAQuC,KAAA,EAAO,CAACE,WAAA,IAAeD,IAAA,CAAKE,UAAA,CAAW,IAAI,IAAI;MAAE,GAAG3C,OAAA;MAASiB,SAAA,EAAW;IAAM,IAAIjB,OAAO;EAC9G;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAQQC,QACPuC,KAAA,EACA;IAAER,iBAAA,GAAoBvF,kBAAA;IAAoBwE,SAAA,GAAY;IAAQ2B;EAAK,IAA8B,CAAC,GACzF;IAET3B,SAAA,GAAY4B,MAAA,CAAO5B,SAAS,EAAE6B,WAAA,CAAY;IAE1C,IAAI,CAACd,iBAAA,CAAkBe,QAAA,CAAS9B,SAAS,GAAG;MAC3C,MAAM,IAAI+B,UAAA,CAAW,+BAA+B/B,SAAS;AAAA,kBAAqBe,iBAAA,CAAkBiB,IAAA,CAAK,IAAI,CAAC,EAAE;IACjH;IAEA,IAAIL,IAAA,IAAQ,CAAClG,aAAA,CAAcqG,QAAA,CAASH,IAAI,GAAG;MAC1C,MAAM,IAAII,UAAA,CAAW,0BAA0BJ,IAAI;AAAA,kBAAqBlG,aAAA,CAAcuG,IAAA,CAAK,IAAI,CAAC,EAAE;IACnG;IAEA,MAAMC,GAAA,GAAM,IAAIC,GAAA,CAAI,GAAG,KAAKvD,IAAI,GAAG4C,KAAK,IAAIvB,SAAS,EAAE;IAEvD,IAAI2B,IAAA,EAAM;MACTM,GAAA,CAAIE,YAAA,CAAaC,GAAA,CAAI,QAAQR,MAAA,CAAOD,IAAI,CAAC;IAC1C;IAEA,OAAOM,GAAA,CAAII,QAAA,CAAS;EACrB;AACD;;;ACxSA,SAASC,oBAAoBC,KAAA,EAAwD;EACpF,OAAOC,OAAA,CAAQC,GAAA,CAAIF,KAAA,EAAkC,SAAS;AAC/D;AAFStF,MAAA,CAAAqF,mBAAA;AAIT,SAASI,gBAAgBH,KAAA,EAA4D;EACpF,OAAO,OAAOC,OAAA,CAAQG,GAAA,CAAIJ,KAAA,EAAkC,SAAS,MAAM;AAC5E;AAFStF,MAAA,CAAAyF,eAAA;AAOF,IAAM1G,eAAA,GAAN,MAAM4G,gBAAA,SAAwBC,KAAA,CAAM;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAWnCnE,YACCoE,QAAA,EACAC,IAAA,EACAC,MAAA,EACAC,MAAA,EACAhB,GAAA,EACPiB,QAAA,EACC;IACD,MAAMN,gBAAA,CAAgBO,UAAA,CAAWL,QAAQ,CAAC;IAPnC,KAAAA,QAAA,GAAAA,QAAA;IACA,KAAAC,IAAA,GAAAA,IAAA;IACA,KAAAC,MAAA,GAAAA,MAAA;IACA,KAAAC,MAAA,GAAAA,MAAA;IACA,KAAAhB,GAAA,GAAAA,GAAA;IAKP,KAAKmB,WAAA,GAAc;MAAEC,KAAA,EAAOH,QAAA,CAASG,KAAA;MAAOC,IAAA,EAAMJ,QAAA,CAASK;IAAK;EACjE;EA9DD;IAwC2CtG,MAAA;EAAA;EACnCmG,WAAA;EAAA;AAAA;AAAA;EA0BP,IAAoBI,KAAA,EAAe;IAClC,OAAO,GAAGZ,gBAAA,CAAgBY,IAAI,IAAI,KAAKT,IAAI;EAC5C;EAEA,OAAeI,WAAWZ,KAAA,EAA0C;IACnE,IAAIkB,SAAA,GAAY;IAChB,IAAI,UAAUlB,KAAA,EAAO;MACpB,IAAIA,KAAA,CAAMmB,MAAA,EAAQ;QACjBD,SAAA,GAAY,CAAC,GAAG,KAAKE,mBAAA,CAAoBpB,KAAA,CAAMmB,MAAM,CAAC,EAAE1B,IAAA,CAAK,IAAI;MAClE;MAEA,OAAOO,KAAA,CAAMqB,OAAA,IAAWH,SAAA,GACrB,GAAGlB,KAAA,CAAMqB,OAAO;AAAA,EAAKH,SAAS,KAC9BlB,KAAA,CAAMqB,OAAA,IAAWH,SAAA,IAAa;IAClC;IAEA,OAAOlB,KAAA,CAAMsB,iBAAA,IAAqB;EACnC;EAEA,QAAgBF,oBAAoBG,GAAA,EAAmBC,GAAA,GAAM,IAA8B;IAC1F,IAAIrB,eAAA,CAAgBoB,GAAG,GAAG;MACzB,OAAO,MAAM,GAAGC,GAAA,CAAIC,MAAA,GAAS,GAAGD,GAAG,IAAID,GAAA,CAAIf,IAAI,MAAM,GAAGe,GAAA,CAAIf,IAAI,EAAE,KAAKe,GAAA,CAAIF,OAAO,GAAGK,IAAA,CAAK;IAC3F;IAEA,WAAW,CAACC,QAAA,EAAUC,GAAG,KAAKC,MAAA,CAAOC,OAAA,CAAQP,GAAG,GAAG;MAClD,MAAMQ,OAAA,GAAUJ,QAAA,CAASxC,UAAA,CAAW,GAAG,IACpCqC,GAAA,GACAA,GAAA,GACAQ,MAAA,CAAOC,KAAA,CAAMD,MAAA,CAAOL,QAAQ,CAAC,IAC5B,GAAGH,GAAG,IAAIG,QAAQ,KAClB,GAAGH,GAAG,IAAIG,QAAQ,MACnBA,QAAA;MAEH,IAAI,OAAOC,GAAA,KAAQ,UAAU;QAC5B,MAAMA,GAAA;MACP,WAAW7B,mBAAA,CAAoB6B,GAAG,GAAG;QACpC,WAAW5B,KAAA,IAAS4B,GAAA,CAAIM,OAAA,EAAS;UAChC,OAAO,KAAKd,mBAAA,CAAoBpB,KAAA,EAAO+B,OAAO;QAC/C;MACD,OAAO;QACN,OAAO,KAAKX,mBAAA,CAAoBQ,GAAA,EAAKG,OAAO;MAC7C;IACD;EACD;AACD;;;ACzGO,IAAMrI,SAAA,GAAN,MAAMyI,UAAA,SAAkB7B,KAAA,CAAM;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAY7BnE,YACCsE,MAAA,EACP2B,UAAA,EACO1B,MAAA,EACAhB,GAAA,EACPiB,QAAA,EACC;IACD,MAAMyB,UAAU;IANT,KAAA3B,MAAA,GAAAA,MAAA;IAEA,KAAAC,MAAA,GAAAA,MAAA;IACA,KAAAhB,GAAA,GAAAA,GAAA;IAIP,KAAKmB,WAAA,GAAc;MAAEC,KAAA,EAAOH,QAAA,CAASG,KAAA;MAAOC,IAAA,EAAMJ,QAAA,CAASK;IAAK;EACjE;EA3BD;IAMqCtG,MAAA;EAAA;EAC7BmG,WAAA;EAESI,IAAA,GAAOkB,UAAA,CAAUlB,IAAA;AAmBlC;;;AC1BO,IAAMnH,cAAA,GAAN,MAAMuI,eAAA,SAAuB/B,KAAA,CAA+B;EAFnE;IAEmE5F,MAAA;EAAA;EAC3D4H,WAAA;EAEAC,KAAA;EAEA7B,MAAA;EAEAzB,IAAA;EAEAS,GAAA;EAEAV,KAAA;EAEAwD,cAAA;EAEAC,MAAA;EAEAtG,YAAY;IAAEmG,WAAA;IAAaC,KAAA;IAAO7B,MAAA;IAAQzB,IAAA;IAAMS,GAAA;IAAKV,KAAA;IAAOwD,cAAA;IAAgBC;EAAO,GAAkB;IAC3G,MAAM;IACN,KAAKH,WAAA,GAAcA,WAAA;IACnB,KAAKC,KAAA,GAAQA,KAAA;IACb,KAAK7B,MAAA,GAASA,MAAA;IACd,KAAKzB,IAAA,GAAOA,IAAA;IACZ,KAAKS,GAAA,GAAMA,GAAA;IACX,KAAKV,KAAA,GAAQA,KAAA;IACb,KAAKwD,cAAA,GAAiBA,cAAA;IACtB,KAAKC,MAAA,GAASA,MAAA;EACf;EAAA;AAAA;AAAA;EAKA,IAAoBxB,KAAA,EAAe;IAClC,OAAO,GAAGoB,eAAA,CAAepB,IAAI,IAAI,KAAKjC,KAAK;EAC5C;AACD;;;ACrCA,IAAA0D,iBAAA,GAA2B7H,OAAA;AAC3B,IAAA8H,gBAAA,GAAiC9H,OAAA;AACjC,IAAA+H,0BAAA,GAAkC/H,OAAA;AAClC,IAAAgI,kBAAA,GAA6BhI,OAAA;;;AC0TtB,IAAKd,aAAA,GAAL,gBAAK+I,cAAA,IAAL;EACNA,cAAA,aAAS;EACTA,cAAA,UAAM;EACNA,cAAA,YAAQ;EACRA,cAAA,WAAO;EACPA,cAAA,UAAM;EALK,OAAAA,cAAA;AAAA,GAAA/I,aAAA;;;ACxTZ,SAASgJ,qBAAqBC,KAAA,EAA+B;EAC5D,QAAQ,OAAOA,KAAA;IACd,KAAK;MACJ,OAAOA,KAAA;IACR,KAAK;IACL,KAAK;IACL,KAAK;MACJ,OAAOA,KAAA,CAAMlD,QAAA,CAAS;IACvB,KAAK;MACJ,IAAIkD,KAAA,KAAU,MAAM,OAAO;MAC3B,IAAIA,KAAA,YAAiBC,IAAA,EAAM;QAC1B,OAAOjB,MAAA,CAAOC,KAAA,CAAMe,KAAA,CAAME,OAAA,CAAQ,CAAC,IAAI,OAAOF,KAAA,CAAMG,WAAA,CAAY;MACjE;MAGA,IAAI,OAAOH,KAAA,CAAMlD,QAAA,KAAa,cAAckD,KAAA,CAAMlD,QAAA,KAAa+B,MAAA,CAAOuB,SAAA,CAAUtD,QAAA,EAAU,OAAOkD,KAAA,CAAMlD,QAAA,CAAS;MAChH,OAAO;IACR;MACC,OAAO;EACT;AACD;AApBSpF,MAAA,CAAAqI,oBAAA;AA6BF,SAAS9I,oBAAsCuC,OAAA,EAAuB;EAC5E,MAAM6G,MAAA,GAAS,IAAIC,eAAA,CAAgB;EACnC,IAAI,CAAC9G,OAAA,EAAS,OAAO6G,MAAA;EAErB,WAAW,CAAC7B,GAAA,EAAKwB,KAAK,KAAKnB,MAAA,CAAOC,OAAA,CAAQtF,OAAO,GAAG;IACnD,MAAM+G,UAAA,GAAaR,oBAAA,CAAqBC,KAAK;IAC7C,IAAIO,UAAA,KAAe,MAAMF,MAAA,CAAOG,MAAA,CAAOhC,GAAA,EAAK+B,UAAU;EACvD;EAEA,OAAOF,MAAA;AACR;AAVgB3I,MAAA,CAAAT,mBAAA;AAiBhB,eAAsBC,cAAcuJ,GAAA,EAAqC;EACxE,IAAIA,GAAA,CAAIrI,OAAA,CAAQgF,GAAA,CAAI,cAAc,GAAGjB,UAAA,CAAW,kBAAkB,GAAG;IACpE,OAAOsE,GAAA,CAAI1C,IAAA,CAAK;EACjB;EAEA,OAAO0C,GAAA,CAAIC,WAAA,CAAY;AACxB;AANsBhJ,MAAA,CAAAR,aAAA;AAgBf,SAASyJ,YAAYC,WAAA,EAAqB5C,IAAA,EAAgBN,MAAA,EAA0B;EAI1F,IAAIkD,WAAA,KAAgB,iBAAiB;IACpC,IAAI,OAAO5C,IAAA,KAAS,YAAYA,IAAA,KAAS,MAAM,OAAO;IAEtD,IAAIN,MAAA,0BAAgC,OAAO;IAC3C,MAAMmD,UAAA,GAAa7C,IAAA;IACnB,OAAO,CAAC,QAAQ,OAAO,EAAE8C,IAAA,CAAMtC,GAAA,IAAQvB,OAAA,CAAQC,GAAA,CAAI2D,UAAA,EAAYrC,GAAG,CAAC;EACpE;EAGA,OAAO;AACR;AAdgB9G,MAAA,CAAAiJ,WAAA;AAsBT,SAASI,YAAY/D,KAAA,EAAsC;EAEjE,IAAIA,KAAA,CAAMiB,IAAA,KAAS,cAAc,OAAO;EAExC,OAAQ,UAAUjB,KAAA,IAASA,KAAA,CAAMQ,IAAA,KAAS,gBAAiBR,KAAA,CAAMqB,OAAA,CAAQ9B,QAAA,CAAS,YAAY;AAC/F;AALgB7E,MAAA,CAAAqJ,WAAA;AAYhB,eAAsBC,YAAYC,OAAA,EAAeC,aAAA,EAA8B;EAC9E,MAAM;IAAE1H;EAAQ,IAAIyH,OAAA;EACpB,IAAI,CAACzH,OAAA,CAAQhB,iBAAA,EAAmB;EAEhC,MAAM2I,WAAA,GACL,OAAO3H,OAAA,CAAQhB,iBAAA,KAAsB,aAClC,MAAMgB,OAAA,CAAQhB,iBAAA,CAAkB0I,aAAa,IAC7C1H,OAAA,CAAQhB,iBAAA,CAAkBsI,IAAA,CAAM9E,KAAA,IAAUkF,aAAA,CAAclF,KAAA,CAAMG,UAAA,CAAWH,KAAA,CAAMM,WAAA,CAAY,CAAC,CAAC;EACjG,IAAI6E,WAAA,EAAa;IAChB,MAAM,IAAIrK,cAAA,CAAeoK,aAAa;EACvC;AACD;AAXsBxJ,MAAA,CAAAsJ,WAAA;AAkBf,SAAShK,gCAAgCiD,MAAA,EAAmB;EAClE,OAAO+E,MAAA,CAAOoC,MAAA,CAAOnH,MAAM,KAAK,GAAG,IAAI;AACxC;AAFgBvC,MAAA,CAAAV,+BAAA;AAShB,eAAsBqK,MAAMC,EAAA,EAA2B;EACtD,OAAO,IAAIC,OAAA,CAAeC,OAAA,IAAY;IACrCC,UAAA,CAAW,MAAMD,OAAA,CAAQ,GAAGF,EAAE;EAC/B,CAAC;AACF;AAJsB5J,MAAA,CAAA2J,KAAA;AAWf,SAASK,aAAa1B,KAAA,EAAgF;EAC5G,OAAOA,KAAA,YAAiB2B,WAAA,IAAe3B,KAAA,YAAiB4B,UAAA,IAAc5B,KAAA,YAAiB6B,iBAAA;AACxF;AAFgBnK,MAAA,CAAAgK,YAAA;;;AC3HhB,IAAII,YAAA,GAAe;AACnB,IAAIC,qBAAA,GAAuC;AAOpC,SAASC,sBAAsBf,OAAA,EAAe;EACpD,IAAI,CAACc,qBAAA,IAAyBA,qBAAA,GAAwB9B,IAAA,CAAKgC,GAAA,CAAI,GAAG;IACjEF,qBAAA,GAAwB9B,IAAA,CAAKgC,GAAA,CAAI,IAAI,MAAQ,KAAK;IAClDH,YAAA,GAAe;EAChB;EAEAA,YAAA;EAEA,MAAMI,WAAA,GACLjB,OAAA,CAAQzH,OAAA,CAAQnB,6BAAA,GAAgC,KAChDyJ,YAAA,GAAeb,OAAA,CAAQzH,OAAA,CAAQnB,6BAAA,KAAkC;EAClE,IAAI6J,WAAA,EAAa;IAEhBjB,OAAA,CAAQkB,IAAA,sDAAuC;MAC9CC,KAAA,EAAON,YAAA;MACPO,aAAA,EAAeN,qBAAA,GAAwB9B,IAAA,CAAKgC,GAAA,CAAI;IACjD,CAAC;EACF;AACD;AAlBgBvK,MAAA,CAAAsK,qBAAA;AAgChB,eAAsBM,mBACrBrB,OAAA,EACAsB,OAAA,EACA7F,GAAA,EACAlD,OAAA,EACAgJ,WAAA,EACA/J,OAAA,EACC;EACD,MAAMgK,UAAA,GAAa,IAAIC,eAAA,CAAgB;EACvC,MAAMhK,OAAA,GAAU+I,UAAA,CAAW,MAAMgB,UAAA,CAAWE,KAAA,CAAM,GAAG1B,OAAA,CAAQzH,OAAA,CAAQd,OAAO;EAC5E,IAAI8J,WAAA,CAAYI,MAAA,EAAQ;IAIvB,IAAIJ,WAAA,CAAYI,MAAA,CAAOC,OAAA,EAASJ,UAAA,CAAWE,KAAA,CAAM,OAC5CH,WAAA,CAAYI,MAAA,CAAOE,gBAAA,CAAiB,SAAS,MAAML,UAAA,CAAWE,KAAA,CAAM,CAAC;EAC3E;EAEA,IAAIlC,GAAA;EACJ,IAAI;IACHA,GAAA,GAAM,MAAMQ,OAAA,CAAQzH,OAAA,CAAQR,WAAA,CAAY0D,GAAA,EAAK;MAAE,GAAGlD,OAAA;MAASoJ,MAAA,EAAQH,UAAA,CAAWG;IAAO,CAAC;EACvF,SAAS5F,KAAA,EAAgB;IACxB,IAAI,EAAEA,KAAA,YAAiBM,KAAA,GAAQ,MAAMN,KAAA;IAErC,IAAI+D,WAAA,CAAY/D,KAAK,KAAKvE,OAAA,KAAYwI,OAAA,CAAQzH,OAAA,CAAQf,OAAA,EAAS;MAE9D,OAAO;IACR;IAEA,MAAMuE,KAAA;EACP,UAAE;IACD+F,YAAA,CAAarK,OAAO;EACrB;EAEA,IAAIuI,OAAA,CAAQ+B,aAAA,0BAAiC,GAAG;IAC/C/B,OAAA,CAAQkB,IAAA,4BAEP;MACCzE,MAAA,EAAQlE,OAAA,CAAQkE,MAAA,IAAU;MAC1BuF,IAAA,EAAMV,OAAA,CAAQW,QAAA;MACdlH,KAAA,EAAOuG,OAAA,CAAQ3B,WAAA;MACfpH,OAAA;MACA2J,IAAA,EAAMX,WAAA;MACN/J;IACD,GACAgI,GAAA,YAAe2C,QAAA,GAAW3C,GAAA,CAAI4C,KAAA,CAAM,IAAI;MAAE,GAAG5C;IAAI,CAClD;EACD;EAEA,OAAOA,GAAA;AACR;AAlDsB/I,MAAA,CAAA4K,kBAAA;AA+DtB,eAAsBgB,aACrBrC,OAAA,EACAR,GAAA,EACA/C,MAAA,EACAhB,GAAA,EACA8F,WAAA,EACA/J,OAAA,EACC;EACD,MAAMgF,MAAA,GAASgD,GAAA,CAAIhD,MAAA;EACnB,IAAIA,MAAA,IAAU,OAAOA,MAAA,GAAS,KAAK;IAElC,IAAIhF,OAAA,KAAYwI,OAAA,CAAQzH,OAAA,CAAQf,OAAA,EAAS;MACxC,OAAO;IACR;IAGA,MAAM,IAAI/B,SAAA,CAAU+G,MAAA,EAAQgD,GAAA,CAAIrB,UAAA,EAAY1B,MAAA,EAAQhB,GAAA,EAAK8F,WAAW;EACrE,OAAO;IAEN,IAAI/E,MAAA,IAAU,OAAOA,MAAA,GAAS,KAAK;MAElC,IAAIA,MAAA,KAAW,OAAO+E,WAAA,CAAYe,IAAA,EAAM;QACvCtC,OAAA,CAAQuC,QAAA,CAAS,IAAK;MACvB;MAGA,MAAML,IAAA,GAAQ,MAAMjM,aAAA,CAAcuJ,GAAG;MAErC,MAAM,IAAIhK,eAAA,CAAgB0M,IAAA,EAAM,UAAUA,IAAA,GAAOA,IAAA,CAAK3F,IAAA,GAAO2F,IAAA,CAAKnG,KAAA,EAAOS,MAAA,EAAQC,MAAA,EAAQhB,GAAA,EAAK8F,WAAW;IAC1G;IAEA,OAAO/B,GAAA;EACR;AACD;AAjCsB/I,MAAA,CAAA4L,YAAA;;;ACvGf,IAAMG,YAAA,GAAN,MAAuC;EAAA;AAAA;AAAA;AAAA;AAAA;EAgBtCtK,YACW8H,OAAA,EACAhF,IAAA,EACAuD,cAAA,EAChB;IAHgB,KAAAyB,OAAA,GAAAA,OAAA;IACA,KAAAhF,IAAA,GAAAA,IAAA;IACA,KAAAuD,cAAA,GAAAA,cAAA;IAEjB,KAAK3F,EAAA,GAAK,GAAGoC,IAAI,IAAIuD,cAAc;EACpC;EAtCD;IAgB8C9H,MAAA;EAAA;EAAA;AAAA;AAAA;EAI7BmC,EAAA;EAAA;AAAA;AAAA;EAKT6J,QAAA,GAAW;EAAA;AAAA;AAAA;AAAA;AAAA;EAoBVC,MAAMtF,OAAA,EAAiB;IAC9B,KAAK4C,OAAA,CAAQkB,IAAA,0BAAuB,SAAS,KAAKtI,EAAE,KAAKwE,OAAO,EAAE;EACnE;EAAA;AAAA;AAAA;EAKA,MAAauF,aACZrB,OAAA,EACA7F,GAAA,EACAlD,OAAA,EACAgJ,WAAA,EACwB;IACxB,OAAO,KAAKqB,UAAA,CAAWtB,OAAA,EAAS7F,GAAA,EAAKlD,OAAA,EAASgJ,WAAW;EAC1D;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAWA,MAAcqB,WACbtB,OAAA,EACA7F,GAAA,EACAlD,OAAA,EACAgJ,WAAA,EACA/J,OAAA,GAAU,GACc;IACxB,MAAMiF,MAAA,GAASlE,OAAA,CAAQkE,MAAA,IAAU;IAEjC,MAAM+C,GAAA,GAAM,MAAM6B,kBAAA,CAAmB,KAAKrB,OAAA,EAASsB,OAAA,EAAS7F,GAAA,EAAKlD,OAAA,EAASgJ,WAAA,EAAa/J,OAAO;IAG9F,IAAIgI,GAAA,KAAQ,MAAM;MAEjB,OAAO,KAAKoD,UAAA,CAAWtB,OAAA,EAAS7F,GAAA,EAAKlD,OAAA,EAASgJ,WAAA,EAAa,EAAE/J,OAAO;IACrE;IAEA,MAAMgF,MAAA,GAASgD,GAAA,CAAIhD,MAAA;IACnB,IAAIqG,UAAA,GAAa;IACjB,MAAMC,KAAA,GAAQtD,GAAA,CAAIrI,OAAA,CAAQgF,GAAA,CAAI,aAAa;IAG3C,IAAI2G,KAAA,EAAOD,UAAA,GAAa9E,MAAA,CAAO+E,KAAK,IAAI,MAAQ,KAAK9C,OAAA,CAAQzH,OAAA,CAAQjB,MAAA;IAGrE,IAAIkF,MAAA,KAAW,OAAOA,MAAA,KAAW,OAAOA,MAAA,KAAW,KAAK;MACvDuE,qBAAA,CAAsB,KAAKf,OAAO;IACnC;IAEA,IAAIxD,MAAA,IAAU,OAAOA,MAAA,GAAS,KAAK;MAClC,OAAOgD,GAAA;IACR,WAAWhD,MAAA,KAAW,KAAK;MAE1B,MAAMuG,QAAA,GAAWvD,GAAA,CAAIrI,OAAA,CAAQ8E,GAAA,CAAI,oBAAoB;MACrD,MAAM8D,WAAA,CAAY,KAAKC,OAAA,EAAS;QAC/B3B,WAAA,EAAawE,UAAA;QACbvE,KAAA,EAAOP,MAAA,CAAOiF,iBAAA;QACdvG,MAAA;QACAzB,IAAA,EAAM,KAAKA,IAAA;QACXS,GAAA;QACAV,KAAA,EAAOuG,OAAA,CAAQ3B,WAAA;QACfpB,cAAA,EAAgB,KAAKA,cAAA;QACrBC,MAAA,EAAQuE;MACT,CAAC;MACD,KAAKL,KAAA,CACJ,CACC,yCACA,sBAAsBK,QAAQ,IAC9B,sBAAsBtG,MAAM,IAC5B,sBAAsBhB,GAAG,IACzB,sBAAsB6F,OAAA,CAAQ3B,WAAW,IACzC,sBAAsB2B,OAAA,CAAQ/C,cAAc,IAC5C,sBAAsB,KAAKvD,IAAI,IAC/B,sBAAsB+C,MAAA,CAAOiF,iBAAiB,IAC9C,sBAAsBH,UAAU,MAChC,0BACD,CAAErH,IAAA,CAAK,IAAI,CACZ;MAGA,MAAM4E,KAAA,CAAMyC,UAAU;MAGtB,OAAO,KAAKD,UAAA,CAAWtB,OAAA,EAAS7F,GAAA,EAAKlD,OAAA,EAASgJ,WAAA,EAAa/J,OAAO;IACnE,OAAO;MACN,MAAMyL,OAAA,GAAU,MAAMZ,YAAA,CAAa,KAAKrC,OAAA,EAASR,GAAA,EAAK/C,MAAA,EAAQhB,GAAA,EAAK8F,WAAA,EAAa/J,OAAO;MACvF,IAAIyL,OAAA,KAAY,MAAM;QAErB,OAAO,KAAKL,UAAA,CAAWtB,OAAA,EAAS7F,GAAA,EAAKlD,OAAA,EAASgJ,WAAA,EAAa,EAAE/J,OAAO;MACrE;MAEA,OAAOyL,OAAA;IACR;EACD;AACD;;;AChJA,IAAAC,kBAAA,GAA2BtM,OAAA;AAiBpB,IAAMuM,iBAAA,GAAN,MAA4C;EAAA;AAAA;AAAA;AAAA;AAAA;EA8C3CjL,YACW8H,OAAA,EACAhF,IAAA,EACAuD,cAAA,EAChB;IAHgB,KAAAyB,OAAA,GAAAA,OAAA;IACA,KAAAhF,IAAA,GAAAA,IAAA;IACA,KAAAuD,cAAA,GAAAA,cAAA;IAEjB,KAAK3F,EAAA,GAAK,GAAGoC,IAAI,IAAIuD,cAAc;EACpC;EArED;IAiBmD9H,MAAA;EAAA;EAAA;AAAA;AAAA;EAIlCmC,EAAA;EAAA;AAAA;AAAA;EAKRwK,KAAA,GAAQ;EAAA;AAAA;AAAA;EAKRC,SAAA,GAAY;EAAA;AAAA;AAAA;EAKZ/E,KAAA,GAAQP,MAAA,CAAOiF,iBAAA;EAAA;AAAA;AAAA;EAKvB,CAAAM,UAAA,GAAc,IAAIJ,kBAAA,CAAAK,UAAA,CAAW;EAAA;AAAA;AAAA;EAK7B,CAAAC,eAAA,GAAsC;EAAA;AAAA;AAAA;EAKtC,CAAAC,eAAA,GAAuE;EAAA;AAAA;AAAA;EAKvE,CAAAC,aAAA,GAAiB;EAAA;AAAA;AAAA;EAkBjB,IAAWjB,SAAA,EAAoB;IAC9B,OACC,KAAK,CAAAa,UAAA,CAAYD,SAAA,KAAc,MAC9B,KAAK,CAAAG,eAAA,KAAqB,QAAQ,KAAK,CAAAA,eAAA,CAAiBH,SAAA,KAAc,MACvE,CAAC,KAAKM,OAAA;EAER;EAAA;AAAA;AAAA;EAKA,IAAYC,cAAA,EAAyB;IACpC,OAAO,KAAK5D,OAAA,CAAQ6D,eAAA,IAAmB,KAAK7E,IAAA,CAAKgC,GAAA,CAAI,IAAI,KAAKhB,OAAA,CAAQ8D,WAAA;EACvE;EAAA;AAAA;AAAA;EAKA,IAAYC,aAAA,EAAwB;IACnC,OAAO,KAAKV,SAAA,IAAa,KAAKrE,IAAA,CAAKgC,GAAA,CAAI,IAAI,KAAKoC,KAAA;EACjD;EAAA;AAAA;AAAA;EAKA,IAAYO,QAAA,EAAmB;IAC9B,OAAO,KAAKC,aAAA,IAAiB,KAAKG,YAAA;EACnC;EAAA;AAAA;AAAA;EAKA,IAAY1F,YAAA,EAAsB;IACjC,OAAO,KAAK+E,KAAA,GAAQ,KAAKpD,OAAA,CAAQzH,OAAA,CAAQjB,MAAA,GAAS0H,IAAA,CAAKgC,GAAA,CAAI;EAC5D;EAAA;AAAA;AAAA;AAAA;AAAA;EAOQ0B,MAAMtF,OAAA,EAAiB;IAC9B,KAAK4C,OAAA,CAAQkB,IAAA,0BAAuB,SAAS,KAAKtI,EAAE,KAAKwE,OAAO,EAAE;EACnE;EAAA;AAAA;AAAA;AAAA;AAAA;EAOA,MAAc4G,eAAeC,IAAA,EAA6B;IACzD,MAAM7D,KAAA,CAAM6D,IAAI;IAChB,KAAKjE,OAAA,CAAQkE,WAAA,GAAc;EAC5B;EAAA;AAAA;AAAA;EAKA,MAAavB,aACZrB,OAAA,EACA7F,GAAA,EACAlD,OAAA,EACAgJ,WAAA,EACwB;IACxB,IAAI4C,KAAA,GAAQ,KAAK,CAAAb,UAAA;IACjB,IAAIc,SAAA,GAAY;IAEhB,IAAI,KAAK,CAAAZ,eAAA,IAAoB9D,WAAA,CAAY4B,OAAA,CAAQ3B,WAAA,EAAa4B,WAAA,CAAYxE,IAAA,EAAMxE,OAAA,CAAQkE,MAAM,GAAG;MAChG0H,KAAA,GAAQ,KAAK,CAAAX,eAAA;MACbY,SAAA,GAAY;IACb;IAGA,MAAMD,KAAA,CAAME,IAAA,CAAK;MAAE1C,MAAA,EAAQJ,WAAA,CAAYI;IAAO,CAAC;IAE/C,IAAIyC,SAAA,KAAc,kBAAoB;MACrC,IAAI,KAAK,CAAAZ,eAAA,IAAoB9D,WAAA,CAAY4B,OAAA,CAAQ3B,WAAA,EAAa4B,WAAA,CAAYxE,IAAA,EAAMxE,OAAA,CAAQkE,MAAM,GAAG;QAKhG0H,KAAA,GAAQ,KAAK,CAAAX,eAAA;QACb,MAAMa,IAAA,GAAOF,KAAA,CAAME,IAAA,CAAK;QACxB,KAAK,CAAAf,UAAA,CAAYgB,KAAA,CAAM;QACvB,MAAMD,IAAA;MACP,WAAW,KAAK,CAAAZ,eAAA,EAAkB;QAEjC,MAAM,KAAK,CAAAA,eAAA,CAAiBc,OAAA;MAC7B;IACD;IAEA,IAAI;MAEH,OAAO,MAAM,KAAK3B,UAAA,CAAWtB,OAAA,EAAS7F,GAAA,EAAKlD,OAAA,EAASgJ,WAAW;IAChE,UAAE;MAED4C,KAAA,CAAMG,KAAA,CAAM;MACZ,IAAI,KAAK,CAAAZ,aAAA,EAAgB;QACxB,KAAK,CAAAA,aAAA,GAAiB;QACtB,KAAK,CAAAF,eAAA,EAAkBc,KAAA,CAAM;MAC9B;MAGA,IAAI,KAAK,CAAAd,eAAA,EAAkBH,SAAA,KAAc,GAAG;QAC3C,KAAK,CAAAI,eAAA,EAAkBlD,OAAA,CAAQ;QAC/B,KAAK,CAAAiD,eAAA,GAAmB;MACzB;IACD;EACD;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAWA,MAAcZ,WACbtB,OAAA,EACA7F,GAAA,EACAlD,OAAA,EACAgJ,WAAA,EACA/J,OAAA,GAAU,GACc;IAKxB,OAAO,KAAKmM,OAAA,EAAS;MACpB,MAAMZ,QAAA,GAAW,KAAKa,aAAA;MACtB,IAAIY,MAAA;MACJ,IAAI/M,OAAA;MACJ,IAAIgN,KAAA;MAEJ,IAAI1B,QAAA,EAAU;QAEbyB,MAAA,GAAQ,KAAKxE,OAAA,CAAQzH,OAAA,CAAQlB,uBAAA;QAC7BI,OAAA,GAAU,KAAKuI,OAAA,CAAQ8D,WAAA,GAAc,KAAK9D,OAAA,CAAQzH,OAAA,CAAQjB,MAAA,GAAS0H,IAAA,CAAKgC,GAAA,CAAI;QAE5E,IAAI,CAAC,KAAKhB,OAAA,CAAQkE,WAAA,EAAa;UAE9B,KAAKlE,OAAA,CAAQkE,WAAA,GAAc,KAAKF,cAAA,CAAevM,OAAO;QACvD;QAEAgN,KAAA,GAAQ,KAAKzE,OAAA,CAAQkE,WAAA;MACtB,OAAO;QAENM,MAAA,GAAQ,KAAKlG,KAAA;QACb7G,OAAA,GAAU,KAAK4G,WAAA;QACfoG,KAAA,GAAQrE,KAAA,CAAM3I,OAAO;MACtB;MAEA,MAAMwI,aAAA,GAA+B;QACpC5B,WAAA,EAAa5G,OAAA;QACb6G,KAAA,EAAAkG,MAAA;QACA/H,MAAA,EAAQlE,OAAA,CAAQkE,MAAA,IAAU;QAC1BzB,IAAA,EAAM,KAAKA,IAAA;QACXS,GAAA;QACAV,KAAA,EAAOuG,OAAA,CAAQ3B,WAAA;QACfpB,cAAA,EAAgB,KAAKA,cAAA;QACrBC,MAAA,EAAQuE;MACT;MAEA,KAAK/C,OAAA,CAAQkB,IAAA,kCAA6BjB,aAAa;MAEvD,MAAMF,WAAA,CAAY,KAAKC,OAAA,EAASC,aAAa;MAE7C,IAAI8C,QAAA,EAAU;QACb,KAAKL,KAAA,CAAM,oDAAoDjL,OAAO,IAAI;MAC3E,OAAO;QACN,KAAKiL,KAAA,CAAM,WAAWjL,OAAO,2BAA2B;MACzD;MAGA,MAAMgN,KAAA;IACP;IAGA,IAAI,CAAC,KAAKzE,OAAA,CAAQ8D,WAAA,IAAe,KAAK9D,OAAA,CAAQ8D,WAAA,GAAc9E,IAAA,CAAKgC,GAAA,CAAI,GAAG;MACvE,KAAKhB,OAAA,CAAQ8D,WAAA,GAAc9E,IAAA,CAAKgC,GAAA,CAAI,IAAI;MACxC,KAAKhB,OAAA,CAAQ6D,eAAA,GAAkB,KAAK7D,OAAA,CAAQzH,OAAA,CAAQlB,uBAAA;IACrD;IAEA,KAAK2I,OAAA,CAAQ6D,eAAA;IAEb,MAAMpH,MAAA,GAASlE,OAAA,CAAQkE,MAAA,IAAU;IAEjC,MAAM+C,GAAA,GAAM,MAAM6B,kBAAA,CAAmB,KAAKrB,OAAA,EAASsB,OAAA,EAAS7F,GAAA,EAAKlD,OAAA,EAASgJ,WAAA,EAAa/J,OAAO;IAG9F,IAAIgI,GAAA,KAAQ,MAAM;MAEjB,OAAO,KAAKoD,UAAA,CAAWtB,OAAA,EAAS7F,GAAA,EAAKlD,OAAA,EAASgJ,WAAA,EAAa,EAAE/J,OAAO;IACrE;IAEA,MAAMgF,MAAA,GAASgD,GAAA,CAAIhD,MAAA;IACnB,IAAIqG,UAAA,GAAa;IAEjB,MAAMvE,KAAA,GAAQkB,GAAA,CAAIrI,OAAA,CAAQgF,GAAA,CAAI,mBAAmB;IACjD,MAAMkH,SAAA,GAAY7D,GAAA,CAAIrI,OAAA,CAAQgF,GAAA,CAAI,uBAAuB;IACzD,MAAMiH,KAAA,GAAQ5D,GAAA,CAAIrI,OAAA,CAAQgF,GAAA,CAAI,yBAAyB;IACvD,MAAMnB,IAAA,GAAOwE,GAAA,CAAIrI,OAAA,CAAQgF,GAAA,CAAI,oBAAoB;IACjD,MAAM2G,KAAA,GAAQtD,GAAA,CAAIrI,OAAA,CAAQgF,GAAA,CAAI,aAAa;IAG3C,KAAKmC,KAAA,GAAQA,KAAA,GAAQP,MAAA,CAAOO,KAAK,IAAIP,MAAA,CAAOiF,iBAAA;IAE5C,KAAKK,SAAA,GAAYA,SAAA,GAAYtF,MAAA,CAAOsF,SAAS,IAAI;IAEjD,KAAKD,KAAA,GAAQA,KAAA,GAAQrF,MAAA,CAAOqF,KAAK,IAAI,MAAQpE,IAAA,CAAKgC,GAAA,CAAI,IAAI,KAAKhB,OAAA,CAAQzH,OAAA,CAAQjB,MAAA,GAAS0H,IAAA,CAAKgC,GAAA,CAAI;IAGjG,IAAI8B,KAAA,EAAOD,UAAA,GAAa9E,MAAA,CAAO+E,KAAK,IAAI,MAAQ,KAAK9C,OAAA,CAAQzH,OAAA,CAAQjB,MAAA;IAGrE,IAAI0D,IAAA,IAAQA,IAAA,KAAS,KAAKA,IAAA,EAAM;MAE/B,KAAK0H,KAAA,CAAM,CAAC,+BAA+B,iBAAiB,KAAK1H,IAAI,IAAI,iBAAiBA,IAAI,EAAE,EAAEQ,IAAA,CAAK,IAAI,CAAC;MAE5G,KAAKwE,OAAA,CAAQ0E,MAAA,CAAO9I,GAAA,CAAI,GAAGa,MAAM,IAAI6E,OAAA,CAAQ3B,WAAW,IAAI;QAAEZ,KAAA,EAAO/D,IAAA;QAAM2J,UAAA,EAAY3F,IAAA,CAAKgC,GAAA,CAAI;MAAE,CAAC;IACpG,WAAWhG,IAAA,EAAM;MAGhB,MAAM4J,QAAA,GAAW,KAAK5E,OAAA,CAAQ0E,MAAA,CAAOvI,GAAA,CAAI,GAAGM,MAAM,IAAI6E,OAAA,CAAQ3B,WAAW,EAAE;MAG3E,IAAIiF,QAAA,EAAU;QACbA,QAAA,CAASD,UAAA,GAAa3F,IAAA,CAAKgC,GAAA,CAAI;MAChC;IACD;IAGA,IAAI6D,eAAA,GAAiC;IACrC,IAAIhC,UAAA,GAAa,GAAG;MACnB,IAAIrD,GAAA,CAAIrI,OAAA,CAAQ8E,GAAA,CAAI,oBAAoB,GAAG;QAC1C,KAAK+D,OAAA,CAAQ6D,eAAA,GAAkB;QAC/B,KAAK7D,OAAA,CAAQ8D,WAAA,GAAc9E,IAAA,CAAKgC,GAAA,CAAI,IAAI6B,UAAA;MACzC,WAAW,CAAC,KAAKkB,YAAA,EAAc;QAM9Bc,eAAA,GAAkBhC,UAAA;MACnB;IACD;IAGA,IAAIrG,MAAA,KAAW,OAAOA,MAAA,KAAW,OAAOA,MAAA,KAAW,KAAK;MACvDuE,qBAAA,CAAsB,KAAKf,OAAO;IACnC;IAEA,IAAIR,GAAA,CAAIsF,EAAA,EAAI;MACX,OAAOtF,GAAA;IACR,WAAWhD,MAAA,KAAW,KAAK;MAE1B,MAAMuG,QAAA,GAAW,KAAKa,aAAA;MACtB,IAAIY,MAAA;MACJ,IAAI/M,OAAA;MAEJ,IAAIsL,QAAA,EAAU;QAEbyB,MAAA,GAAQ,KAAKxE,OAAA,CAAQzH,OAAA,CAAQlB,uBAAA;QAC7BI,OAAA,GAAU,KAAKuI,OAAA,CAAQ8D,WAAA,GAAc,KAAK9D,OAAA,CAAQzH,OAAA,CAAQjB,MAAA,GAAS0H,IAAA,CAAKgC,GAAA,CAAI;MAC7E,OAAO;QAENwD,MAAA,GAAQ,KAAKlG,KAAA;QACb7G,OAAA,GAAU,KAAK4G,WAAA;MAChB;MAEA,MAAM0B,WAAA,CAAY,KAAKC,OAAA,EAAS;QAC/B3B,WAAA,EAAa5G,OAAA;QACb6G,KAAA,EAAAkG,MAAA;QACA/H,MAAA;QACAzB,IAAA,EAAM,KAAKA,IAAA;QACXS,GAAA;QACAV,KAAA,EAAOuG,OAAA,CAAQ3B,WAAA;QACfpB,cAAA,EAAgB,KAAKA,cAAA;QACrBC,MAAA,EAAQuE;MACT,CAAC;MACD,KAAKL,KAAA,CACJ,CACC,yCACA,sBAAsBK,QAAA,CAASlH,QAAA,CAAS,CAAC,IACzC,sBAAsBY,MAAM,IAC5B,sBAAsBhB,GAAG,IACzB,sBAAsB6F,OAAA,CAAQ3B,WAAW,IACzC,sBAAsB2B,OAAA,CAAQ/C,cAAc,IAC5C,sBAAsB,KAAKvD,IAAI,IAC/B,sBAAsBwJ,MAAK,IAC3B,sBAAsB3B,UAAU,MAChC,sBAAsBgC,eAAA,GAAkB,GAAGA,eAAe,OAAO,MAAM,GACxE,CAAErJ,IAAA,CAAK,IAAI,CACZ;MAEA,IAAIqJ,eAAA,EAAiB;QAEpB,MAAME,aAAA,GAAgB,CAAC,KAAK,CAAAvB,eAAA;QAC5B,IAAIuB,aAAA,EAAe;UAClB,KAAK,CAAAvB,eAAA,GAAmB,IAAIN,kBAAA,CAAAK,UAAA,CAAW;UACvC,KAAK,KAAK,CAAAC,eAAA,CAAiBa,IAAA,CAAK;UAChC,KAAK,CAAAf,UAAA,CAAYgB,KAAA,CAAM;QACxB;QAEA,KAAK,CAAAb,eAAA,EAAkBlD,OAAA,CAAQ;QAC/B,KAAK,CAAAkD,eAAA,GAAmB;QACxB,MAAMrD,KAAA,CAAMyE,eAAe;QAC3B,IAAItE,OAAA;QAEJ,MAAMgE,OAAA,GAAU,IAAIjE,OAAA,CAAe0E,IAAA,IAASzE,OAAA,GAAUyE,IAAI;QAC1D,KAAK,CAAAvB,eAAA,GAAmB;UAAEc,OAAA;UAAShE;QAAkB;QACrD,IAAIwE,aAAA,EAAe;UAElB,MAAM,KAAK,CAAAzB,UAAA,CAAYe,IAAA,CAAK;UAC5B,KAAK,CAAAX,aAAA,GAAiB;QACvB;MACD;MAGA,OAAO,KAAKd,UAAA,CAAWtB,OAAA,EAAS7F,GAAA,EAAKlD,OAAA,EAASgJ,WAAA,EAAa/J,OAAO;IACnE,OAAO;MACN,MAAMyL,OAAA,GAAU,MAAMZ,YAAA,CAAa,KAAKrC,OAAA,EAASR,GAAA,EAAK/C,MAAA,EAAQhB,GAAA,EAAK8F,WAAA,EAAa/J,OAAO;MACvF,IAAIyL,OAAA,KAAY,MAAM;QAErB,OAAO,KAAKL,UAAA,CAAWtB,OAAA,EAAS7F,GAAA,EAAKlD,OAAA,EAASgJ,WAAA,EAAa,EAAE/J,OAAO;MACrE;MAEA,OAAOyL,OAAA;IACR;EACD;AACD;;;ALrXO,IAAMtN,IAAA,GAAN,MAAMsP,KAAA,SAAatG,0BAAA,CAAAuG,iBAAA,CAAiC;EAjC3D;IAiC2DzO,MAAA;EAAA;EAAA;AAAA;AAAA;AAAA;EAKnDM,KAAA,GAA2B;EAElBG,GAAA;EAAA;AAAA;AAAA;EAKT2M,eAAA;EAAA;AAAA;AAAA;EAKAK,WAAA,GAAoC;EAAA;AAAA;AAAA;EAKpCJ,WAAA,GAAc;EAAA;AAAA;AAAA;EAKLY,MAAA,GAAS,IAAIjG,iBAAA,CAAA0G,UAAA,CAA6B;EAAA;AAAA;AAAA;EAK1CC,QAAA,GAAW,IAAI3G,iBAAA,CAAA0G,UAAA,CAA6B;EAE5D,CAAAE,KAAA,GAAwB;EAEhBC,SAAA;EAEAC,YAAA;EAEQhN,OAAA;EAETL,YAAYK,OAAA,GAAgC,CAAC,GAAG;IACtD,MAAM;IACN,KAAKrB,GAAA,GAAM,IAAI9B,GAAA,CAAImD,OAAA,CAAQrB,GAAA,IAAO7B,kBAAA,CAAmB6B,GAAG;IACxD,KAAKqB,OAAA,GAAU;MAAE,GAAGlD,kBAAA;MAAoB,GAAGkD;IAAQ;IACnD,KAAKA,OAAA,CAAQjB,MAAA,GAASkO,IAAA,CAAKC,GAAA,CAAI,GAAG,KAAKlN,OAAA,CAAQjB,MAAM;IACrD,KAAKuM,eAAA,GAAkB2B,IAAA,CAAKC,GAAA,CAAI,GAAG,KAAKlN,OAAA,CAAQlB,uBAAuB;IACvE,KAAKN,KAAA,GAAQwB,OAAA,CAAQxB,KAAA,IAAS;IAG9B,KAAK2O,aAAA,CAAc;EACpB;EAEQA,cAAA,EAAgB;IAEvB,MAAMC,mBAAA,GAAsB,eAAAlP,MAAA,CAACmP,QAAA,IAAqB;MACjD,IAAIA,QAAA,GAAW,OAAY;QAC1B,MAAM,IAAIvJ,KAAA,CAAM,6CAA6C;MAC9D;IACD,GAJ4B;IAM5B,IAAI,KAAK9D,OAAA,CAAQX,iBAAA,KAAsB,KAAK,KAAKW,OAAA,CAAQX,iBAAA,KAAsBmG,MAAA,CAAOiF,iBAAA,EAAmB;MACxG2C,mBAAA,CAAoB,KAAKpN,OAAA,CAAQX,iBAAiB;MAClD,KAAK0N,SAAA,GAAYO,WAAA,CAAY,MAAM;QAClC,MAAMC,WAAA,GAAc,IAAIrH,iBAAA,CAAA0G,UAAA,CAA6B;QACrD,MAAMY,WAAA,GAAc/G,IAAA,CAAKgC,GAAA,CAAI;QAG7B,KAAK0D,MAAA,CAAOsB,KAAA,CAAM,CAACrI,GAAA,EAAKJ,GAAA,KAAQ;UAE/B,IAAII,GAAA,CAAIgH,UAAA,KAAe,IAAI,OAAO;UAGlC,MAAMsB,WAAA,GAAcT,IAAA,CAAKU,KAAA,CAAMH,WAAA,GAAcpI,GAAA,CAAIgH,UAAU,IAAI,KAAKpM,OAAA,CAAQV,YAAA;UAG5E,IAAIoO,WAAA,EAAa;YAEhBH,WAAA,CAAYlK,GAAA,CAAI2B,GAAA,EAAKI,GAAG;YAGxB,KAAKuD,IAAA,0BAAuB,QAAQvD,GAAA,CAAIoB,KAAK,QAAQxB,GAAG,uCAAuC;UAChG;UAEA,OAAO0I,WAAA;QACR,CAAC;QAGD,KAAK/E,IAAA,8BAA2B4E,WAAW;MAC5C,GAAG,KAAKvN,OAAA,CAAQX,iBAAiB;MAEjC,KAAK0N,SAAA,CAAUa,KAAA,GAAQ;IACxB;IAEA,IAAI,KAAK5N,OAAA,CAAQT,oBAAA,KAAyB,KAAK,KAAKS,OAAA,CAAQT,oBAAA,KAAyBiG,MAAA,CAAOiF,iBAAA,EAAmB;MAC9G2C,mBAAA,CAAoB,KAAKpN,OAAA,CAAQT,oBAAoB;MACrD,KAAKyN,YAAA,GAAeM,WAAA,CAAY,MAAM;QACrC,MAAMO,aAAA,GAAgB,IAAI3H,iBAAA,CAAA0G,UAAA,CAA6B;QAGvD,KAAKC,QAAA,CAASY,KAAA,CAAM,CAACrI,GAAA,EAAKJ,GAAA,KAAQ;UACjC,MAAM;YAAEkF;UAAS,IAAI9E,GAAA;UAGrB,IAAI8E,QAAA,EAAU;YACb2D,aAAA,CAAcxK,GAAA,CAAI2B,GAAA,EAAKI,GAAG;YAC1B,KAAKuD,IAAA,0BAAuB,WAAWvD,GAAA,CAAI/E,EAAE,QAAQ2E,GAAG,8BAA8B;UACvF;UAEA,OAAOkF,QAAA;QACR,CAAC;QAGD,KAAKvB,IAAA,oCAA8BkF,aAAa;MACjD,GAAG,KAAK7N,OAAA,CAAQT,oBAAoB;MAEpC,KAAKyN,YAAA,CAAaY,KAAA,GAAQ;IAC3B;EACD;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAQA,MAAahK,IAAIkK,SAAA,EAAsB9N,OAAA,GAAuB,CAAC,GAAG;IACjE,OAAO,KAAK+N,OAAA,CAAQ;MAAE,GAAG/N,OAAA;MAAS8N,SAAA;MAAW5J,MAAA;IAA0B,CAAC;EACzE;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAQA,MAAa8J,OAAOF,SAAA,EAAsB9N,OAAA,GAAuB,CAAC,GAAG;IACpE,OAAO,KAAK+N,OAAA,CAAQ;MAAE,GAAG/N,OAAA;MAAS8N,SAAA;MAAW5J,MAAA;IAA6B,CAAC;EAC5E;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAQA,MAAa+J,KAAKH,SAAA,EAAsB9N,OAAA,GAAuB,CAAC,GAAG;IAClE,OAAO,KAAK+N,OAAA,CAAQ;MAAE,GAAG/N,OAAA;MAAS8N,SAAA;MAAW5J,MAAA;IAA2B,CAAC;EAC1E;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAQA,MAAagK,IAAIJ,SAAA,EAAsB9N,OAAA,GAAuB,CAAC,GAAG;IACjE,OAAO,KAAK+N,OAAA,CAAQ;MAAE,GAAG/N,OAAA;MAAS8N,SAAA;MAAW5J,MAAA;IAA0B,CAAC;EACzE;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAQA,MAAaiK,MAAML,SAAA,EAAsB9N,OAAA,GAAuB,CAAC,GAAG;IACnE,OAAO,KAAK+N,OAAA,CAAQ;MAAE,GAAG/N,OAAA;MAAS8N,SAAA;MAAW5J,MAAA;IAA4B,CAAC;EAC3E;EAAA;AAAA;AAAA;AAAA;AAAA;EAOA,MAAa6J,QAAQ/N,OAAA,EAA0B;IAC9C,MAAMoO,QAAA,GAAW,MAAM,KAAKhE,YAAA,CAAapK,OAAO;IAChD,OAAOtC,aAAA,CAAc0Q,QAAQ;EAC9B;EAAA;AAAA;AAAA;AAAA;AAAA;EAOOC,SAAS7P,KAAA,EAAmB;IAClC,KAAKA,KAAA,GAAQA,KAAA;IACb,OAAO;EACR;EAAA;AAAA;AAAA;AAAA;AAAA;EAOOwL,SAAS8C,KAAA,EAAe;IAC9B,KAAK,CAAAA,KAAA,GAASA,KAAA;IACd,OAAO;EACR;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAQA,MAAa1C,aAAa2D,OAAA,EAAiD;IAE1E,MAAMhF,OAAA,GAAU2D,KAAA,CAAK4B,iBAAA,CAAkBP,OAAA,CAAQD,SAAA,EAAWC,OAAA,CAAQ7J,MAAM;IAExE,MAAMzB,IAAA,GAAO,KAAK0J,MAAA,CAAOvI,GAAA,CAAI,GAAGmK,OAAA,CAAQ7J,MAAM,IAAI6E,OAAA,CAAQ3B,WAAW,EAAE,KAAK;MAC3EZ,KAAA,EAAO,UAAUuH,OAAA,CAAQ7J,MAAM,IAAI6E,OAAA,CAAQ3B,WAAW;MACtDgF,UAAA,EAAY;IACb;IAGA,MAAMmC,OAAA,GACL,KAAK1B,QAAA,CAASjJ,GAAA,CAAI,GAAGnB,IAAA,CAAK+D,KAAK,IAAIuC,OAAA,CAAQ/C,cAAc,EAAE,KAC3D,KAAKwI,aAAA,CAAc/L,IAAA,CAAK+D,KAAA,EAAOuC,OAAA,CAAQ/C,cAAc;IAGtD,MAAM;MAAE9C,GAAA;MAAKuL;IAAa,IAAI,MAAM,KAAKC,cAAA,CAAeX,OAAO;IAG/D,OAAOQ,OAAA,CAAQnE,YAAA,CAAarB,OAAA,EAAS7F,GAAA,EAAKuL,YAAA,EAAc;MACvDjK,IAAA,EAAMuJ,OAAA,CAAQvJ,IAAA;MACdF,KAAA,EAAOyJ,OAAA,CAAQzJ,KAAA;MACfyF,IAAA,EAAMgE,OAAA,CAAQhE,IAAA,KAAS;MACvBX,MAAA,EAAQ2E,OAAA,CAAQ3E;IACjB,CAAC;EACF;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASQoF,cAAc/L,IAAA,EAAcuD,cAAA,EAAwB;IAE3D,MAAM4F,KAAA,GACL5F,cAAA,KAAmBpJ,sBAAA,GAChB,IAAIqN,YAAA,CAAa,MAAMxH,IAAA,EAAMuD,cAAc,IAC3C,IAAI4E,iBAAA,CAAkB,MAAMnI,IAAA,EAAMuD,cAAc;IAEpD,KAAK6G,QAAA,CAASxJ,GAAA,CAAIuI,KAAA,CAAMvL,EAAA,EAAIuL,KAAK;IAEjC,OAAOA,KAAA;EACR;EAAA;AAAA;AAAA;AAAA;AAAA;EAOA,MAAc8C,eAAeX,OAAA,EAA+E;IAC3G,MAAM;MAAE/N;IAAQ,IAAI;IAEpB,IAAI2O,KAAA,GAAQ;IAGZ,IAAIZ,OAAA,CAAQY,KAAA,EAAO;MAClB,MAAMC,aAAA,GAAgBb,OAAA,CAAQY,KAAA,CAAMrL,QAAA,CAAS;MAC7C,IAAIsL,aAAA,KAAkB,IAAI;QACzBD,KAAA,GAAQ,IAAIC,aAAa;MAC1B;IACD;IAGA,MAAMhQ,OAAA,GAA0B;MAC/B,GAAG,KAAKoB,OAAA,CAAQpB,OAAA;MAChB,cAAc,GAAG7B,gBAAgB,IAAIiD,OAAA,CAAQb,iBAAiB,GAAG+F,IAAA,CAAK;IACvE;IAGA,IAAI6I,OAAA,CAAQhE,IAAA,KAAS,OAAO;MAE3B,IAAI,CAAC,KAAK,CAAA+C,KAAA,EAAQ;QACjB,MAAM,IAAIhJ,KAAA,CAAM,iEAAiE;MAClF;MAEAlF,OAAA,CAAQiQ,aAAA,GAAgB,GAAGd,OAAA,CAAQrP,UAAA,IAAc,KAAKsB,OAAA,CAAQtB,UAAU,IAAI,KAAK,CAAAoO,KAAM;IACxF;IAGA,IAAIiB,OAAA,CAAQe,MAAA,EAAQ7J,MAAA,EAAQ;MAC3BrG,OAAA,CAAQ,oBAAoB,IAAImQ,kBAAA,CAAmBhB,OAAA,CAAQe,MAAM;IAClE;IAGA,MAAM5L,GAAA,GAAM,GAAGlD,OAAA,CAAQvB,GAAG,GAAGsP,OAAA,CAAQiB,SAAA,KAAc,QAAQ,KAAK,KAAKhP,OAAA,CAAQrC,OAAO,EAAE,GACrFoQ,OAAA,CAAQD,SACT,GAAGa,KAAK;IAER,IAAIM,SAAA;IACJ,IAAIC,iBAAA,GAA4C,CAAC;IAEjD,IAAInB,OAAA,CAAQzJ,KAAA,EAAOW,MAAA,EAAQ;MAC1B,MAAMkK,QAAA,GAAW,IAAIC,QAAA,CAAS;MAG9B,WAAW,CAACpO,KAAA,EAAOqO,IAAI,KAAKtB,OAAA,CAAQzJ,KAAA,CAAMgB,OAAA,CAAQ,GAAG;QACpD,MAAMgK,OAAA,GAAUD,IAAA,CAAKrK,GAAA,IAAO,SAAShE,KAAK;QAM1C,IAAIkH,YAAA,CAAamH,IAAA,CAAK1F,IAAI,GAAG;UAE5B,IAAI4F,WAAA,GAAcF,IAAA,CAAKE,WAAA;UAEvB,IAAI,CAACA,WAAA,EAAa;YACjB,MAAM,CAACC,UAAU,QAAInJ,kBAAA,CAAAoJ,YAAA,EAAaJ,IAAA,CAAK1F,IAAI;YAE3C,IAAI6F,UAAA,EAAY;cACfD,WAAA,GACCpS,oBAAA,CAAqBqS,UAAA,CAAWE,IAAyC,KACzEF,UAAA,CAAWE,IAAA,IACX;YACF;UACD;UAEAP,QAAA,CAASnI,MAAA,CAAOsI,OAAA,EAAS,IAAIK,IAAA,CAAK,CAACN,IAAA,CAAK1F,IAAI,GAAG;YAAEiG,IAAA,EAAML;UAAY,CAAC,GAAGF,IAAA,CAAK5K,IAAI;QACjF,OAAO;UACN0K,QAAA,CAASnI,MAAA,CAAOsI,OAAA,EAAS,IAAIK,IAAA,CAAK,CAAC,GAAGN,IAAA,CAAK1F,IAAI,EAAE,GAAG;YAAEiG,IAAA,EAAMP,IAAA,CAAKE;UAAY,CAAC,GAAGF,IAAA,CAAK5K,IAAI;QAC3F;MACD;MAIA,IAAIsJ,OAAA,CAAQvJ,IAAA,IAAQ,MAAM;QACzB,IAAIuJ,OAAA,CAAQ8B,gBAAA,EAAkB;UAC7B,WAAW,CAAC7K,GAAA,EAAKwB,KAAK,KAAKnB,MAAA,CAAOC,OAAA,CAAQyI,OAAA,CAAQvJ,IAA+B,GAAG;YACnF2K,QAAA,CAASnI,MAAA,CAAOhC,GAAA,EAAKwB,KAAK;UAC3B;QACD,OAAO;UACN2I,QAAA,CAASnI,MAAA,CAAO,gBAAgB8I,IAAA,CAAKC,SAAA,CAAUhC,OAAA,CAAQvJ,IAAI,CAAC;QAC7D;MACD;MAGAyK,SAAA,GAAYE,QAAA;IAGb,WAAWpB,OAAA,CAAQvJ,IAAA,IAAQ,MAAM;MAChC,IAAIuJ,OAAA,CAAQiC,eAAA,EAAiB;QAC5Bf,SAAA,GAAYlB,OAAA,CAAQvJ,IAAA;MACrB,OAAO;QAENyK,SAAA,GAAYa,IAAA,CAAKC,SAAA,CAAUhC,OAAA,CAAQvJ,IAAI;QAEvC0K,iBAAA,GAAoB;UAAE,gBAAgB;QAAmB;MAC1D;IACD;IAEA,MAAMhL,MAAA,GAAS6J,OAAA,CAAQ7J,MAAA,CAAO+L,WAAA,CAAY;IAG1C,MAAMxB,YAAA,GAA4B;MAAA;MAEjCjK,IAAA,EAAM,CAAC,OAAO,MAAM,EAAEzB,QAAA,CAASmB,MAAM,IAAI,OAAO+K,SAAA;MAChDrQ,OAAA,EAAS;QAAE,GAAGmP,OAAA,CAAQnP,OAAA;QAAS,GAAGsQ,iBAAA;QAAmB,GAAGtQ;MAAQ;MAChEsF,MAAA;MAAA;MAEAgM,UAAA,EAAYnC,OAAA,CAAQmC,UAAA,IAAc,KAAK1R,KAAA,IAAS;IACjD;IAEA,OAAO;MAAE0E,GAAA;MAAKuL;IAAa;EAC5B;EAAA;AAAA;AAAA;EAKO0B,iBAAA,EAAmB;IACzBC,aAAA,CAAc,KAAKrD,SAAS;EAC7B;EAAA;AAAA;AAAA;EAKOsD,oBAAA,EAAsB;IAC5BD,aAAA,CAAc,KAAKpD,YAAY;EAChC;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASA,OAAesB,kBAAkBgC,QAAA,EAAqBpM,MAAA,EAAkC;IACvF,IAAIoM,QAAA,CAAS3N,UAAA,CAAW,gBAAgB,KAAK2N,QAAA,CAASC,QAAA,CAAS,WAAW,GAAG;MAC5E,OAAO;QACNvK,cAAA,EAAgBpJ,sBAAA;QAChBwK,WAAA,EAAa;QACbsC,QAAA,EAAU4G;MACX;IACD;IAEA,MAAME,YAAA,GAAe,+CAA+CC,IAAA,CAAKH,QAAQ;IAGjF,MAAMI,OAAA,GAAUF,YAAA,GAAe,CAAC,KAAK;IAErC,MAAMG,SAAA,GAAYL,QAAA,CAEhBM,UAAA,CAAW,cAAc,KAAK,EAE9BC,OAAA,CAAQ,qBAAqB,sBAAsB;IAErD,IAAIC,UAAA,GAAa;IAIjB,IAAI5M,MAAA,8BAAmCyM,SAAA,KAAc,8BAA8B;MAClF,MAAMtQ,EAAA,GAAK,aAAaoQ,IAAA,CAAKH,QAAQ,EAAG,CAAC;MACzC,MAAMS,SAAA,GAAY5K,gBAAA,CAAA6K,gBAAA,CAAiBC,aAAA,CAAc5Q,EAAE;MACnD,IAAIoG,IAAA,CAAKgC,GAAA,CAAI,IAAIsI,SAAA,GAAY,MAAQ,KAAK,KAAK,KAAK,IAAI;QACvDD,UAAA,IAAc;MACf;IACD;IAEA,OAAO;MACN9K,cAAA,EAAgB0K,OAAA;MAChBtJ,WAAA,EAAauJ,SAAA,GAAYG,UAAA;MACzBpH,QAAA,EAAU4G;IACX;EACD;AACD;;;AMncO,IAAM3S,OAAA,GAAU;;;AbZvBK,kBAAA,CAAmBkT,KAAK","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}