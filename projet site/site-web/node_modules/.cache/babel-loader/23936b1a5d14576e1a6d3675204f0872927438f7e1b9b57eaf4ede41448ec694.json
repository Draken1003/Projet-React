{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('node:events');\nconst process = require('node:process');\nconst {\n  setTimeout,\n  clearTimeout\n} = require('node:timers');\nconst {\n  GatewayIntentBits\n} = require('discord-api-types/v10');\nconst Status = require('../../util/Status');\nconst WebSocketShardEvents = require('../../util/WebSocketShardEvents');\nlet deprecationEmittedForImportant = false;\n/**\n * Represents a Shard's WebSocket connection\n * @extends {EventEmitter}\n */\nclass WebSocketShard extends EventEmitter {\n  constructor(manager, id) {\n    super();\n\n    /**\n     * The WebSocketManager of the shard\n     * @type {WebSocketManager}\n     */\n    this.manager = manager;\n\n    /**\n     * The shard's id\n     * @type {number}\n     */\n    this.id = id;\n\n    /**\n     * The current status of the shard\n     * @type {Status}\n     */\n    this.status = Status.Idle;\n\n    /**\n     * The sequence of the shard after close\n     * @type {number}\n     * @private\n     */\n    this.closeSequence = 0;\n\n    /**\n     * The previous heartbeat ping of the shard\n     * @type {number}\n     */\n    this.ping = -1;\n\n    /**\n     * The last time a ping was sent (a timestamp)\n     * @type {number}\n     */\n    this.lastPingTimestamp = -1;\n\n    /**\n     * A set of guild ids this shard expects to receive\n     * @name WebSocketShard#expectedGuilds\n     * @type {?Set<string>}\n     * @private\n     */\n    Object.defineProperty(this, 'expectedGuilds', {\n      value: null,\n      writable: true\n    });\n\n    /**\n     * The ready timeout\n     * @name WebSocketShard#readyTimeout\n     * @type {?NodeJS.Timeout}\n     * @private\n     */\n    Object.defineProperty(this, 'readyTimeout', {\n      value: null,\n      writable: true\n    });\n\n    /**\n     * @external SessionInfo\n     * @see {@link https://discord.js.org/docs/packages/ws/stable/SessionInfo:Interface}\n     */\n\n    /**\n     * The session info used by `@discordjs/ws` package.\n     * @name WebSocketShard#sessionInfo\n     * @type {?SessionInfo}\n     * @private\n     */\n    Object.defineProperty(this, 'sessionInfo', {\n      value: null,\n      writable: true\n    });\n  }\n\n  /**\n   * Emits a debug event.\n   * @param {string} message The debug message\n   * @private\n   */\n  debug(message) {\n    this.manager.debug(message, this.id);\n  }\n\n  /**\n   * @external CloseEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}\n   */\n\n  /**\n   * This method is responsible to emit close event for this shard.\n   * This method helps the shard reconnect.\n   * @param {CloseEvent} [event] Close event that was received\n   * @deprecated\n   */\n  emitClose(event = {\n    code: 1011,\n    reason: 'INTERNAL_ERROR',\n    wasClean: false\n  }) {\n    this.debug(`[CLOSE]\n    Event Code: ${event.code}\n    Clean     : ${event.wasClean}\n    Reason    : ${event.reason ?? 'No reason received'}`);\n    /**\n     * Emitted when a shard's WebSocket closes.\n     * @private\n     * @event WebSocketShard#close\n     * @param {CloseEvent} event The received event\n     */\n    this.emit(WebSocketShardEvents.Close, event);\n  }\n\n  /**\n   * Called when the shard receives the READY payload.\n   * @param {Object} packet The received packet\n   * @private\n   */\n  onReadyPacket(packet) {\n    if (!packet) {\n      this.debug(`Received broken packet: '${packet}'.`);\n      return;\n    }\n\n    /**\n     * Emitted when the shard receives the READY payload and is now waiting for guilds\n     * @event WebSocketShard#ready\n     */\n    this.emit(WebSocketShardEvents.Ready);\n    this.expectedGuilds = new Set(packet.guilds.map(d => d.id));\n    this.status = Status.WaitingForGuilds;\n  }\n\n  /**\n   * Called when a GuildCreate or GuildDelete for this shard was sent after READY payload was received,\n   * but before we emitted the READY event.\n   * @param {Snowflake} guildId the id of the Guild sent in the payload\n   * @private\n   */\n  gotGuild(guildId) {\n    this.expectedGuilds.delete(guildId);\n    this.checkReady();\n  }\n\n  /**\n   * Checks if the shard can be marked as ready\n   * @private\n   */\n  checkReady() {\n    // Step 0. Clear the ready timeout, if it exists\n    if (this.readyTimeout) {\n      clearTimeout(this.readyTimeout);\n      this.readyTimeout = null;\n    }\n    // Step 1. If we don't have any other guilds pending, we are ready\n    if (!this.expectedGuilds.size) {\n      this.debug('Shard received all its guilds. Marking as fully ready.');\n      this.status = Status.Ready;\n\n      /**\n       * Emitted when the shard is fully ready.\n       * This event is emitted if:\n       * * all guilds were received by this shard\n       * * the ready timeout expired, and some guilds are unavailable\n       * @event WebSocketShard#allReady\n       * @param {?Set<string>} unavailableGuilds Set of unavailable guilds, if any\n       */\n      this.emit(WebSocketShardEvents.AllReady);\n      return;\n    }\n    const hasGuildsIntent = this.manager.client.options.intents.has(GatewayIntentBits.Guilds);\n    // Step 2. Create a timeout that will mark the shard as ready if there are still unavailable guilds\n    // * The timeout is 15 seconds by default\n    // * This can be optionally changed in the client options via the `waitGuildTimeout` option\n    // * a timeout time of zero will skip this timeout, which potentially could cause the Client to miss guilds.\n\n    const {\n      waitGuildTimeout\n    } = this.manager.client.options;\n    this.readyTimeout = setTimeout(() => {\n      this.debug(`Shard ${hasGuildsIntent ? 'did' : 'will'} not receive any more guild packets` + `${hasGuildsIntent ? ` in ${waitGuildTimeout} ms` : ''}.\\nUnavailable guild count: ${this.expectedGuilds.size}`);\n      this.readyTimeout = null;\n      this.status = Status.Ready;\n      this.emit(WebSocketShardEvents.AllReady, this.expectedGuilds);\n    }, hasGuildsIntent ? waitGuildTimeout : 0).unref();\n  }\n\n  /**\n   * Adds a packet to the queue to be sent to the gateway.\n   * <warn>If you use this method, make sure you understand that you need to provide\n   * a full [Payload](https://discord.com/developers/docs/topics/gateway#commands-and-events-gateway-commands).\n   * Do not use this method if you don't know what you're doing.</warn>\n   * @param {Object} data The full packet to send\n   * @param {boolean} [important=false] If this packet should be added first in queue\n   * <warn>This parameter is **deprecated**. Important payloads are determined by their opcode instead.</warn>\n   */\n  send(data, important = false) {\n    if (important && !deprecationEmittedForImportant) {\n      process.emitWarning('Sending important payloads explicitly is deprecated. They are determined by their opcode implicitly now.', 'DeprecationWarning');\n      deprecationEmittedForImportant = true;\n    }\n    this.manager._ws.send(this.id, data);\n  }\n}\nmodule.exports = WebSocketShard;","map":{"version":3,"names":["EventEmitter","require","process","setTimeout","clearTimeout","GatewayIntentBits","Status","WebSocketShardEvents","deprecationEmittedForImportant","WebSocketShard","constructor","manager","id","status","Idle","closeSequence","ping","lastPingTimestamp","Object","defineProperty","value","writable","debug","message","emitClose","event","code","reason","wasClean","emit","Close","onReadyPacket","packet","Ready","expectedGuilds","Set","guilds","map","d","WaitingForGuilds","gotGuild","guildId","delete","checkReady","readyTimeout","size","AllReady","hasGuildsIntent","client","options","intents","has","Guilds","waitGuildTimeout","unref","send","data","important","emitWarning","_ws","module","exports"],"sources":["C:/Users/hetit/node_modules/discord.js/src/client/websocket/WebSocketShard.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('node:events');\nconst process = require('node:process');\nconst { setTimeout, clearTimeout } = require('node:timers');\nconst { GatewayIntentBits } = require('discord-api-types/v10');\nconst Status = require('../../util/Status');\nconst WebSocketShardEvents = require('../../util/WebSocketShardEvents');\n\nlet deprecationEmittedForImportant = false;\n/**\n * Represents a Shard's WebSocket connection\n * @extends {EventEmitter}\n */\nclass WebSocketShard extends EventEmitter {\n  constructor(manager, id) {\n    super();\n\n    /**\n     * The WebSocketManager of the shard\n     * @type {WebSocketManager}\n     */\n    this.manager = manager;\n\n    /**\n     * The shard's id\n     * @type {number}\n     */\n    this.id = id;\n\n    /**\n     * The current status of the shard\n     * @type {Status}\n     */\n    this.status = Status.Idle;\n\n    /**\n     * The sequence of the shard after close\n     * @type {number}\n     * @private\n     */\n    this.closeSequence = 0;\n\n    /**\n     * The previous heartbeat ping of the shard\n     * @type {number}\n     */\n    this.ping = -1;\n\n    /**\n     * The last time a ping was sent (a timestamp)\n     * @type {number}\n     */\n    this.lastPingTimestamp = -1;\n\n    /**\n     * A set of guild ids this shard expects to receive\n     * @name WebSocketShard#expectedGuilds\n     * @type {?Set<string>}\n     * @private\n     */\n    Object.defineProperty(this, 'expectedGuilds', { value: null, writable: true });\n\n    /**\n     * The ready timeout\n     * @name WebSocketShard#readyTimeout\n     * @type {?NodeJS.Timeout}\n     * @private\n     */\n    Object.defineProperty(this, 'readyTimeout', { value: null, writable: true });\n\n    /**\n     * @external SessionInfo\n     * @see {@link https://discord.js.org/docs/packages/ws/stable/SessionInfo:Interface}\n     */\n\n    /**\n     * The session info used by `@discordjs/ws` package.\n     * @name WebSocketShard#sessionInfo\n     * @type {?SessionInfo}\n     * @private\n     */\n    Object.defineProperty(this, 'sessionInfo', { value: null, writable: true });\n  }\n\n  /**\n   * Emits a debug event.\n   * @param {string} message The debug message\n   * @private\n   */\n  debug(message) {\n    this.manager.debug(message, this.id);\n  }\n\n  /**\n   * @external CloseEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}\n   */\n\n  /**\n   * This method is responsible to emit close event for this shard.\n   * This method helps the shard reconnect.\n   * @param {CloseEvent} [event] Close event that was received\n   * @deprecated\n   */\n  emitClose(\n    event = {\n      code: 1011,\n      reason: 'INTERNAL_ERROR',\n      wasClean: false,\n    },\n  ) {\n    this.debug(`[CLOSE]\n    Event Code: ${event.code}\n    Clean     : ${event.wasClean}\n    Reason    : ${event.reason ?? 'No reason received'}`);\n    /**\n     * Emitted when a shard's WebSocket closes.\n     * @private\n     * @event WebSocketShard#close\n     * @param {CloseEvent} event The received event\n     */\n    this.emit(WebSocketShardEvents.Close, event);\n  }\n\n  /**\n   * Called when the shard receives the READY payload.\n   * @param {Object} packet The received packet\n   * @private\n   */\n  onReadyPacket(packet) {\n    if (!packet) {\n      this.debug(`Received broken packet: '${packet}'.`);\n      return;\n    }\n\n    /**\n     * Emitted when the shard receives the READY payload and is now waiting for guilds\n     * @event WebSocketShard#ready\n     */\n    this.emit(WebSocketShardEvents.Ready);\n\n    this.expectedGuilds = new Set(packet.guilds.map(d => d.id));\n    this.status = Status.WaitingForGuilds;\n  }\n\n  /**\n   * Called when a GuildCreate or GuildDelete for this shard was sent after READY payload was received,\n   * but before we emitted the READY event.\n   * @param {Snowflake} guildId the id of the Guild sent in the payload\n   * @private\n   */\n  gotGuild(guildId) {\n    this.expectedGuilds.delete(guildId);\n    this.checkReady();\n  }\n\n  /**\n   * Checks if the shard can be marked as ready\n   * @private\n   */\n  checkReady() {\n    // Step 0. Clear the ready timeout, if it exists\n    if (this.readyTimeout) {\n      clearTimeout(this.readyTimeout);\n      this.readyTimeout = null;\n    }\n    // Step 1. If we don't have any other guilds pending, we are ready\n    if (!this.expectedGuilds.size) {\n      this.debug('Shard received all its guilds. Marking as fully ready.');\n      this.status = Status.Ready;\n\n      /**\n       * Emitted when the shard is fully ready.\n       * This event is emitted if:\n       * * all guilds were received by this shard\n       * * the ready timeout expired, and some guilds are unavailable\n       * @event WebSocketShard#allReady\n       * @param {?Set<string>} unavailableGuilds Set of unavailable guilds, if any\n       */\n      this.emit(WebSocketShardEvents.AllReady);\n      return;\n    }\n    const hasGuildsIntent = this.manager.client.options.intents.has(GatewayIntentBits.Guilds);\n    // Step 2. Create a timeout that will mark the shard as ready if there are still unavailable guilds\n    // * The timeout is 15 seconds by default\n    // * This can be optionally changed in the client options via the `waitGuildTimeout` option\n    // * a timeout time of zero will skip this timeout, which potentially could cause the Client to miss guilds.\n\n    const { waitGuildTimeout } = this.manager.client.options;\n\n    this.readyTimeout = setTimeout(\n      () => {\n        this.debug(\n          `Shard ${hasGuildsIntent ? 'did' : 'will'} not receive any more guild packets` +\n            `${hasGuildsIntent ? ` in ${waitGuildTimeout} ms` : ''}.\\nUnavailable guild count: ${\n              this.expectedGuilds.size\n            }`,\n        );\n\n        this.readyTimeout = null;\n        this.status = Status.Ready;\n\n        this.emit(WebSocketShardEvents.AllReady, this.expectedGuilds);\n      },\n      hasGuildsIntent ? waitGuildTimeout : 0,\n    ).unref();\n  }\n\n  /**\n   * Adds a packet to the queue to be sent to the gateway.\n   * <warn>If you use this method, make sure you understand that you need to provide\n   * a full [Payload](https://discord.com/developers/docs/topics/gateway#commands-and-events-gateway-commands).\n   * Do not use this method if you don't know what you're doing.</warn>\n   * @param {Object} data The full packet to send\n   * @param {boolean} [important=false] If this packet should be added first in queue\n   * <warn>This parameter is **deprecated**. Important payloads are determined by their opcode instead.</warn>\n   */\n  send(data, important = false) {\n    if (important && !deprecationEmittedForImportant) {\n      process.emitWarning(\n        'Sending important payloads explicitly is deprecated. They are determined by their opcode implicitly now.',\n        'DeprecationWarning',\n      );\n      deprecationEmittedForImportant = true;\n    }\n    this.manager._ws.send(this.id, data);\n  }\n}\n\nmodule.exports = WebSocketShard;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}