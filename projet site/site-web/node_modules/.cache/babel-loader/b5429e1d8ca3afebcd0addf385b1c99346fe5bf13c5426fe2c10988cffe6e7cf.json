{"ast":null,"code":"'use strict';\n\nconst {\n  setTimeout,\n  clearTimeout\n} = require('node:timers');\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  makeURLSearchParams\n} = require('@discordjs/rest');\nconst {\n  DiscordSnowflake\n} = require('@sapphire/snowflake');\nconst {\n  Routes,\n  GatewayOpcodes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst {\n  DiscordjsError,\n  DiscordjsTypeError,\n  DiscordjsRangeError,\n  ErrorCodes\n} = require('../errors');\nconst BaseGuildVoiceChannel = require('../structures/BaseGuildVoiceChannel');\nconst {\n  GuildMember\n} = require('../structures/GuildMember');\nconst {\n  Role\n} = require('../structures/Role');\nconst Events = require('../util/Events');\nconst {\n  GuildMemberFlagsBitField\n} = require('../util/GuildMemberFlagsBitField');\nconst Partials = require('../util/Partials');\n\n/**\n * Manages API methods for GuildMembers and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildMemberManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, GuildMember, iterable);\n\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, GuildMember>}\n   * @name GuildMemberManager#cache\n   */\n\n  _add(data, cache = true) {\n    return super._add(data, cache, {\n      id: data.user.id,\n      extras: [this.guild]\n    });\n  }\n\n  /**\n   * Data that resolves to give a GuildMember object. This can be:\n   * * A GuildMember object\n   * * A User resolvable\n   * @typedef {GuildMember|UserResolvable} GuildMemberResolvable\n   */\n\n  /**\n   * Resolves a {@link GuildMemberResolvable} to a {@link GuildMember} object.\n   * @param {GuildMemberResolvable} member The user that is part of the guild\n   * @returns {?GuildMember}\n   */\n  resolve(member) {\n    const memberResolvable = super.resolve(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveId(member);\n    if (userResolvable) return super.resolve(userResolvable);\n    return null;\n  }\n\n  /**\n   * Resolves a {@link GuildMemberResolvable} to a member id.\n   * @param {GuildMemberResolvable} member The user that is part of the guild\n   * @returns {?Snowflake}\n   */\n  resolveId(member) {\n    const memberResolvable = super.resolveId(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveId(member);\n    return this.cache.has(userResolvable) ? userResolvable : null;\n  }\n\n  /**\n   * Options used to add a user to a guild using OAuth2.\n   * @typedef {Object} AddGuildMemberOptions\n   * @property {string} accessToken An OAuth2 access token for the user with the {@link OAuth2Scopes.GuildsJoin}\n   * scope granted to the bot's application\n   * @property {string} [nick] The nickname to give to the member\n   * <info>This property requires the {@link PermissionFlagsBits.ManageNicknames} permission.</info>\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles to add to the member\n   * <info>This property requires the {@link PermissionFlagsBits.ManageRoles} permission.</info>\n   * @property {boolean} [mute] Whether the member should be muted\n   * <info>This property requires the {@link PermissionFlagsBits.MuteMembers} permission.</info>\n   * @property {boolean} [deaf] Whether the member should be deafened\n   * <info>This property requires the {@link PermissionFlagsBits.MuteMembers} permission.</info>\n   * @property {boolean} [force] Whether to skip the cache check and request the API directly\n   * @property {boolean} [fetchWhenExisting=true] Whether to fetch the user if not cached and already a member\n   */\n\n  /**\n   * Adds a user to the guild using OAuth2.\n   * <info>This method requires the {@link PermissionFlagsBits.CreateInstantInvite} permission.\n   * @param {UserResolvable} user The user to add to the guild\n   * @param {AddGuildMemberOptions} options Options for adding the user to the guild\n   * @returns {Promise<GuildMember|null>}\n   */\n  async add(user, options) {\n    const userId = this.client.users.resolveId(user);\n    if (!userId) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'user', 'UserResolvable');\n    if (!options.force) {\n      const cachedUser = this.cache.get(userId);\n      if (cachedUser) return cachedUser;\n    }\n    const resolvedOptions = {\n      access_token: options.accessToken,\n      nick: options.nick,\n      mute: options.mute,\n      deaf: options.deaf\n    };\n    if (options.roles) {\n      if (!Array.isArray(options.roles) && !(options.roles instanceof Collection)) {\n        throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'options.roles', 'Array or Collection of Roles or Snowflakes', true);\n      }\n      const resolvedRoles = [];\n      for (const role of options.roles.values()) {\n        const resolvedRole = this.guild.roles.resolveId(role);\n        if (!resolvedRole) {\n          throw new DiscordjsTypeError(ErrorCodes.InvalidElement, 'Array or Collection', 'options.roles', role);\n        }\n        resolvedRoles.push(resolvedRole);\n      }\n      resolvedOptions.roles = resolvedRoles;\n    }\n    const data = await this.client.rest.put(Routes.guildMember(this.guild.id, userId), {\n      body: resolvedOptions\n    });\n    // Data is an empty Uint8Array if the member is already part of the guild.\n    return data instanceof Uint8Array ? options.fetchWhenExisting === false ? null : this.fetch(userId) : this._add(data);\n  }\n\n  /**\n   * The client user as a GuildMember of this guild\n   * @type {?GuildMember}\n   * @readonly\n   */\n  get me() {\n    return this.resolve(this.client.user.id) ?? (this.client.options.partials.includes(Partials.GuildMember) ? this._add({\n      user: {\n        id: this.client.user.id\n      }\n    }, true) : null);\n  }\n\n  /**\n   * Options used to fetch a single member from a guild.\n   * @typedef {BaseFetchOptions} FetchMemberOptions\n   * @property {UserResolvable} user The user to fetch\n   */\n\n  /**\n   * Options used to fetch multiple members from a guild.\n   * @typedef {Object} FetchMembersOptions\n   * @property {UserResolvable|UserResolvable[]} [user] The user(s) to fetch\n   * @property {?string} [query] Limit fetch to members with similar usernames\n   * @property {number} [limit=0] Maximum number of members to request\n   * @property {boolean} [withPresences=false] Whether to include the presences\n   * @property {number} [time=120e3] Timeout for receipt of members\n   * @property {?string} [nonce] Nonce for this request (32 characters max - default to base 16 now timestamp)\n   */\n\n  /**\n   * Fetches member(s) from a guild.\n   * @param {UserResolvable|FetchMemberOptions|FetchMembersOptions} [options] Options for fetching member(s).\n   * Omitting the parameter or providing `undefined` will fetch all members.\n   * @returns {Promise<GuildMember|Collection<Snowflake, GuildMember>>}\n   * @example\n   * // Fetch all members from a guild\n   * guild.members.fetch()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single member\n   * guild.members.fetch('66564597481480192')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single member without checking cache\n   * guild.members.fetch({ user, force: true })\n   *   .then(console.log)\n   *   .catch(console.error)\n   * @example\n   * // Fetch a single member without caching\n   * guild.members.fetch({ user, cache: false })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch by an array of users including their presences\n   * guild.members.fetch({ user: ['66564597481480192', '191615925336670208'], withPresences: true })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch by query\n   * guild.members.fetch({ query: 'hydra', limit: 1 })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  fetch(options) {\n    if (!options) return this._fetchMany();\n    const {\n      user: users,\n      limit,\n      withPresences,\n      cache,\n      force\n    } = options;\n    const resolvedUser = this.client.users.resolveId(users ?? options);\n    if (resolvedUser && !limit && !withPresences) return this._fetchSingle({\n      user: resolvedUser,\n      cache,\n      force\n    });\n    const resolvedUsers = users?.map?.(user => this.client.users.resolveId(user)) ?? resolvedUser ?? undefined;\n    return this._fetchMany({\n      ...options,\n      users: resolvedUsers\n    });\n  }\n  async _fetchSingle({\n    user,\n    cache,\n    force = false\n  }) {\n    if (!force) {\n      const existing = this.cache.get(user);\n      if (existing && !existing.partial) return existing;\n    }\n    const data = await this.client.rest.get(Routes.guildMember(this.guild.id, user));\n    return this._add(data, cache);\n  }\n  _fetchMany({\n    limit = 0,\n    withPresences: presences,\n    users,\n    query,\n    time = 120e3,\n    nonce = DiscordSnowflake.generate().toString()\n  } = {}) {\n    if (nonce.length > 32) return Promise.reject(new DiscordjsRangeError(ErrorCodes.MemberFetchNonceLength));\n    return new Promise((resolve, reject) => {\n      if (!query && !users) query = '';\n      this.guild.shard.send({\n        op: GatewayOpcodes.RequestGuildMembers,\n        d: {\n          guild_id: this.guild.id,\n          presences,\n          user_ids: users,\n          query,\n          nonce,\n          limit\n        }\n      });\n      const fetchedMembers = new Collection();\n      let i = 0;\n      const handler = (members, _, chunk) => {\n        if (chunk.nonce !== nonce) return;\n        timeout.refresh();\n        i++;\n        for (const member of members.values()) {\n          fetchedMembers.set(member.id, member);\n        }\n        if (members.size < 1_000 || limit && fetchedMembers.size >= limit || i === chunk.count) {\n          clearTimeout(timeout);\n          this.client.removeListener(Events.GuildMembersChunk, handler);\n          this.client.decrementMaxListeners();\n          resolve(users && !Array.isArray(users) && fetchedMembers.size ? fetchedMembers.first() : fetchedMembers);\n        }\n      };\n      const timeout = setTimeout(() => {\n        this.client.removeListener(Events.GuildMembersChunk, handler);\n        this.client.decrementMaxListeners();\n        reject(new DiscordjsError(ErrorCodes.GuildMembersTimeout));\n      }, time).unref();\n      this.client.incrementMaxListeners();\n      this.client.on(Events.GuildMembersChunk, handler);\n    });\n  }\n\n  /**\n   * Fetches the client user as a GuildMember of the guild.\n   * @param {BaseFetchOptions} [options] The options for fetching the member\n   * @returns {Promise<GuildMember>}\n   */\n  fetchMe(options) {\n    return this.fetch({\n      ...options,\n      user: this.client.user.id\n    });\n  }\n\n  /**\n   * Options used for searching guild members.\n   * @typedef {Object} GuildSearchMembersOptions\n   * @property {string} query Filter members whose username or nickname start with this query\n   * @property {number} [limit] Maximum number of members to search\n   * @property {boolean} [cache=true] Whether or not to cache the fetched member(s)\n   */\n\n  /**\n   * Searches for members in the guild based on a query.\n   * @param {GuildSearchMembersOptions} options Options for searching members\n   * @returns {Promise<Collection<Snowflake, GuildMember>>}\n   */\n  async search({\n    query,\n    limit,\n    cache = true\n  } = {}) {\n    const data = await this.client.rest.get(Routes.guildMembersSearch(this.guild.id), {\n      query: makeURLSearchParams({\n        query,\n        limit\n      })\n    });\n    return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection());\n  }\n\n  /**\n   * Options used for listing guild members.\n   * @typedef {Object} GuildListMembersOptions\n   * @property {Snowflake} [after] Limit fetching members to those with an id greater than the supplied id\n   * @property {number} [limit] Maximum number of members to list\n   * @property {boolean} [cache=true] Whether or not to cache the fetched member(s)\n   */\n\n  /**\n   * Lists up to 1000 members of the guild.\n   * @param {GuildListMembersOptions} [options] Options for listing members\n   * @returns {Promise<Collection<Snowflake, GuildMember>>}\n   */\n  async list({\n    after,\n    limit,\n    cache = true\n  } = {}) {\n    const query = makeURLSearchParams({\n      limit,\n      after\n    });\n    const data = await this.client.rest.get(Routes.guildMembers(this.guild.id), {\n      query\n    });\n    return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection());\n  }\n\n  /**\n   * The data for editing a guild member.\n   * @typedef {Object} GuildMemberEditOptions\n   * @property {?string} [nick] The nickname to set for the member\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles or role ids to apply\n   * @property {boolean} [mute] Whether or not the member should be muted\n   * @property {boolean} [deaf] Whether or not the member should be deafened\n   * @property {GuildVoiceChannelResolvable|null} [channel] Channel to move the member to\n   * (if they are connected to voice), or `null` if you want to disconnect them from voice\n   * @property {DateResolvable|null} [communicationDisabledUntil] The date or timestamp\n   * for the member's communication to be disabled until. Provide `null` to enable communication again.\n   * @property {GuildMemberFlagsResolvable} [flags] The flags to set for the member\n   * @property {string} [reason] Reason for editing this user\n   */\n\n  /**\n   * Edits a member of the guild.\n   * <info>The user must be a member of the guild</info>\n   * @param {UserResolvable} user The member to edit\n   * @param {GuildMemberEditOptions} options The options to provide\n   * @returns {Promise<GuildMember>}\n   */\n  async edit(user, {\n    reason,\n    ...options\n  }) {\n    const id = this.client.users.resolveId(user);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'user', 'UserResolvable');\n    if (options.channel) {\n      options.channel = this.guild.channels.resolve(options.channel);\n      if (!(options.channel instanceof BaseGuildVoiceChannel)) {\n        throw new DiscordjsError(ErrorCodes.GuildVoiceChannelResolve);\n      }\n      options.channel_id = options.channel.id;\n      options.channel = undefined;\n    } else if (options.channel === null) {\n      options.channel_id = null;\n      options.channel = undefined;\n    }\n    options.roles &&= options.roles.map(role => role instanceof Role ? role.id : role);\n    if (options.communicationDisabledUntil !== undefined) {\n      options.communication_disabled_until =\n      // eslint-disable-next-line eqeqeq\n      options.communicationDisabledUntil != null ? new Date(options.communicationDisabledUntil).toISOString() : options.communicationDisabledUntil;\n    }\n    if (options.flags !== undefined) {\n      options.flags = GuildMemberFlagsBitField.resolve(options.flags);\n    }\n    let endpoint;\n    if (id === this.client.user.id) {\n      const keys = Object.keys(options);\n      if (keys.length === 1 && keys[0] === 'nick') endpoint = Routes.guildMember(this.guild.id);else endpoint = Routes.guildMember(this.guild.id, id);\n    } else {\n      endpoint = Routes.guildMember(this.guild.id, id);\n    }\n    const d = await this.client.rest.patch(endpoint, {\n      body: options,\n      reason\n    });\n    const clone = this.cache.get(id)?._clone();\n    clone?._patch(d);\n    return clone ?? this._add(d, false);\n  }\n\n  /**\n   * Options used for pruning guild members.\n   * <info>It's recommended to set {@link GuildPruneMembersOptions#count options.count}\n   * to `false` for large guilds.</info>\n   * @typedef {Object} GuildPruneMembersOptions\n   * @property {number} [days] Number of days of inactivity required to kick\n   * @property {boolean} [dry=false] Get the number of users that will be kicked, without actually kicking them\n   * @property {boolean} [count] Whether or not to return the number of users that have been kicked.\n   * @property {RoleResolvable[]} [roles] Array of roles to bypass the \"...and no roles\" constraint when pruning\n   * @property {string} [reason] Reason for this prune\n   */\n\n  /**\n   * Prunes members from the guild based on how long they have been inactive.\n   * @param {GuildPruneMembersOptions} [options] Options for pruning\n   * @returns {Promise<number|null>} The number of members that were/will be kicked\n   * @example\n   * // See how many members will be pruned\n   * guild.members.prune({ dry: true })\n   *   .then(pruned => console.log(`This will prune ${pruned} people!`))\n   *   .catch(console.error);\n   * @example\n   * // Actually prune the members\n   * guild.members.prune({ days: 1, reason: 'too many people!' })\n   *   .then(pruned => console.log(`I just pruned ${pruned} people!`))\n   *   .catch(console.error);\n   * @example\n   * // Include members with a specified role\n   * guild.members.prune({ days: 7, roles: ['657259391652855808'] })\n   *    .then(pruned => console.log(`I just pruned ${pruned} people!`))\n   *    .catch(console.error);\n   */\n  async prune({\n    days,\n    dry = false,\n    count: compute_prune_count,\n    roles = [],\n    reason\n  } = {}) {\n    if (typeof days !== 'number') throw new DiscordjsTypeError(ErrorCodes.PruneDaysType);\n    const query = {\n      days\n    };\n    const resolvedRoles = [];\n    for (const role of roles) {\n      const resolvedRole = this.guild.roles.resolveId(role);\n      if (!resolvedRole) {\n        throw new DiscordjsTypeError(ErrorCodes.InvalidElement, 'Array', 'options.roles', role);\n      }\n      resolvedRoles.push(resolvedRole);\n    }\n    if (resolvedRoles.length) {\n      query.include_roles = dry ? resolvedRoles.join(',') : resolvedRoles;\n    }\n    const endpoint = Routes.guildPrune(this.guild.id);\n    const {\n      pruned\n    } = await (dry ? this.client.rest.get(endpoint, {\n      query: makeURLSearchParams(query),\n      reason\n    }) : this.client.rest.post(endpoint, {\n      body: {\n        ...query,\n        compute_prune_count\n      },\n      reason\n    }));\n    return pruned;\n  }\n\n  /**\n   * Kicks a user from the guild.\n   * <info>The user must be a member of the guild</info>\n   * @param {UserResolvable} user The member to kick\n   * @param {string} [reason] Reason for kicking\n   * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.\n   * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot\n   * be resolved, the user's id will be the result.\n   * @example\n   * // Kick a user by id (or with a user/guild member object)\n   * guild.members.kick('84484653687267328')\n   *   .then(kickInfo => console.log(`Kicked ${kickInfo.user?.tag ?? kickInfo.tag ?? kickInfo}`))\n   *   .catch(console.error);\n   */\n  async kick(user, reason) {\n    const id = this.client.users.resolveId(user);\n    if (!id) return Promise.reject(new DiscordjsTypeError(ErrorCodes.InvalidType, 'user', 'UserResolvable'));\n    await this.client.rest.delete(Routes.guildMember(this.guild.id, id), {\n      reason\n    });\n    return this.resolve(user) ?? this.client.users.resolve(user) ?? id;\n  }\n\n  /**\n   * Bans a user from the guild.\n   * @param {UserResolvable} user The user to ban\n   * @param {BanOptions} [options] Options for the ban\n   * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.\n   * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot\n   * be resolved, the user id will be the result.\n   * Internally calls the GuildBanManager#create method.\n   * @example\n   * // Ban a user by id (or with a user/guild member object)\n   * guild.members.ban('84484653687267328')\n   *   .then(banInfo => console.log(`Banned ${banInfo.user?.tag ?? banInfo.tag ?? banInfo}`))\n   *   .catch(console.error);\n   */\n  ban(user, options) {\n    return this.guild.bans.create(user, options);\n  }\n\n  /**\n   * Unbans a user from the guild. Internally calls the {@link GuildBanManager#remove} method.\n   * @param {UserResolvable} user The user to unban\n   * @param {string} [reason] Reason for unbanning user\n   * @returns {Promise<?User>} The user that was unbanned\n   * @example\n   * // Unban a user by id (or with a user/guild member object)\n   * guild.members.unban('84484653687267328')\n   *   .then(user => console.log(`Unbanned ${user.username} from ${guild.name}`))\n   *   .catch(console.error);\n   */\n  unban(user, reason) {\n    return this.guild.bans.remove(user, reason);\n  }\n\n  /**\n   * Options used for adding or removing a role from a member.\n   * @typedef {Object} AddOrRemoveGuildMemberRoleOptions\n   * @property {GuildMemberResolvable} user The user to add/remove the role from\n   * @property {RoleResolvable} role The role to add/remove\n   * @property {string} [reason] Reason for adding/removing the role\n   */\n\n  /**\n   * Adds a role to a member.\n   * @param {AddOrRemoveGuildMemberRoleOptions} options Options for adding the role\n   * @returns {Promise<GuildMember|User|Snowflake>}\n   */\n  async addRole(options) {\n    const {\n      user,\n      role,\n      reason\n    } = options;\n    const userId = this.guild.members.resolveId(user);\n    const roleId = this.guild.roles.resolveId(role);\n    await this.client.rest.put(Routes.guildMemberRole(this.guild.id, userId, roleId), {\n      reason\n    });\n    return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;\n  }\n\n  /**\n   * Removes a role from a member.\n   * @param {AddOrRemoveGuildMemberRoleOptions} options Options for removing the role\n   * @returns {Promise<GuildMember|User|Snowflake>}\n   */\n  async removeRole(options) {\n    const {\n      user,\n      role,\n      reason\n    } = options;\n    const userId = this.guild.members.resolveId(user);\n    const roleId = this.guild.roles.resolveId(role);\n    await this.client.rest.delete(Routes.guildMemberRole(this.guild.id, userId, roleId), {\n      reason\n    });\n    return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;\n  }\n}\nmodule.exports = GuildMemberManager;","map":{"version":3,"names":["setTimeout","clearTimeout","require","Collection","makeURLSearchParams","DiscordSnowflake","Routes","GatewayOpcodes","CachedManager","DiscordjsError","DiscordjsTypeError","DiscordjsRangeError","ErrorCodes","BaseGuildVoiceChannel","GuildMember","Role","Events","GuildMemberFlagsBitField","Partials","GuildMemberManager","constructor","guild","iterable","client","_add","data","cache","id","user","extras","resolve","member","memberResolvable","userResolvable","users","resolveId","has","add","options","userId","InvalidType","force","cachedUser","get","resolvedOptions","access_token","accessToken","nick","mute","deaf","roles","Array","isArray","resolvedRoles","role","values","resolvedRole","InvalidElement","push","rest","put","guildMember","body","Uint8Array","fetchWhenExisting","fetch","me","partials","includes","_fetchMany","limit","withPresences","resolvedUser","_fetchSingle","resolvedUsers","map","undefined","existing","partial","presences","query","time","nonce","generate","toString","length","Promise","reject","MemberFetchNonceLength","shard","send","op","RequestGuildMembers","d","guild_id","user_ids","fetchedMembers","i","handler","members","_","chunk","timeout","refresh","set","size","count","removeListener","GuildMembersChunk","decrementMaxListeners","first","GuildMembersTimeout","unref","incrementMaxListeners","on","fetchMe","search","guildMembersSearch","reduce","col","list","after","guildMembers","edit","reason","channel","channels","GuildVoiceChannelResolve","channel_id","communicationDisabledUntil","communication_disabled_until","Date","toISOString","flags","endpoint","keys","Object","patch","clone","_clone","_patch","prune","days","dry","compute_prune_count","PruneDaysType","include_roles","join","guildPrune","pruned","post","kick","delete","ban","bans","create","unban","remove","addRole","roleId","guildMemberRole","removeRole","module","exports"],"sources":["C:/Users/hetit/node_modules/discord.js/src/managers/GuildMemberManager.js"],"sourcesContent":["'use strict';\n\nconst { setTimeout, clearTimeout } = require('node:timers');\nconst { Collection } = require('@discordjs/collection');\nconst { makeURLSearchParams } = require('@discordjs/rest');\nconst { DiscordSnowflake } = require('@sapphire/snowflake');\nconst { Routes, GatewayOpcodes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst { DiscordjsError, DiscordjsTypeError, DiscordjsRangeError, ErrorCodes } = require('../errors');\nconst BaseGuildVoiceChannel = require('../structures/BaseGuildVoiceChannel');\nconst { GuildMember } = require('../structures/GuildMember');\nconst { Role } = require('../structures/Role');\nconst Events = require('../util/Events');\nconst { GuildMemberFlagsBitField } = require('../util/GuildMemberFlagsBitField');\nconst Partials = require('../util/Partials');\n\n/**\n * Manages API methods for GuildMembers and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildMemberManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, GuildMember, iterable);\n\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, GuildMember>}\n   * @name GuildMemberManager#cache\n   */\n\n  _add(data, cache = true) {\n    return super._add(data, cache, { id: data.user.id, extras: [this.guild] });\n  }\n\n  /**\n   * Data that resolves to give a GuildMember object. This can be:\n   * * A GuildMember object\n   * * A User resolvable\n   * @typedef {GuildMember|UserResolvable} GuildMemberResolvable\n   */\n\n  /**\n   * Resolves a {@link GuildMemberResolvable} to a {@link GuildMember} object.\n   * @param {GuildMemberResolvable} member The user that is part of the guild\n   * @returns {?GuildMember}\n   */\n  resolve(member) {\n    const memberResolvable = super.resolve(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveId(member);\n    if (userResolvable) return super.resolve(userResolvable);\n    return null;\n  }\n\n  /**\n   * Resolves a {@link GuildMemberResolvable} to a member id.\n   * @param {GuildMemberResolvable} member The user that is part of the guild\n   * @returns {?Snowflake}\n   */\n  resolveId(member) {\n    const memberResolvable = super.resolveId(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveId(member);\n    return this.cache.has(userResolvable) ? userResolvable : null;\n  }\n\n  /**\n   * Options used to add a user to a guild using OAuth2.\n   * @typedef {Object} AddGuildMemberOptions\n   * @property {string} accessToken An OAuth2 access token for the user with the {@link OAuth2Scopes.GuildsJoin}\n   * scope granted to the bot's application\n   * @property {string} [nick] The nickname to give to the member\n   * <info>This property requires the {@link PermissionFlagsBits.ManageNicknames} permission.</info>\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles to add to the member\n   * <info>This property requires the {@link PermissionFlagsBits.ManageRoles} permission.</info>\n   * @property {boolean} [mute] Whether the member should be muted\n   * <info>This property requires the {@link PermissionFlagsBits.MuteMembers} permission.</info>\n   * @property {boolean} [deaf] Whether the member should be deafened\n   * <info>This property requires the {@link PermissionFlagsBits.MuteMembers} permission.</info>\n   * @property {boolean} [force] Whether to skip the cache check and request the API directly\n   * @property {boolean} [fetchWhenExisting=true] Whether to fetch the user if not cached and already a member\n   */\n\n  /**\n   * Adds a user to the guild using OAuth2.\n   * <info>This method requires the {@link PermissionFlagsBits.CreateInstantInvite} permission.\n   * @param {UserResolvable} user The user to add to the guild\n   * @param {AddGuildMemberOptions} options Options for adding the user to the guild\n   * @returns {Promise<GuildMember|null>}\n   */\n  async add(user, options) {\n    const userId = this.client.users.resolveId(user);\n    if (!userId) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'user', 'UserResolvable');\n    if (!options.force) {\n      const cachedUser = this.cache.get(userId);\n      if (cachedUser) return cachedUser;\n    }\n    const resolvedOptions = {\n      access_token: options.accessToken,\n      nick: options.nick,\n      mute: options.mute,\n      deaf: options.deaf,\n    };\n    if (options.roles) {\n      if (!Array.isArray(options.roles) && !(options.roles instanceof Collection)) {\n        throw new DiscordjsTypeError(\n          ErrorCodes.InvalidType,\n          'options.roles',\n          'Array or Collection of Roles or Snowflakes',\n          true,\n        );\n      }\n      const resolvedRoles = [];\n      for (const role of options.roles.values()) {\n        const resolvedRole = this.guild.roles.resolveId(role);\n        if (!resolvedRole) {\n          throw new DiscordjsTypeError(ErrorCodes.InvalidElement, 'Array or Collection', 'options.roles', role);\n        }\n        resolvedRoles.push(resolvedRole);\n      }\n      resolvedOptions.roles = resolvedRoles;\n    }\n    const data = await this.client.rest.put(Routes.guildMember(this.guild.id, userId), { body: resolvedOptions });\n    // Data is an empty Uint8Array if the member is already part of the guild.\n    return data instanceof Uint8Array\n      ? options.fetchWhenExisting === false\n        ? null\n        : this.fetch(userId)\n      : this._add(data);\n  }\n\n  /**\n   * The client user as a GuildMember of this guild\n   * @type {?GuildMember}\n   * @readonly\n   */\n  get me() {\n    return (\n      this.resolve(this.client.user.id) ??\n      (this.client.options.partials.includes(Partials.GuildMember)\n        ? this._add({ user: { id: this.client.user.id } }, true)\n        : null)\n    );\n  }\n\n  /**\n   * Options used to fetch a single member from a guild.\n   * @typedef {BaseFetchOptions} FetchMemberOptions\n   * @property {UserResolvable} user The user to fetch\n   */\n\n  /**\n   * Options used to fetch multiple members from a guild.\n   * @typedef {Object} FetchMembersOptions\n   * @property {UserResolvable|UserResolvable[]} [user] The user(s) to fetch\n   * @property {?string} [query] Limit fetch to members with similar usernames\n   * @property {number} [limit=0] Maximum number of members to request\n   * @property {boolean} [withPresences=false] Whether to include the presences\n   * @property {number} [time=120e3] Timeout for receipt of members\n   * @property {?string} [nonce] Nonce for this request (32 characters max - default to base 16 now timestamp)\n   */\n\n  /**\n   * Fetches member(s) from a guild.\n   * @param {UserResolvable|FetchMemberOptions|FetchMembersOptions} [options] Options for fetching member(s).\n   * Omitting the parameter or providing `undefined` will fetch all members.\n   * @returns {Promise<GuildMember|Collection<Snowflake, GuildMember>>}\n   * @example\n   * // Fetch all members from a guild\n   * guild.members.fetch()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single member\n   * guild.members.fetch('66564597481480192')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single member without checking cache\n   * guild.members.fetch({ user, force: true })\n   *   .then(console.log)\n   *   .catch(console.error)\n   * @example\n   * // Fetch a single member without caching\n   * guild.members.fetch({ user, cache: false })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch by an array of users including their presences\n   * guild.members.fetch({ user: ['66564597481480192', '191615925336670208'], withPresences: true })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch by query\n   * guild.members.fetch({ query: 'hydra', limit: 1 })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  fetch(options) {\n    if (!options) return this._fetchMany();\n    const { user: users, limit, withPresences, cache, force } = options;\n    const resolvedUser = this.client.users.resolveId(users ?? options);\n    if (resolvedUser && !limit && !withPresences) return this._fetchSingle({ user: resolvedUser, cache, force });\n    const resolvedUsers = users?.map?.(user => this.client.users.resolveId(user)) ?? resolvedUser ?? undefined;\n    return this._fetchMany({ ...options, users: resolvedUsers });\n  }\n\n  async _fetchSingle({ user, cache, force = false }) {\n    if (!force) {\n      const existing = this.cache.get(user);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.rest.get(Routes.guildMember(this.guild.id, user));\n    return this._add(data, cache);\n  }\n\n  _fetchMany({\n    limit = 0,\n    withPresences: presences,\n    users,\n    query,\n    time = 120e3,\n    nonce = DiscordSnowflake.generate().toString(),\n  } = {}) {\n    if (nonce.length > 32) return Promise.reject(new DiscordjsRangeError(ErrorCodes.MemberFetchNonceLength));\n\n    return new Promise((resolve, reject) => {\n      if (!query && !users) query = '';\n      this.guild.shard.send({\n        op: GatewayOpcodes.RequestGuildMembers,\n        d: {\n          guild_id: this.guild.id,\n          presences,\n          user_ids: users,\n          query,\n          nonce,\n          limit,\n        },\n      });\n      const fetchedMembers = new Collection();\n      let i = 0;\n      const handler = (members, _, chunk) => {\n        if (chunk.nonce !== nonce) return;\n        timeout.refresh();\n        i++;\n        for (const member of members.values()) {\n          fetchedMembers.set(member.id, member);\n        }\n        if (members.size < 1_000 || (limit && fetchedMembers.size >= limit) || i === chunk.count) {\n          clearTimeout(timeout);\n          this.client.removeListener(Events.GuildMembersChunk, handler);\n          this.client.decrementMaxListeners();\n          resolve(users && !Array.isArray(users) && fetchedMembers.size ? fetchedMembers.first() : fetchedMembers);\n        }\n      };\n      const timeout = setTimeout(() => {\n        this.client.removeListener(Events.GuildMembersChunk, handler);\n        this.client.decrementMaxListeners();\n        reject(new DiscordjsError(ErrorCodes.GuildMembersTimeout));\n      }, time).unref();\n      this.client.incrementMaxListeners();\n      this.client.on(Events.GuildMembersChunk, handler);\n    });\n  }\n\n  /**\n   * Fetches the client user as a GuildMember of the guild.\n   * @param {BaseFetchOptions} [options] The options for fetching the member\n   * @returns {Promise<GuildMember>}\n   */\n  fetchMe(options) {\n    return this.fetch({ ...options, user: this.client.user.id });\n  }\n\n  /**\n   * Options used for searching guild members.\n   * @typedef {Object} GuildSearchMembersOptions\n   * @property {string} query Filter members whose username or nickname start with this query\n   * @property {number} [limit] Maximum number of members to search\n   * @property {boolean} [cache=true] Whether or not to cache the fetched member(s)\n   */\n\n  /**\n   * Searches for members in the guild based on a query.\n   * @param {GuildSearchMembersOptions} options Options for searching members\n   * @returns {Promise<Collection<Snowflake, GuildMember>>}\n   */\n  async search({ query, limit, cache = true } = {}) {\n    const data = await this.client.rest.get(Routes.guildMembersSearch(this.guild.id), {\n      query: makeURLSearchParams({ query, limit }),\n    });\n    return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection());\n  }\n\n  /**\n   * Options used for listing guild members.\n   * @typedef {Object} GuildListMembersOptions\n   * @property {Snowflake} [after] Limit fetching members to those with an id greater than the supplied id\n   * @property {number} [limit] Maximum number of members to list\n   * @property {boolean} [cache=true] Whether or not to cache the fetched member(s)\n   */\n\n  /**\n   * Lists up to 1000 members of the guild.\n   * @param {GuildListMembersOptions} [options] Options for listing members\n   * @returns {Promise<Collection<Snowflake, GuildMember>>}\n   */\n  async list({ after, limit, cache = true } = {}) {\n    const query = makeURLSearchParams({ limit, after });\n    const data = await this.client.rest.get(Routes.guildMembers(this.guild.id), { query });\n    return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection());\n  }\n\n  /**\n   * The data for editing a guild member.\n   * @typedef {Object} GuildMemberEditOptions\n   * @property {?string} [nick] The nickname to set for the member\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles or role ids to apply\n   * @property {boolean} [mute] Whether or not the member should be muted\n   * @property {boolean} [deaf] Whether or not the member should be deafened\n   * @property {GuildVoiceChannelResolvable|null} [channel] Channel to move the member to\n   * (if they are connected to voice), or `null` if you want to disconnect them from voice\n   * @property {DateResolvable|null} [communicationDisabledUntil] The date or timestamp\n   * for the member's communication to be disabled until. Provide `null` to enable communication again.\n   * @property {GuildMemberFlagsResolvable} [flags] The flags to set for the member\n   * @property {string} [reason] Reason for editing this user\n   */\n\n  /**\n   * Edits a member of the guild.\n   * <info>The user must be a member of the guild</info>\n   * @param {UserResolvable} user The member to edit\n   * @param {GuildMemberEditOptions} options The options to provide\n   * @returns {Promise<GuildMember>}\n   */\n  async edit(user, { reason, ...options }) {\n    const id = this.client.users.resolveId(user);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'user', 'UserResolvable');\n\n    if (options.channel) {\n      options.channel = this.guild.channels.resolve(options.channel);\n      if (!(options.channel instanceof BaseGuildVoiceChannel)) {\n        throw new DiscordjsError(ErrorCodes.GuildVoiceChannelResolve);\n      }\n      options.channel_id = options.channel.id;\n      options.channel = undefined;\n    } else if (options.channel === null) {\n      options.channel_id = null;\n      options.channel = undefined;\n    }\n    options.roles &&= options.roles.map(role => (role instanceof Role ? role.id : role));\n\n    if (options.communicationDisabledUntil !== undefined) {\n      options.communication_disabled_until =\n        // eslint-disable-next-line eqeqeq\n        options.communicationDisabledUntil != null\n          ? new Date(options.communicationDisabledUntil).toISOString()\n          : options.communicationDisabledUntil;\n    }\n\n    if (options.flags !== undefined) {\n      options.flags = GuildMemberFlagsBitField.resolve(options.flags);\n    }\n\n    let endpoint;\n    if (id === this.client.user.id) {\n      const keys = Object.keys(options);\n      if (keys.length === 1 && keys[0] === 'nick') endpoint = Routes.guildMember(this.guild.id);\n      else endpoint = Routes.guildMember(this.guild.id, id);\n    } else {\n      endpoint = Routes.guildMember(this.guild.id, id);\n    }\n    const d = await this.client.rest.patch(endpoint, { body: options, reason });\n\n    const clone = this.cache.get(id)?._clone();\n    clone?._patch(d);\n    return clone ?? this._add(d, false);\n  }\n\n  /**\n   * Options used for pruning guild members.\n   * <info>It's recommended to set {@link GuildPruneMembersOptions#count options.count}\n   * to `false` for large guilds.</info>\n   * @typedef {Object} GuildPruneMembersOptions\n   * @property {number} [days] Number of days of inactivity required to kick\n   * @property {boolean} [dry=false] Get the number of users that will be kicked, without actually kicking them\n   * @property {boolean} [count] Whether or not to return the number of users that have been kicked.\n   * @property {RoleResolvable[]} [roles] Array of roles to bypass the \"...and no roles\" constraint when pruning\n   * @property {string} [reason] Reason for this prune\n   */\n\n  /**\n   * Prunes members from the guild based on how long they have been inactive.\n   * @param {GuildPruneMembersOptions} [options] Options for pruning\n   * @returns {Promise<number|null>} The number of members that were/will be kicked\n   * @example\n   * // See how many members will be pruned\n   * guild.members.prune({ dry: true })\n   *   .then(pruned => console.log(`This will prune ${pruned} people!`))\n   *   .catch(console.error);\n   * @example\n   * // Actually prune the members\n   * guild.members.prune({ days: 1, reason: 'too many people!' })\n   *   .then(pruned => console.log(`I just pruned ${pruned} people!`))\n   *   .catch(console.error);\n   * @example\n   * // Include members with a specified role\n   * guild.members.prune({ days: 7, roles: ['657259391652855808'] })\n   *    .then(pruned => console.log(`I just pruned ${pruned} people!`))\n   *    .catch(console.error);\n   */\n  async prune({ days, dry = false, count: compute_prune_count, roles = [], reason } = {}) {\n    if (typeof days !== 'number') throw new DiscordjsTypeError(ErrorCodes.PruneDaysType);\n\n    const query = { days };\n    const resolvedRoles = [];\n\n    for (const role of roles) {\n      const resolvedRole = this.guild.roles.resolveId(role);\n      if (!resolvedRole) {\n        throw new DiscordjsTypeError(ErrorCodes.InvalidElement, 'Array', 'options.roles', role);\n      }\n      resolvedRoles.push(resolvedRole);\n    }\n\n    if (resolvedRoles.length) {\n      query.include_roles = dry ? resolvedRoles.join(',') : resolvedRoles;\n    }\n\n    const endpoint = Routes.guildPrune(this.guild.id);\n\n    const { pruned } = await (dry\n      ? this.client.rest.get(endpoint, { query: makeURLSearchParams(query), reason })\n      : this.client.rest.post(endpoint, { body: { ...query, compute_prune_count }, reason }));\n\n    return pruned;\n  }\n\n  /**\n   * Kicks a user from the guild.\n   * <info>The user must be a member of the guild</info>\n   * @param {UserResolvable} user The member to kick\n   * @param {string} [reason] Reason for kicking\n   * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.\n   * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot\n   * be resolved, the user's id will be the result.\n   * @example\n   * // Kick a user by id (or with a user/guild member object)\n   * guild.members.kick('84484653687267328')\n   *   .then(kickInfo => console.log(`Kicked ${kickInfo.user?.tag ?? kickInfo.tag ?? kickInfo}`))\n   *   .catch(console.error);\n   */\n  async kick(user, reason) {\n    const id = this.client.users.resolveId(user);\n    if (!id) return Promise.reject(new DiscordjsTypeError(ErrorCodes.InvalidType, 'user', 'UserResolvable'));\n\n    await this.client.rest.delete(Routes.guildMember(this.guild.id, id), { reason });\n\n    return this.resolve(user) ?? this.client.users.resolve(user) ?? id;\n  }\n\n  /**\n   * Bans a user from the guild.\n   * @param {UserResolvable} user The user to ban\n   * @param {BanOptions} [options] Options for the ban\n   * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.\n   * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot\n   * be resolved, the user id will be the result.\n   * Internally calls the GuildBanManager#create method.\n   * @example\n   * // Ban a user by id (or with a user/guild member object)\n   * guild.members.ban('84484653687267328')\n   *   .then(banInfo => console.log(`Banned ${banInfo.user?.tag ?? banInfo.tag ?? banInfo}`))\n   *   .catch(console.error);\n   */\n  ban(user, options) {\n    return this.guild.bans.create(user, options);\n  }\n\n  /**\n   * Unbans a user from the guild. Internally calls the {@link GuildBanManager#remove} method.\n   * @param {UserResolvable} user The user to unban\n   * @param {string} [reason] Reason for unbanning user\n   * @returns {Promise<?User>} The user that was unbanned\n   * @example\n   * // Unban a user by id (or with a user/guild member object)\n   * guild.members.unban('84484653687267328')\n   *   .then(user => console.log(`Unbanned ${user.username} from ${guild.name}`))\n   *   .catch(console.error);\n   */\n  unban(user, reason) {\n    return this.guild.bans.remove(user, reason);\n  }\n\n  /**\n   * Options used for adding or removing a role from a member.\n   * @typedef {Object} AddOrRemoveGuildMemberRoleOptions\n   * @property {GuildMemberResolvable} user The user to add/remove the role from\n   * @property {RoleResolvable} role The role to add/remove\n   * @property {string} [reason] Reason for adding/removing the role\n   */\n\n  /**\n   * Adds a role to a member.\n   * @param {AddOrRemoveGuildMemberRoleOptions} options Options for adding the role\n   * @returns {Promise<GuildMember|User|Snowflake>}\n   */\n  async addRole(options) {\n    const { user, role, reason } = options;\n    const userId = this.guild.members.resolveId(user);\n    const roleId = this.guild.roles.resolveId(role);\n    await this.client.rest.put(Routes.guildMemberRole(this.guild.id, userId, roleId), { reason });\n\n    return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;\n  }\n\n  /**\n   * Removes a role from a member.\n   * @param {AddOrRemoveGuildMemberRoleOptions} options Options for removing the role\n   * @returns {Promise<GuildMember|User|Snowflake>}\n   */\n  async removeRole(options) {\n    const { user, role, reason } = options;\n    const userId = this.guild.members.resolveId(user);\n    const roleId = this.guild.roles.resolveId(role);\n    await this.client.rest.delete(Routes.guildMemberRole(this.guild.id, userId, roleId), { reason });\n\n    return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;\n  }\n}\n\nmodule.exports = GuildMemberManager;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}