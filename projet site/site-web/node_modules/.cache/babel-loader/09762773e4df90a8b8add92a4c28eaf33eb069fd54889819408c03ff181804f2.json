{"ast":null,"code":"'use strict';\n\nconst process = require('node:process');\nconst {\n  Routes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst {\n  BaseChannel\n} = require('../structures/BaseChannel');\nconst {\n  createChannel\n} = require('../util/Channels');\nconst {\n  ThreadChannelTypes\n} = require('../util/Constants');\nconst Events = require('../util/Events');\nlet cacheWarningEmitted = false;\n\n/**\n * A manager of channels belonging to a client\n * @extends {CachedManager}\n */\nclass ChannelManager extends CachedManager {\n  constructor(client, iterable) {\n    super(client, BaseChannel, iterable);\n    const defaultCaching = this._cache.constructor.name === 'Collection' || this._cache.maxSize === undefined || this._cache.maxSize === Infinity;\n    if (!cacheWarningEmitted && !defaultCaching) {\n      cacheWarningEmitted = true;\n      process.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, 'UnsupportedCacheOverwriteWarning');\n    }\n  }\n\n  /**\n   * The cache of Channels\n   * @type {Collection<Snowflake, BaseChannel>}\n   * @name ChannelManager#cache\n   */\n\n  _add(data, guild, {\n    cache = true,\n    allowUnknownGuild = false\n  } = {}) {\n    const existing = this.cache.get(data.id);\n    if (existing) {\n      if (cache) existing._patch(data);\n      guild?.channels?._add(existing);\n      if (ThreadChannelTypes.includes(existing.type)) {\n        existing.parent?.threads?._add(existing);\n      }\n      return existing;\n    }\n    const channel = createChannel(this.client, data, guild, {\n      allowUnknownGuild\n    });\n    if (!channel) {\n      this.client.emit(Events.Debug, `Failed to find guild, or unknown type for channel ${data.id} ${data.type}`);\n      return null;\n    }\n    if (cache && !allowUnknownGuild) this.cache.set(channel.id, channel);\n    return channel;\n  }\n  _remove(id) {\n    const channel = this.cache.get(id);\n    channel?.guild?.channels.cache.delete(id);\n    for (const [code, invite] of channel?.guild?.invites.cache ?? []) {\n      if (invite.channelId === id) channel.guild.invites.cache.delete(code);\n    }\n    channel?.parent?.threads?.cache.delete(id);\n    this.cache.delete(id);\n  }\n\n  /**\n   * Data that can be resolved to give a Channel object. This can be:\n   * * A Channel object\n   * * A Snowflake\n   * @typedef {BaseChannel|Snowflake} ChannelResolvable\n   */\n\n  /**\n   * Resolves a ChannelResolvable to a Channel object.\n   * @method resolve\n   * @memberof ChannelManager\n   * @instance\n   * @param {ChannelResolvable} channel The channel resolvable to resolve\n   * @returns {?BaseChannel}\n   */\n\n  /**\n   * Resolves a ChannelResolvable to a channel id string.\n   * @method resolveId\n   * @memberof ChannelManager\n   * @instance\n   * @param {ChannelResolvable} channel The channel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Options for fetching a channel from Discord\n   * @typedef {BaseFetchOptions} FetchChannelOptions\n   * @property {boolean} [allowUnknownGuild=false] Allows the channel to be returned even if the guild is not in cache,\n   * it will not be cached. <warn>Many of the properties and methods on the returned channel will throw errors</warn>\n   */\n\n  /**\n   * Obtains a channel from Discord, or the channel cache if it's already available.\n   * @param {Snowflake} id The channel's id\n   * @param {FetchChannelOptions} [options] Additional options for this fetch\n   * @returns {Promise<?BaseChannel>}\n   * @example\n   * // Fetch a channel by its id\n   * client.channels.fetch('222109930545610754')\n   *   .then(channel => console.log(channel.name))\n   *   .catch(console.error);\n   */\n  async fetch(id, {\n    allowUnknownGuild = false,\n    cache = true,\n    force = false\n  } = {}) {\n    if (!force) {\n      const existing = this.cache.get(id);\n      if (existing && !existing.partial) return existing;\n    }\n    const data = await this.client.rest.get(Routes.channel(id));\n    return this._add(data, null, {\n      cache,\n      allowUnknownGuild\n    });\n  }\n}\nmodule.exports = ChannelManager;","map":{"version":3,"names":["process","require","Routes","CachedManager","BaseChannel","createChannel","ThreadChannelTypes","Events","cacheWarningEmitted","ChannelManager","constructor","client","iterable","defaultCaching","_cache","name","maxSize","undefined","Infinity","emitWarning","_add","data","guild","cache","allowUnknownGuild","existing","get","id","_patch","channels","includes","type","parent","threads","channel","emit","Debug","set","_remove","delete","code","invite","invites","channelId","fetch","force","partial","rest","module","exports"],"sources":["C:/Users/hetit/node_modules/discord.js/src/managers/ChannelManager.js"],"sourcesContent":["'use strict';\n\nconst process = require('node:process');\nconst { Routes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst { BaseChannel } = require('../structures/BaseChannel');\nconst { createChannel } = require('../util/Channels');\nconst { ThreadChannelTypes } = require('../util/Constants');\nconst Events = require('../util/Events');\n\nlet cacheWarningEmitted = false;\n\n/**\n * A manager of channels belonging to a client\n * @extends {CachedManager}\n */\nclass ChannelManager extends CachedManager {\n  constructor(client, iterable) {\n    super(client, BaseChannel, iterable);\n    const defaultCaching =\n      this._cache.constructor.name === 'Collection' ||\n      this._cache.maxSize === undefined ||\n      this._cache.maxSize === Infinity;\n    if (!cacheWarningEmitted && !defaultCaching) {\n      cacheWarningEmitted = true;\n      process.emitWarning(\n        `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,\n        'UnsupportedCacheOverwriteWarning',\n      );\n    }\n  }\n\n  /**\n   * The cache of Channels\n   * @type {Collection<Snowflake, BaseChannel>}\n   * @name ChannelManager#cache\n   */\n\n  _add(data, guild, { cache = true, allowUnknownGuild = false } = {}) {\n    const existing = this.cache.get(data.id);\n    if (existing) {\n      if (cache) existing._patch(data);\n      guild?.channels?._add(existing);\n      if (ThreadChannelTypes.includes(existing.type)) {\n        existing.parent?.threads?._add(existing);\n      }\n      return existing;\n    }\n\n    const channel = createChannel(this.client, data, guild, { allowUnknownGuild });\n\n    if (!channel) {\n      this.client.emit(Events.Debug, `Failed to find guild, or unknown type for channel ${data.id} ${data.type}`);\n      return null;\n    }\n\n    if (cache && !allowUnknownGuild) this.cache.set(channel.id, channel);\n\n    return channel;\n  }\n\n  _remove(id) {\n    const channel = this.cache.get(id);\n    channel?.guild?.channels.cache.delete(id);\n\n    for (const [code, invite] of channel?.guild?.invites.cache ?? []) {\n      if (invite.channelId === id) channel.guild.invites.cache.delete(code);\n    }\n\n    channel?.parent?.threads?.cache.delete(id);\n    this.cache.delete(id);\n  }\n\n  /**\n   * Data that can be resolved to give a Channel object. This can be:\n   * * A Channel object\n   * * A Snowflake\n   * @typedef {BaseChannel|Snowflake} ChannelResolvable\n   */\n\n  /**\n   * Resolves a ChannelResolvable to a Channel object.\n   * @method resolve\n   * @memberof ChannelManager\n   * @instance\n   * @param {ChannelResolvable} channel The channel resolvable to resolve\n   * @returns {?BaseChannel}\n   */\n\n  /**\n   * Resolves a ChannelResolvable to a channel id string.\n   * @method resolveId\n   * @memberof ChannelManager\n   * @instance\n   * @param {ChannelResolvable} channel The channel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Options for fetching a channel from Discord\n   * @typedef {BaseFetchOptions} FetchChannelOptions\n   * @property {boolean} [allowUnknownGuild=false] Allows the channel to be returned even if the guild is not in cache,\n   * it will not be cached. <warn>Many of the properties and methods on the returned channel will throw errors</warn>\n   */\n\n  /**\n   * Obtains a channel from Discord, or the channel cache if it's already available.\n   * @param {Snowflake} id The channel's id\n   * @param {FetchChannelOptions} [options] Additional options for this fetch\n   * @returns {Promise<?BaseChannel>}\n   * @example\n   * // Fetch a channel by its id\n   * client.channels.fetch('222109930545610754')\n   *   .then(channel => console.log(channel.name))\n   *   .catch(console.error);\n   */\n  async fetch(id, { allowUnknownGuild = false, cache = true, force = false } = {}) {\n    if (!force) {\n      const existing = this.cache.get(id);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.rest.get(Routes.channel(id));\n    return this._add(data, null, { cache, allowUnknownGuild });\n  }\n}\n\nmodule.exports = ChannelManager;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}