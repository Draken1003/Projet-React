{"ast":null,"code":"'use strict';\n\nconst process = require('node:process');\nconst {\n  calculateShardId\n} = require('@discordjs/util');\nconst {\n  DiscordjsError,\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../errors');\nconst Events = require('../util/Events');\nconst {\n  makeError,\n  makePlainError\n} = require('../util/Util');\n\n/**\n * Helper class for sharded clients spawned as a child process/worker, such as from a {@link ShardingManager}.\n * Utilises IPC to send and receive data to/from the master process and other shards.\n */\nclass ShardClientUtil {\n  constructor(client, mode) {\n    /**\n     * Client for the shard\n     * @type {Client}\n     */\n    this.client = client;\n\n    /**\n     * Mode the shard was spawned with\n     * @type {ShardingManagerMode}\n     */\n    this.mode = mode;\n\n    /**\n     * Message port for the master process (only when {@link ShardClientUtil#mode} is `worker`)\n     * @type {?MessagePort}\n     */\n    this.parentPort = null;\n    switch (mode) {\n      case 'process':\n        process.on('message', this._handleMessage.bind(this));\n        client.on(Events.ShardReady, () => {\n          process.send({\n            _ready: true\n          });\n        });\n        client.on(Events.ShardDisconnect, () => {\n          process.send({\n            _disconnect: true\n          });\n        });\n        client.on(Events.ShardReconnecting, () => {\n          process.send({\n            _reconnecting: true\n          });\n        });\n        client.on(Events.ShardResume, () => {\n          process.send({\n            _resume: true\n          });\n        });\n        break;\n      case 'worker':\n        this.parentPort = require('node:worker_threads').parentPort;\n        this.parentPort.on('message', this._handleMessage.bind(this));\n        client.on(Events.ShardReady, () => {\n          this.parentPort.postMessage({\n            _ready: true\n          });\n        });\n        client.on(Events.ShardDisconnect, () => {\n          this.parentPort.postMessage({\n            _disconnect: true\n          });\n        });\n        client.on(Events.ShardReconnecting, () => {\n          this.parentPort.postMessage({\n            _reconnecting: true\n          });\n        });\n        client.on(Events.ShardResume, () => {\n          this.parentPort.postMessage({\n            _resume: true\n          });\n        });\n        break;\n    }\n  }\n\n  /**\n   * Array of shard ids of this client\n   * @type {number[]}\n   * @readonly\n   */\n  get ids() {\n    return this.client.options.shards;\n  }\n\n  /**\n   * Total number of shards\n   * @type {number}\n   * @readonly\n   */\n  get count() {\n    return this.client.options.shardCount;\n  }\n\n  /**\n   * Sends a message to the master process.\n   * @param {*} message Message to send\n   * @returns {Promise<void>}\n   * @emits Shard#message\n   */\n  send(message) {\n    return new Promise((resolve, reject) => {\n      switch (this.mode) {\n        case 'process':\n          process.send(message, err => {\n            if (err) reject(err);else resolve();\n          });\n          break;\n        case 'worker':\n          this.parentPort.postMessage(message);\n          resolve();\n          break;\n      }\n    });\n  }\n\n  /**\n   * Fetches a client property value of each shard, or a given shard.\n   * @param {string} prop Name of the client property to get, using periods for nesting\n   * @param {number} [shard] Shard to fetch property from, all if undefined\n   * @returns {Promise<*|Array<*>>}\n   * @example\n   * client.shard.fetchClientValues('guilds.cache.size')\n   *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))\n   *   .catch(console.error);\n   * @see {@link ShardingManager#fetchClientValues}\n   */\n  fetchClientValues(prop, shard) {\n    return new Promise((resolve, reject) => {\n      const parent = this.parentPort ?? process;\n      const listener = message => {\n        if (message?._sFetchProp !== prop || message._sFetchPropShard !== shard) return;\n        parent.removeListener('message', listener);\n        this.decrementMaxListeners(parent);\n        if (!message._error) resolve(message._result);else reject(makeError(message._error));\n      };\n      this.incrementMaxListeners(parent);\n      parent.on('message', listener);\n      this.send({\n        _sFetchProp: prop,\n        _sFetchPropShard: shard\n      }).catch(err => {\n        parent.removeListener('message', listener);\n        this.decrementMaxListeners(parent);\n        reject(err);\n      });\n    });\n  }\n\n  /**\n   * Evaluates a script or function on all shards, or a given shard, in the context of the {@link Client}s.\n   * @param {Function} script JavaScript to run on each shard\n   * @param {BroadcastEvalOptions} [options={}] The options for the broadcast\n   * @returns {Promise<*|Array<*>>} Results of the script execution\n   * @example\n   * client.shard.broadcastEval(client => client.guilds.cache.size)\n   *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))\n   *   .catch(console.error);\n   * @see {@link ShardingManager#broadcastEval}\n   */\n  broadcastEval(script, options = {}) {\n    return new Promise((resolve, reject) => {\n      const parent = this.parentPort ?? process;\n      if (typeof script !== 'function') {\n        reject(new DiscordjsTypeError(ErrorCodes.ShardingInvalidEvalBroadcast));\n        return;\n      }\n      script = `(${script})(this, ${JSON.stringify(options.context)})`;\n      const listener = message => {\n        if (message?._sEval !== script || message._sEvalShard !== options.shard) return;\n        parent.removeListener('message', listener);\n        this.decrementMaxListeners(parent);\n        if (!message._error) resolve(message._result);else reject(makeError(message._error));\n      };\n      this.incrementMaxListeners(parent);\n      parent.on('message', listener);\n      this.send({\n        _sEval: script,\n        _sEvalShard: options.shard\n      }).catch(err => {\n        parent.removeListener('message', listener);\n        this.decrementMaxListeners(parent);\n        reject(err);\n      });\n    });\n  }\n\n  /**\n   * Requests a respawn of all shards.\n   * @param {MultipleShardRespawnOptions} [options] Options for respawning shards\n   * @returns {Promise<void>} Resolves upon the message being sent\n   * @see {@link ShardingManager#respawnAll}\n   */\n  respawnAll({\n    shardDelay = 5_000,\n    respawnDelay = 500,\n    timeout = 30_000\n  } = {}) {\n    return this.send({\n      _sRespawnAll: {\n        shardDelay,\n        respawnDelay,\n        timeout\n      }\n    });\n  }\n\n  /**\n   * Handles an IPC message.\n   * @param {*} message Message received\n   * @private\n   */\n  async _handleMessage(message) {\n    if (!message) return;\n    if (message._fetchProp) {\n      try {\n        const props = message._fetchProp.split('.');\n        let value = this.client;\n        for (const prop of props) value = value[prop];\n        this._respond('fetchProp', {\n          _fetchProp: message._fetchProp,\n          _result: value\n        });\n      } catch (err) {\n        this._respond('fetchProp', {\n          _fetchProp: message._fetchProp,\n          _error: makePlainError(err)\n        });\n      }\n    } else if (message._eval) {\n      try {\n        this._respond('eval', {\n          _eval: message._eval,\n          _result: await this.client._eval(message._eval)\n        });\n      } catch (err) {\n        this._respond('eval', {\n          _eval: message._eval,\n          _error: makePlainError(err)\n        });\n      }\n    }\n  }\n\n  /**\n   * Sends a message to the master process, emitting an error from the client upon failure.\n   * @param {string} type Type of response to send\n   * @param {*} message Message to send\n   * @private\n   */\n  _respond(type, message) {\n    this.send(message).catch(err => {\n      const error = new Error(`Error when sending ${type} response to master process: ${err.message}`);\n      error.stack = err.stack;\n      /**\n       * Emitted when the client encounters an error.\n       * <warn>Errors thrown within this event do not have a catch handler, it is\n       * recommended to not use async functions as `error` event handlers. See the\n       * [Node.js docs](https://nodejs.org/api/events.html#capture-rejections-of-promises) for details.</warn>\n       * @event Client#error\n       * @param {Error} error The error encountered\n       */\n      this.client.emit(Events.Error, error);\n    });\n  }\n\n  /**\n   * Creates/gets the singleton of this class.\n   * @param {Client} client The client to use\n   * @param {ShardingManagerMode} mode Mode the shard was spawned with\n   * @returns {ShardClientUtil}\n   */\n  static singleton(client, mode) {\n    if (!this._singleton) {\n      this._singleton = new this(client, mode);\n    } else {\n      client.emit(Events.Warn, 'Multiple clients created in child process/worker; only the first will handle sharding helpers.');\n    }\n    return this._singleton;\n  }\n\n  /**\n   * Get the shard id for a given guild id.\n   * @param {Snowflake} guildId Snowflake guild id to get shard id for\n   * @param {number} shardCount Number of shards\n   * @returns {number}\n   */\n  static shardIdForGuildId(guildId, shardCount) {\n    const shard = calculateShardId(guildId, shardCount);\n    if (shard < 0) throw new DiscordjsError(ErrorCodes.ShardingShardMiscalculation, shard, guildId, shardCount);\n    return shard;\n  }\n\n  /**\n   * Increments max listeners by one for a given emitter, if they are not zero.\n   * @param {EventEmitter|process} emitter The emitter that emits the events.\n   * @private\n   */\n  incrementMaxListeners(emitter) {\n    const maxListeners = emitter.getMaxListeners();\n    if (maxListeners !== 0) {\n      emitter.setMaxListeners(maxListeners + 1);\n    }\n  }\n\n  /**\n   * Decrements max listeners by one for a given emitter, if they are not zero.\n   * @param {EventEmitter|process} emitter The emitter that emits the events.\n   * @private\n   */\n  decrementMaxListeners(emitter) {\n    const maxListeners = emitter.getMaxListeners();\n    if (maxListeners !== 0) {\n      emitter.setMaxListeners(maxListeners - 1);\n    }\n  }\n}\nmodule.exports = ShardClientUtil;","map":{"version":3,"names":["process","require","calculateShardId","DiscordjsError","DiscordjsTypeError","ErrorCodes","Events","makeError","makePlainError","ShardClientUtil","constructor","client","mode","parentPort","on","_handleMessage","bind","ShardReady","send","_ready","ShardDisconnect","_disconnect","ShardReconnecting","_reconnecting","ShardResume","_resume","postMessage","ids","options","shards","count","shardCount","message","Promise","resolve","reject","err","fetchClientValues","prop","shard","parent","listener","_sFetchProp","_sFetchPropShard","removeListener","decrementMaxListeners","_error","_result","incrementMaxListeners","catch","broadcastEval","script","ShardingInvalidEvalBroadcast","JSON","stringify","context","_sEval","_sEvalShard","respawnAll","shardDelay","respawnDelay","timeout","_sRespawnAll","_fetchProp","props","split","value","_respond","_eval","type","error","Error","stack","emit","singleton","_singleton","Warn","shardIdForGuildId","guildId","ShardingShardMiscalculation","emitter","maxListeners","getMaxListeners","setMaxListeners","module","exports"],"sources":["C:/Users/hetit/node_modules/discord.js/src/sharding/ShardClientUtil.js"],"sourcesContent":["'use strict';\n\nconst process = require('node:process');\nconst { calculateShardId } = require('@discordjs/util');\nconst { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require('../errors');\nconst Events = require('../util/Events');\nconst { makeError, makePlainError } = require('../util/Util');\n\n/**\n * Helper class for sharded clients spawned as a child process/worker, such as from a {@link ShardingManager}.\n * Utilises IPC to send and receive data to/from the master process and other shards.\n */\nclass ShardClientUtil {\n  constructor(client, mode) {\n    /**\n     * Client for the shard\n     * @type {Client}\n     */\n    this.client = client;\n\n    /**\n     * Mode the shard was spawned with\n     * @type {ShardingManagerMode}\n     */\n    this.mode = mode;\n\n    /**\n     * Message port for the master process (only when {@link ShardClientUtil#mode} is `worker`)\n     * @type {?MessagePort}\n     */\n    this.parentPort = null;\n\n    switch (mode) {\n      case 'process':\n        process.on('message', this._handleMessage.bind(this));\n        client.on(Events.ShardReady, () => {\n          process.send({ _ready: true });\n        });\n        client.on(Events.ShardDisconnect, () => {\n          process.send({ _disconnect: true });\n        });\n        client.on(Events.ShardReconnecting, () => {\n          process.send({ _reconnecting: true });\n        });\n        client.on(Events.ShardResume, () => {\n          process.send({ _resume: true });\n        });\n        break;\n      case 'worker':\n        this.parentPort = require('node:worker_threads').parentPort;\n        this.parentPort.on('message', this._handleMessage.bind(this));\n        client.on(Events.ShardReady, () => {\n          this.parentPort.postMessage({ _ready: true });\n        });\n        client.on(Events.ShardDisconnect, () => {\n          this.parentPort.postMessage({ _disconnect: true });\n        });\n        client.on(Events.ShardReconnecting, () => {\n          this.parentPort.postMessage({ _reconnecting: true });\n        });\n        client.on(Events.ShardResume, () => {\n          this.parentPort.postMessage({ _resume: true });\n        });\n        break;\n    }\n  }\n\n  /**\n   * Array of shard ids of this client\n   * @type {number[]}\n   * @readonly\n   */\n  get ids() {\n    return this.client.options.shards;\n  }\n\n  /**\n   * Total number of shards\n   * @type {number}\n   * @readonly\n   */\n  get count() {\n    return this.client.options.shardCount;\n  }\n\n  /**\n   * Sends a message to the master process.\n   * @param {*} message Message to send\n   * @returns {Promise<void>}\n   * @emits Shard#message\n   */\n  send(message) {\n    return new Promise((resolve, reject) => {\n      switch (this.mode) {\n        case 'process':\n          process.send(message, err => {\n            if (err) reject(err);\n            else resolve();\n          });\n          break;\n        case 'worker':\n          this.parentPort.postMessage(message);\n          resolve();\n          break;\n      }\n    });\n  }\n\n  /**\n   * Fetches a client property value of each shard, or a given shard.\n   * @param {string} prop Name of the client property to get, using periods for nesting\n   * @param {number} [shard] Shard to fetch property from, all if undefined\n   * @returns {Promise<*|Array<*>>}\n   * @example\n   * client.shard.fetchClientValues('guilds.cache.size')\n   *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))\n   *   .catch(console.error);\n   * @see {@link ShardingManager#fetchClientValues}\n   */\n  fetchClientValues(prop, shard) {\n    return new Promise((resolve, reject) => {\n      const parent = this.parentPort ?? process;\n\n      const listener = message => {\n        if (message?._sFetchProp !== prop || message._sFetchPropShard !== shard) return;\n        parent.removeListener('message', listener);\n        this.decrementMaxListeners(parent);\n        if (!message._error) resolve(message._result);\n        else reject(makeError(message._error));\n      };\n      this.incrementMaxListeners(parent);\n      parent.on('message', listener);\n\n      this.send({ _sFetchProp: prop, _sFetchPropShard: shard }).catch(err => {\n        parent.removeListener('message', listener);\n        this.decrementMaxListeners(parent);\n        reject(err);\n      });\n    });\n  }\n\n  /**\n   * Evaluates a script or function on all shards, or a given shard, in the context of the {@link Client}s.\n   * @param {Function} script JavaScript to run on each shard\n   * @param {BroadcastEvalOptions} [options={}] The options for the broadcast\n   * @returns {Promise<*|Array<*>>} Results of the script execution\n   * @example\n   * client.shard.broadcastEval(client => client.guilds.cache.size)\n   *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))\n   *   .catch(console.error);\n   * @see {@link ShardingManager#broadcastEval}\n   */\n  broadcastEval(script, options = {}) {\n    return new Promise((resolve, reject) => {\n      const parent = this.parentPort ?? process;\n      if (typeof script !== 'function') {\n        reject(new DiscordjsTypeError(ErrorCodes.ShardingInvalidEvalBroadcast));\n        return;\n      }\n      script = `(${script})(this, ${JSON.stringify(options.context)})`;\n\n      const listener = message => {\n        if (message?._sEval !== script || message._sEvalShard !== options.shard) return;\n        parent.removeListener('message', listener);\n        this.decrementMaxListeners(parent);\n        if (!message._error) resolve(message._result);\n        else reject(makeError(message._error));\n      };\n      this.incrementMaxListeners(parent);\n      parent.on('message', listener);\n      this.send({ _sEval: script, _sEvalShard: options.shard }).catch(err => {\n        parent.removeListener('message', listener);\n        this.decrementMaxListeners(parent);\n        reject(err);\n      });\n    });\n  }\n\n  /**\n   * Requests a respawn of all shards.\n   * @param {MultipleShardRespawnOptions} [options] Options for respawning shards\n   * @returns {Promise<void>} Resolves upon the message being sent\n   * @see {@link ShardingManager#respawnAll}\n   */\n  respawnAll({ shardDelay = 5_000, respawnDelay = 500, timeout = 30_000 } = {}) {\n    return this.send({ _sRespawnAll: { shardDelay, respawnDelay, timeout } });\n  }\n\n  /**\n   * Handles an IPC message.\n   * @param {*} message Message received\n   * @private\n   */\n  async _handleMessage(message) {\n    if (!message) return;\n    if (message._fetchProp) {\n      try {\n        const props = message._fetchProp.split('.');\n        let value = this.client;\n        for (const prop of props) value = value[prop];\n        this._respond('fetchProp', { _fetchProp: message._fetchProp, _result: value });\n      } catch (err) {\n        this._respond('fetchProp', { _fetchProp: message._fetchProp, _error: makePlainError(err) });\n      }\n    } else if (message._eval) {\n      try {\n        this._respond('eval', { _eval: message._eval, _result: await this.client._eval(message._eval) });\n      } catch (err) {\n        this._respond('eval', { _eval: message._eval, _error: makePlainError(err) });\n      }\n    }\n  }\n\n  /**\n   * Sends a message to the master process, emitting an error from the client upon failure.\n   * @param {string} type Type of response to send\n   * @param {*} message Message to send\n   * @private\n   */\n  _respond(type, message) {\n    this.send(message).catch(err => {\n      const error = new Error(`Error when sending ${type} response to master process: ${err.message}`);\n      error.stack = err.stack;\n      /**\n       * Emitted when the client encounters an error.\n       * <warn>Errors thrown within this event do not have a catch handler, it is\n       * recommended to not use async functions as `error` event handlers. See the\n       * [Node.js docs](https://nodejs.org/api/events.html#capture-rejections-of-promises) for details.</warn>\n       * @event Client#error\n       * @param {Error} error The error encountered\n       */\n      this.client.emit(Events.Error, error);\n    });\n  }\n\n  /**\n   * Creates/gets the singleton of this class.\n   * @param {Client} client The client to use\n   * @param {ShardingManagerMode} mode Mode the shard was spawned with\n   * @returns {ShardClientUtil}\n   */\n  static singleton(client, mode) {\n    if (!this._singleton) {\n      this._singleton = new this(client, mode);\n    } else {\n      client.emit(\n        Events.Warn,\n        'Multiple clients created in child process/worker; only the first will handle sharding helpers.',\n      );\n    }\n    return this._singleton;\n  }\n\n  /**\n   * Get the shard id for a given guild id.\n   * @param {Snowflake} guildId Snowflake guild id to get shard id for\n   * @param {number} shardCount Number of shards\n   * @returns {number}\n   */\n  static shardIdForGuildId(guildId, shardCount) {\n    const shard = calculateShardId(guildId, shardCount);\n    if (shard < 0) throw new DiscordjsError(ErrorCodes.ShardingShardMiscalculation, shard, guildId, shardCount);\n    return shard;\n  }\n\n  /**\n   * Increments max listeners by one for a given emitter, if they are not zero.\n   * @param {EventEmitter|process} emitter The emitter that emits the events.\n   * @private\n   */\n  incrementMaxListeners(emitter) {\n    const maxListeners = emitter.getMaxListeners();\n    if (maxListeners !== 0) {\n      emitter.setMaxListeners(maxListeners + 1);\n    }\n  }\n\n  /**\n   * Decrements max listeners by one for a given emitter, if they are not zero.\n   * @param {EventEmitter|process} emitter The emitter that emits the events.\n   * @private\n   */\n  decrementMaxListeners(emitter) {\n    const maxListeners = emitter.getMaxListeners();\n    if (maxListeners !== 0) {\n      emitter.setMaxListeners(maxListeners - 1);\n    }\n  }\n}\n\nmodule.exports = ShardClientUtil;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}