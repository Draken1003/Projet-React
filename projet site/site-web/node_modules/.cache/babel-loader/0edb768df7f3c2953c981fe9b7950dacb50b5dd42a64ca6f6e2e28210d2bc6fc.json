{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  makeURLSearchParams\n} = require('@discordjs/rest');\nconst {\n  Routes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst {\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../errors');\nconst ThreadChannel = require('../structures/ThreadChannel');\nconst {\n  MakeCacheOverrideSymbol\n} = require('../util/Symbols');\n\n/**\n * Manages API methods for thread-based channels and stores their cache.\n * @extends {CachedManager}\n */\nclass ThreadManager extends CachedManager {\n  static [MakeCacheOverrideSymbol] = ThreadManager;\n  constructor(channel, iterable) {\n    super(channel.client, ThreadChannel, iterable);\n\n    /**\n     * The channel this Manager belongs to\n     * @type {TextChannel|NewsChannel|ForumChannel}\n     */\n    this.channel = channel;\n  }\n\n  /**\n   * Data that can be resolved to a Thread Channel object. This can be:\n   * * A ThreadChannel object\n   * * A Snowflake\n   * @typedef {ThreadChannel|Snowflake} ThreadChannelResolvable\n   */\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, ThreadChannel>}\n   * @name ThreadManager#cache\n   */\n\n  _add(thread) {\n    const existing = this.cache.get(thread.id);\n    if (existing) return existing;\n    this.cache.set(thread.id, thread);\n    return thread;\n  }\n\n  /**\n   * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} object.\n   * @method resolve\n   * @memberof ThreadManager\n   * @instance\n   * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve\n   * @returns {?ThreadChannel}\n   */\n\n  /**\n   * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} id.\n   * @method resolveId\n   * @memberof ThreadManager\n   * @instance\n   * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Options for creating a thread. <warn>Only one of `startMessage` or `type` can be defined.</warn>\n   * @typedef {StartThreadOptions} ThreadCreateOptions\n   * @property {MessageResolvable} [startMessage] The message to start a thread from. <warn>If this is defined then type\n   * of thread gets automatically defined and cannot be changed. The provided `type` field will be ignored</warn>\n   * @property {ChannelType.AnnouncementThread|ChannelType.PublicThread|ChannelType.PrivateThread} [type]\n   * The type of thread to create.\n   * Defaults to {@link ChannelType.PublicThread} if created in a {@link TextChannel}\n   * <warn>When creating threads in a {@link NewsChannel} this is ignored and is always\n   * {@link ChannelType.AnnouncementThread}</warn>\n   * @property {boolean} [invitable] Whether non-moderators can add other non-moderators to the thread\n   * <info>Can only be set when type will be {@link ChannelType.PrivateThread}</info>\n   */\n\n  /**\n   * Options for fetching multiple threads.\n   * @typedef {Object} FetchThreadsOptions\n   * @property {FetchArchivedThreadOptions} [archived] Options used to fetch archived threads\n   */\n\n  /**\n   * Obtains a thread from Discord, or the channel cache if it's already available.\n   * @param {ThreadChannelResolvable|FetchThreadsOptions} [options] The options to fetch threads. If it is a\n   * ThreadChannelResolvable then the specified thread will be fetched. Fetches all active threads if `undefined`\n   * @param {BaseFetchOptions} [cacheOptions] Additional options for this fetch. <warn>The `force` field gets ignored\n   * if `options` is not a {@link ThreadChannelResolvable}</warn>\n   * @returns {Promise<?(ThreadChannel|FetchedThreads|FetchedThreadsMore)>}\n   * {@link FetchedThreads} if active & {@link FetchedThreadsMore} if archived.\n   * @example\n   * // Fetch a thread by its id\n   * channel.threads.fetch('831955138126104859')\n   *   .then(channel => console.log(channel.name))\n   *   .catch(console.error);\n   */\n  fetch(options, {\n    cache,\n    force\n  } = {}) {\n    if (!options) return this.fetchActive(cache);\n    const channel = this.client.channels.resolveId(options);\n    if (channel) return this.client.channels.fetch(channel, {\n      cache,\n      force\n    });\n    if (options.archived) {\n      return this.fetchArchived(options.archived, cache);\n    }\n    return this.fetchActive(cache);\n  }\n\n  /**\n   * Data that can be resolved to a Date object. This can be:\n   * * A Date object\n   * * A number representing a timestamp\n   * * An [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) string\n   * @typedef {Date|number|string} DateResolvable\n   */\n\n  /**\n   * The options used to fetch archived threads.\n   * @typedef {Object} FetchArchivedThreadOptions\n   * @property {string} [type='public'] The type of threads to fetch (`public` or `private`)\n   * @property {boolean} [fetchAll=false] Whether to fetch **all** archived threads when `type` is `private`\n   * <info>This property requires the {@link PermissionFlagsBits.ManageThreads} permission if `true`.</info>\n   * @property {DateResolvable|ThreadChannelResolvable} [before] Only return threads that were archived before this Date\n   * or Snowflake\n   * <warn>Must be a {@link ThreadChannelResolvable} when `type` is `private` and `fetchAll` is `false`.</warn>\n   * @property {number} [limit] Maximum number of threads to return\n   */\n\n  /**\n   * Data returned from fetching multiple threads.\n   * @typedef {FetchedThreads} FetchedThreadsMore\n   * @property {?boolean} hasMore Whether there are potentially additional threads that require a subsequent call\n   */\n\n  /**\n   * Obtains a set of archived threads from Discord.\n   * <info>This method requires the {@link PermissionFlagsBits.ReadMessageHistory} permission\n   * in the parent channel.</info>\n   * @param {FetchArchivedThreadOptions} [options] The options to fetch archived threads\n   * @param {boolean} [cache=true] Whether to cache the new thread objects if they aren't already\n   * @returns {Promise<FetchedThreadsMore>}\n   */\n  async fetchArchived({\n    type = 'public',\n    fetchAll = false,\n    before,\n    limit\n  } = {}, cache = true) {\n    let path = Routes.channelThreads(this.channel.id, type);\n    if (type === 'private' && !fetchAll) {\n      path = Routes.channelJoinedArchivedThreads(this.channel.id);\n    }\n    let timestamp;\n    let id;\n    const query = makeURLSearchParams({\n      limit\n    });\n    if (before !== undefined) {\n      if (before instanceof ThreadChannel || /^\\d{17,19}$/.test(String(before))) {\n        id = this.resolveId(before);\n        timestamp = this.resolve(before)?.archivedAt?.toISOString();\n        const toUse = type === 'private' && !fetchAll ? id : timestamp;\n        if (toUse) {\n          query.set('before', toUse);\n        }\n      } else {\n        try {\n          timestamp = new Date(before).toISOString();\n          if (type === 'public' || fetchAll) {\n            query.set('before', timestamp);\n          }\n        } catch {\n          throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'before', 'DateResolvable or ThreadChannelResolvable');\n        }\n      }\n    }\n    const raw = await this.client.rest.get(path, {\n      query\n    });\n    return this.constructor._mapThreads(raw, this.client, {\n      parent: this.channel,\n      cache\n    });\n  }\n\n  /**\n   * Obtains all active threads in the channel.\n   * @param {boolean} [cache=true] Whether to cache the fetched data\n   * @returns {Promise<FetchedThreads>}\n   */\n  async fetchActive(cache = true) {\n    const data = await this.channel.guild.channels.rawFetchGuildActiveThreads();\n    return this.constructor._mapThreads(data, this.client, {\n      parent: this.channel,\n      cache\n    });\n  }\n  static _mapThreads(rawThreads, client, {\n    parent,\n    guild,\n    cache\n  }) {\n    const threads = rawThreads.threads.reduce((coll, raw) => {\n      const thread = client.channels._add(raw, guild ?? parent?.guild, {\n        cache\n      });\n      if (parent && thread.parentId !== parent.id) return coll;\n      return coll.set(thread.id, thread);\n    }, new Collection());\n\n    // Discord sends the thread id as id in this object\n    const threadMembers = rawThreads.members.reduce((coll, raw) => {\n      const thread = threads.get(raw.id);\n      return thread ? coll.set(raw.user_id, thread.members._add(raw)) : coll;\n    }, new Collection());\n    const response = {\n      threads,\n      members: threadMembers\n    };\n\n    // The GET `/guilds/{guild.id}/threads/active` route does not return `has_more`.\n    if ('has_more' in rawThreads) response.hasMore = rawThreads.has_more;\n    return response;\n  }\n}\nmodule.exports = ThreadManager;","map":{"version":3,"names":["Collection","require","makeURLSearchParams","Routes","CachedManager","DiscordjsTypeError","ErrorCodes","ThreadChannel","MakeCacheOverrideSymbol","ThreadManager","constructor","channel","iterable","client","_add","thread","existing","cache","get","id","set","fetch","options","force","fetchActive","channels","resolveId","archived","fetchArchived","type","fetchAll","before","limit","path","channelThreads","channelJoinedArchivedThreads","timestamp","query","undefined","test","String","resolve","archivedAt","toISOString","toUse","Date","InvalidType","raw","rest","_mapThreads","parent","data","guild","rawFetchGuildActiveThreads","rawThreads","threads","reduce","coll","parentId","threadMembers","members","user_id","response","hasMore","has_more","module","exports"],"sources":["C:/Users/hetit/node_modules/discord.js/src/managers/ThreadManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst { makeURLSearchParams } = require('@discordjs/rest');\nconst { Routes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst { DiscordjsTypeError, ErrorCodes } = require('../errors');\nconst ThreadChannel = require('../structures/ThreadChannel');\nconst { MakeCacheOverrideSymbol } = require('../util/Symbols');\n\n/**\n * Manages API methods for thread-based channels and stores their cache.\n * @extends {CachedManager}\n */\nclass ThreadManager extends CachedManager {\n  static [MakeCacheOverrideSymbol] = ThreadManager;\n\n  constructor(channel, iterable) {\n    super(channel.client, ThreadChannel, iterable);\n\n    /**\n     * The channel this Manager belongs to\n     * @type {TextChannel|NewsChannel|ForumChannel}\n     */\n    this.channel = channel;\n  }\n\n  /**\n   * Data that can be resolved to a Thread Channel object. This can be:\n   * * A ThreadChannel object\n   * * A Snowflake\n   * @typedef {ThreadChannel|Snowflake} ThreadChannelResolvable\n   */\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, ThreadChannel>}\n   * @name ThreadManager#cache\n   */\n\n  _add(thread) {\n    const existing = this.cache.get(thread.id);\n    if (existing) return existing;\n    this.cache.set(thread.id, thread);\n    return thread;\n  }\n\n  /**\n   * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} object.\n   * @method resolve\n   * @memberof ThreadManager\n   * @instance\n   * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve\n   * @returns {?ThreadChannel}\n   */\n\n  /**\n   * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} id.\n   * @method resolveId\n   * @memberof ThreadManager\n   * @instance\n   * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Options for creating a thread. <warn>Only one of `startMessage` or `type` can be defined.</warn>\n   * @typedef {StartThreadOptions} ThreadCreateOptions\n   * @property {MessageResolvable} [startMessage] The message to start a thread from. <warn>If this is defined then type\n   * of thread gets automatically defined and cannot be changed. The provided `type` field will be ignored</warn>\n   * @property {ChannelType.AnnouncementThread|ChannelType.PublicThread|ChannelType.PrivateThread} [type]\n   * The type of thread to create.\n   * Defaults to {@link ChannelType.PublicThread} if created in a {@link TextChannel}\n   * <warn>When creating threads in a {@link NewsChannel} this is ignored and is always\n   * {@link ChannelType.AnnouncementThread}</warn>\n   * @property {boolean} [invitable] Whether non-moderators can add other non-moderators to the thread\n   * <info>Can only be set when type will be {@link ChannelType.PrivateThread}</info>\n   */\n\n  /**\n   * Options for fetching multiple threads.\n   * @typedef {Object} FetchThreadsOptions\n   * @property {FetchArchivedThreadOptions} [archived] Options used to fetch archived threads\n   */\n\n  /**\n   * Obtains a thread from Discord, or the channel cache if it's already available.\n   * @param {ThreadChannelResolvable|FetchThreadsOptions} [options] The options to fetch threads. If it is a\n   * ThreadChannelResolvable then the specified thread will be fetched. Fetches all active threads if `undefined`\n   * @param {BaseFetchOptions} [cacheOptions] Additional options for this fetch. <warn>The `force` field gets ignored\n   * if `options` is not a {@link ThreadChannelResolvable}</warn>\n   * @returns {Promise<?(ThreadChannel|FetchedThreads|FetchedThreadsMore)>}\n   * {@link FetchedThreads} if active & {@link FetchedThreadsMore} if archived.\n   * @example\n   * // Fetch a thread by its id\n   * channel.threads.fetch('831955138126104859')\n   *   .then(channel => console.log(channel.name))\n   *   .catch(console.error);\n   */\n  fetch(options, { cache, force } = {}) {\n    if (!options) return this.fetchActive(cache);\n    const channel = this.client.channels.resolveId(options);\n    if (channel) return this.client.channels.fetch(channel, { cache, force });\n    if (options.archived) {\n      return this.fetchArchived(options.archived, cache);\n    }\n    return this.fetchActive(cache);\n  }\n\n  /**\n   * Data that can be resolved to a Date object. This can be:\n   * * A Date object\n   * * A number representing a timestamp\n   * * An [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) string\n   * @typedef {Date|number|string} DateResolvable\n   */\n\n  /**\n   * The options used to fetch archived threads.\n   * @typedef {Object} FetchArchivedThreadOptions\n   * @property {string} [type='public'] The type of threads to fetch (`public` or `private`)\n   * @property {boolean} [fetchAll=false] Whether to fetch **all** archived threads when `type` is `private`\n   * <info>This property requires the {@link PermissionFlagsBits.ManageThreads} permission if `true`.</info>\n   * @property {DateResolvable|ThreadChannelResolvable} [before] Only return threads that were archived before this Date\n   * or Snowflake\n   * <warn>Must be a {@link ThreadChannelResolvable} when `type` is `private` and `fetchAll` is `false`.</warn>\n   * @property {number} [limit] Maximum number of threads to return\n   */\n\n  /**\n   * Data returned from fetching multiple threads.\n   * @typedef {FetchedThreads} FetchedThreadsMore\n   * @property {?boolean} hasMore Whether there are potentially additional threads that require a subsequent call\n   */\n\n  /**\n   * Obtains a set of archived threads from Discord.\n   * <info>This method requires the {@link PermissionFlagsBits.ReadMessageHistory} permission\n   * in the parent channel.</info>\n   * @param {FetchArchivedThreadOptions} [options] The options to fetch archived threads\n   * @param {boolean} [cache=true] Whether to cache the new thread objects if they aren't already\n   * @returns {Promise<FetchedThreadsMore>}\n   */\n  async fetchArchived({ type = 'public', fetchAll = false, before, limit } = {}, cache = true) {\n    let path = Routes.channelThreads(this.channel.id, type);\n    if (type === 'private' && !fetchAll) {\n      path = Routes.channelJoinedArchivedThreads(this.channel.id);\n    }\n    let timestamp;\n    let id;\n    const query = makeURLSearchParams({ limit });\n    if (before !== undefined) {\n      if (before instanceof ThreadChannel || /^\\d{17,19}$/.test(String(before))) {\n        id = this.resolveId(before);\n        timestamp = this.resolve(before)?.archivedAt?.toISOString();\n        const toUse = type === 'private' && !fetchAll ? id : timestamp;\n        if (toUse) {\n          query.set('before', toUse);\n        }\n      } else {\n        try {\n          timestamp = new Date(before).toISOString();\n          if (type === 'public' || fetchAll) {\n            query.set('before', timestamp);\n          }\n        } catch {\n          throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'before', 'DateResolvable or ThreadChannelResolvable');\n        }\n      }\n    }\n\n    const raw = await this.client.rest.get(path, { query });\n    return this.constructor._mapThreads(raw, this.client, { parent: this.channel, cache });\n  }\n\n  /**\n   * Obtains all active threads in the channel.\n   * @param {boolean} [cache=true] Whether to cache the fetched data\n   * @returns {Promise<FetchedThreads>}\n   */\n  async fetchActive(cache = true) {\n    const data = await this.channel.guild.channels.rawFetchGuildActiveThreads();\n    return this.constructor._mapThreads(data, this.client, { parent: this.channel, cache });\n  }\n\n  static _mapThreads(rawThreads, client, { parent, guild, cache }) {\n    const threads = rawThreads.threads.reduce((coll, raw) => {\n      const thread = client.channels._add(raw, guild ?? parent?.guild, { cache });\n      if (parent && thread.parentId !== parent.id) return coll;\n      return coll.set(thread.id, thread);\n    }, new Collection());\n\n    // Discord sends the thread id as id in this object\n    const threadMembers = rawThreads.members.reduce((coll, raw) => {\n      const thread = threads.get(raw.id);\n      return thread ? coll.set(raw.user_id, thread.members._add(raw)) : coll;\n    }, new Collection());\n\n    const response = { threads, members: threadMembers };\n\n    // The GET `/guilds/{guild.id}/threads/active` route does not return `has_more`.\n    if ('has_more' in rawThreads) response.hasMore = rawThreads.has_more;\n    return response;\n  }\n}\n\nmodule.exports = ThreadManager;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}