{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  DiscordSnowflake\n} = require('@sapphire/snowflake');\nconst {\n  InteractionType,\n  Routes\n} = require('discord-api-types/v10');\nconst {\n  DiscordjsTypeError,\n  DiscordjsError,\n  ErrorCodes\n} = require('../../errors');\nconst {\n  MaxBulkDeletableMessageAge\n} = require('../../util/Constants');\nconst InteractionCollector = require('../InteractionCollector');\nconst MessageCollector = require('../MessageCollector');\nconst MessagePayload = require('../MessagePayload');\n\n/**\n * Interface for classes that have text-channel-like features.\n * @interface\n */\nclass TextBasedChannel {\n  constructor() {\n    /**\n     * A manager of the messages sent to this channel\n     * @type {GuildMessageManager}\n     */\n    this.messages = new GuildMessageManager(this);\n\n    /**\n     * The channel's last message id, if one was sent\n     * @type {?Snowflake}\n     */\n    this.lastMessageId = null;\n\n    /**\n     * The timestamp when the last pinned message was pinned, if there was one\n     * @type {?number}\n     */\n    this.lastPinTimestamp = null;\n  }\n\n  /**\n   * The Message object of the last message in the channel, if one was sent\n   * @type {?Message}\n   * @readonly\n   */\n  get lastMessage() {\n    return this.messages.resolve(this.lastMessageId);\n  }\n\n  /**\n   * The date when the last pinned message was pinned, if there was one\n   * @type {?Date}\n   * @readonly\n   */\n  get lastPinAt() {\n    return this.lastPinTimestamp && new Date(this.lastPinTimestamp);\n  }\n\n  /**\n   * The base message options for messages.\n   * @typedef {Object} BaseMessageOptions\n   * @property {string|null} [content=''] The content for the message. This can only be `null` when editing a message.\n   * @property {Array<(EmbedBuilder|Embed|APIEmbed)>} [embeds] The embeds for the message\n   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n   * (see [here](https://discord.com/developers/docs/resources/channel#allowed-mentions-object) for more details)\n   * @property {Array<(AttachmentBuilder|Attachment|AttachmentPayload|BufferResolvable)>} [files]\n   * The files to send with the message.\n   * @property {Array<(ActionRowBuilder|ActionRow|APIActionRowComponent)>} [components]\n   * Action rows containing interactive components for the message (buttons, select menus)\n   */\n\n  /**\n   * Options for sending a message with a reply.\n   * @typedef {Object} ReplyOptions\n   * @property {MessageResolvable} messageReference The message to reply to (must be in the same channel and not system)\n   * @property {boolean} [failIfNotExists=this.client.options.failIfNotExists] Whether to error if the referenced\n   * message does not exist (creates a standard message in this case when false)\n   */\n\n  /**\n   * The options for sending a message.\n   * @typedef {BaseMessageOptions} BaseMessageCreateOptions\n   * @property {boolean} [tts=false] Whether the message should be spoken aloud\n   * @property {string} [nonce=''] The nonce for the message\n   * @property {StickerResolvable[]} [stickers=[]] The stickers to send in the message\n   * @property {MessageFlags} [flags] Which flags to set for the message.\n   * <info>Only `MessageFlags.SuppressEmbeds` and `MessageFlags.SuppressNotifications` can be set.</info>\n   */\n\n  /**\n   * The options for sending a message.\n   * @typedef {BaseMessageCreateOptions} MessageCreateOptions\n   * @property {ReplyOptions} [reply] The options for replying to a message\n   */\n\n  /**\n   * Options provided to control parsing of mentions by Discord\n   * @typedef {Object} MessageMentionOptions\n   * @property {MessageMentionTypes[]} [parse] Types of mentions to be parsed\n   * @property {Snowflake[]} [users] Snowflakes of Users to be parsed as mentions\n   * @property {Snowflake[]} [roles] Snowflakes of Roles to be parsed as mentions\n   * @property {boolean} [repliedUser=true] Whether the author of the Message being replied to should be pinged\n   */\n\n  /**\n   * Types of mentions to enable in MessageMentionOptions.\n   * - `roles`\n   * - `users`\n   * - `everyone`\n   * @typedef {string} MessageMentionTypes\n   */\n\n  /**\n   * @typedef {Object} FileOptions\n   * @property {BufferResolvable} attachment File to attach\n   * @property {string} [name='file.jpg'] Filename of the attachment\n   * @property {string} description The description of the file\n   */\n\n  /**\n   * Sends a message to this channel.\n   * @param {string|MessagePayload|MessageCreateOptions} options The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Send a basic message\n   * channel.send('hello!')\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a remote file\n   * channel.send({\n   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send a local file\n   * channel.send({\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg',\n   *     description: 'A description of the file'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async send(options) {\n    const User = require('../User');\n    const {\n      GuildMember\n    } = require('../GuildMember');\n    if (this instanceof User || this instanceof GuildMember) {\n      const dm = await this.createDM();\n      return dm.send(options);\n    }\n    let messagePayload;\n    if (options instanceof MessagePayload) {\n      messagePayload = options.resolveBody();\n    } else {\n      messagePayload = MessagePayload.create(this, options).resolveBody();\n    }\n    const {\n      body,\n      files\n    } = await messagePayload.resolveFiles();\n    const d = await this.client.rest.post(Routes.channelMessages(this.id), {\n      body,\n      files\n    });\n    return this.messages.cache.get(d.id) ?? this.messages._add(d);\n  }\n\n  /**\n   * Sends a typing indicator in the channel.\n   * @returns {Promise<void>} Resolves upon the typing status being sent\n   * @example\n   * // Start typing in a channel\n   * channel.sendTyping();\n   */\n  async sendTyping() {\n    await this.client.rest.post(Routes.channelTyping(this.id));\n  }\n\n  /**\n   * Creates a Message Collector.\n   * @param {MessageCollectorOptions} [options={}] The options to pass to the collector\n   * @returns {MessageCollector}\n   * @example\n   * // Create a message collector\n   * const filter = m => m.content.includes('discord');\n   * const collector = channel.createMessageCollector({ filter, time: 15_000 });\n   * collector.on('collect', m => console.log(`Collected ${m.content}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createMessageCollector(options = {}) {\n    return new MessageCollector(this, options);\n  }\n\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {MessageCollectorOptions} AwaitMessagesOptions\n   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n   */\n\n  /**\n   * Similar to createMessageCollector but in promise form.\n   * Resolves with a collection of messages that pass the specified filter.\n   * @param {AwaitMessagesOptions} [options={}] Optional options to pass to the internal collector\n   * @returns {Promise<Collection<Snowflake, Message>>}\n   * @example\n   * // Await !vote messages\n   * const filter = m => m.content.startsWith('!vote');\n   * // Errors: ['time'] treats ending because of the time limit as an error\n   * channel.awaitMessages({ filter, max: 4, time: 60_000, errors: ['time'] })\n   *   .then(collected => console.log(collected.size))\n   *   .catch(collected => console.log(`After a minute, only ${collected.size} out of 4 voted.`));\n   */\n  awaitMessages(options = {}) {\n    return new Promise((resolve, reject) => {\n      const collector = this.createMessageCollector(options);\n      collector.once('end', (collection, reason) => {\n        if (options.errors?.includes(reason)) {\n          reject(collection);\n        } else {\n          resolve(collection);\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates a component interaction collector.\n   * @param {MessageComponentCollectorOptions} [options={}] Options to send to the collector\n   * @returns {InteractionCollector}\n   * @example\n   * // Create a button interaction collector\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * const collector = channel.createMessageComponentCollector({ filter, time: 15_000 });\n   * collector.on('collect', i => console.log(`Collected ${i.customId}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createMessageComponentCollector(options = {}) {\n    return new InteractionCollector(this.client, {\n      ...options,\n      interactionType: InteractionType.MessageComponent,\n      channel: this\n    });\n  }\n\n  /**\n   * Collects a single component interaction that passes the filter.\n   * The Promise will reject if the time expires.\n   * @param {AwaitMessageComponentOptions} [options={}] Options to pass to the internal collector\n   * @returns {Promise<MessageComponentInteraction>}\n   * @example\n   * // Collect a message component interaction\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * channel.awaitMessageComponent({ filter, time: 15_000 })\n   *   .then(interaction => console.log(`${interaction.customId} was clicked!`))\n   *   .catch(console.error);\n   */\n  awaitMessageComponent(options = {}) {\n    const _options = {\n      ...options,\n      max: 1\n    };\n    return new Promise((resolve, reject) => {\n      const collector = this.createMessageComponentCollector(_options);\n      collector.once('end', (interactions, reason) => {\n        const interaction = interactions.first();\n        if (interaction) resolve(interaction);else reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));\n      });\n    });\n  }\n\n  /**\n   * Bulk deletes given messages that are newer than two weeks.\n   * @param {Collection<Snowflake, Message>|MessageResolvable[]|number} messages\n   * Messages or number of messages to delete\n   * @param {boolean} [filterOld=false] Filter messages to remove those which are older than two weeks automatically\n   * @returns {Promise<Collection<Snowflake, Message|undefined>>} Returns the deleted messages\n   * @example\n   * // Bulk delete messages\n   * channel.bulkDelete(5)\n   *   .then(messages => console.log(`Bulk deleted ${messages.size} messages`))\n   *   .catch(console.error);\n   */\n  async bulkDelete(messages, filterOld = false) {\n    if (Array.isArray(messages) || messages instanceof Collection) {\n      let messageIds = messages instanceof Collection ? [...messages.keys()] : messages.map(m => m.id ?? m);\n      if (filterOld) {\n        messageIds = messageIds.filter(id => Date.now() - DiscordSnowflake.timestampFrom(id) < MaxBulkDeletableMessageAge);\n      }\n      if (messageIds.length === 0) return new Collection();\n      if (messageIds.length === 1) {\n        const message = this.client.actions.MessageDelete.getMessage({\n          message_id: messageIds[0]\n        }, this);\n        await this.client.rest.delete(Routes.channelMessage(this.id, messageIds[0]));\n        return message ? new Collection([[message.id, message]]) : new Collection();\n      }\n      await this.client.rest.post(Routes.channelBulkDelete(this.id), {\n        body: {\n          messages: messageIds\n        }\n      });\n      return messageIds.reduce((col, id) => col.set(id, this.client.actions.MessageDeleteBulk.getMessage({\n        message_id: id\n      }, this)), new Collection());\n    }\n    if (!isNaN(messages)) {\n      const msgs = await this.messages.fetch({\n        limit: messages\n      });\n      return this.bulkDelete(msgs, filterOld);\n    }\n    throw new DiscordjsTypeError(ErrorCodes.MessageBulkDeleteType);\n  }\n\n  /**\n   * Fetches all webhooks for the channel.\n   * @returns {Promise<Collection<Snowflake, Webhook>>}\n   * @example\n   * // Fetch webhooks\n   * channel.fetchWebhooks()\n   *   .then(hooks => console.log(`This channel has ${hooks.size} hooks`))\n   *   .catch(console.error);\n   */\n  fetchWebhooks() {\n    return this.guild.channels.fetchWebhooks(this.id);\n  }\n\n  /**\n   * Options used to create a {@link Webhook}.\n   * @typedef {Object} ChannelWebhookCreateOptions\n   * @property {string} name The name of the webhook\n   * @property {?(BufferResolvable|Base64Resolvable)} [avatar] Avatar for the webhook\n   * @property {string} [reason] Reason for creating the webhook\n   */\n\n  /**\n   * Creates a webhook for the channel.\n   * @param {ChannelWebhookCreateOptions} [options] Options for creating the webhook\n   * @returns {Promise<Webhook>} Returns the created Webhook\n   * @example\n   * // Create a webhook for the current channel\n   * channel.createWebhook({\n   *   name: 'Snek',\n   *   avatar: 'https://i.imgur.com/mI8XcpG.jpg',\n   *   reason: 'Needed a cool new Webhook'\n   * })\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  createWebhook(options) {\n    return this.guild.channels.createWebhook({\n      channel: this.id,\n      ...options\n    });\n  }\n\n  /**\n   * Sets the rate limit per user (slowmode) for this channel.\n   * @param {number} rateLimitPerUser The new rate limit in seconds\n   * @param {string} [reason] Reason for changing the channel's rate limit\n   * @returns {Promise<this>}\n   */\n  setRateLimitPerUser(rateLimitPerUser, reason) {\n    return this.edit({\n      rateLimitPerUser,\n      reason\n    });\n  }\n\n  /**\n   * Sets whether this channel is flagged as NSFW.\n   * @param {boolean} [nsfw=true] Whether the channel should be considered NSFW\n   * @param {string} [reason] Reason for changing the channel's NSFW flag\n   * @returns {Promise<this>}\n   */\n  setNSFW(nsfw = true, reason) {\n    return this.edit({\n      nsfw,\n      reason\n    });\n  }\n  static applyToClass(structure, full = false, ignore = []) {\n    const props = ['send'];\n    if (full) {\n      props.push('lastMessage', 'lastPinAt', 'bulkDelete', 'sendTyping', 'createMessageCollector', 'awaitMessages', 'createMessageComponentCollector', 'awaitMessageComponent', 'fetchWebhooks', 'createWebhook', 'setRateLimitPerUser', 'setNSFW');\n    }\n    for (const prop of props) {\n      if (ignore.includes(prop)) continue;\n      Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(TextBasedChannel.prototype, prop));\n    }\n  }\n}\nmodule.exports = TextBasedChannel;\n\n// Fixes Circular\n// eslint-disable-next-line import/order\nconst GuildMessageManager = require('../../managers/GuildMessageManager');","map":{"version":3,"names":["Collection","require","DiscordSnowflake","InteractionType","Routes","DiscordjsTypeError","DiscordjsError","ErrorCodes","MaxBulkDeletableMessageAge","InteractionCollector","MessageCollector","MessagePayload","TextBasedChannel","constructor","messages","GuildMessageManager","lastMessageId","lastPinTimestamp","lastMessage","resolve","lastPinAt","Date","send","options","User","GuildMember","dm","createDM","messagePayload","resolveBody","create","body","files","resolveFiles","d","client","rest","post","channelMessages","id","cache","get","_add","sendTyping","channelTyping","createMessageCollector","awaitMessages","Promise","reject","collector","once","collection","reason","errors","includes","createMessageComponentCollector","interactionType","MessageComponent","channel","awaitMessageComponent","_options","max","interactions","interaction","first","InteractionCollectorError","bulkDelete","filterOld","Array","isArray","messageIds","keys","map","m","filter","now","timestampFrom","length","message","actions","MessageDelete","getMessage","message_id","delete","channelMessage","channelBulkDelete","reduce","col","set","MessageDeleteBulk","isNaN","msgs","fetch","limit","MessageBulkDeleteType","fetchWebhooks","guild","channels","createWebhook","setRateLimitPerUser","rateLimitPerUser","edit","setNSFW","nsfw","applyToClass","structure","full","ignore","props","push","prop","Object","defineProperty","prototype","getOwnPropertyDescriptor","module","exports"],"sources":["C:/Users/hetit/node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst { DiscordSnowflake } = require('@sapphire/snowflake');\nconst { InteractionType, Routes } = require('discord-api-types/v10');\nconst { DiscordjsTypeError, DiscordjsError, ErrorCodes } = require('../../errors');\nconst { MaxBulkDeletableMessageAge } = require('../../util/Constants');\nconst InteractionCollector = require('../InteractionCollector');\nconst MessageCollector = require('../MessageCollector');\nconst MessagePayload = require('../MessagePayload');\n\n/**\n * Interface for classes that have text-channel-like features.\n * @interface\n */\nclass TextBasedChannel {\n  constructor() {\n    /**\n     * A manager of the messages sent to this channel\n     * @type {GuildMessageManager}\n     */\n    this.messages = new GuildMessageManager(this);\n\n    /**\n     * The channel's last message id, if one was sent\n     * @type {?Snowflake}\n     */\n    this.lastMessageId = null;\n\n    /**\n     * The timestamp when the last pinned message was pinned, if there was one\n     * @type {?number}\n     */\n    this.lastPinTimestamp = null;\n  }\n\n  /**\n   * The Message object of the last message in the channel, if one was sent\n   * @type {?Message}\n   * @readonly\n   */\n  get lastMessage() {\n    return this.messages.resolve(this.lastMessageId);\n  }\n\n  /**\n   * The date when the last pinned message was pinned, if there was one\n   * @type {?Date}\n   * @readonly\n   */\n  get lastPinAt() {\n    return this.lastPinTimestamp && new Date(this.lastPinTimestamp);\n  }\n\n  /**\n   * The base message options for messages.\n   * @typedef {Object} BaseMessageOptions\n   * @property {string|null} [content=''] The content for the message. This can only be `null` when editing a message.\n   * @property {Array<(EmbedBuilder|Embed|APIEmbed)>} [embeds] The embeds for the message\n   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n   * (see [here](https://discord.com/developers/docs/resources/channel#allowed-mentions-object) for more details)\n   * @property {Array<(AttachmentBuilder|Attachment|AttachmentPayload|BufferResolvable)>} [files]\n   * The files to send with the message.\n   * @property {Array<(ActionRowBuilder|ActionRow|APIActionRowComponent)>} [components]\n   * Action rows containing interactive components for the message (buttons, select menus)\n   */\n\n  /**\n   * Options for sending a message with a reply.\n   * @typedef {Object} ReplyOptions\n   * @property {MessageResolvable} messageReference The message to reply to (must be in the same channel and not system)\n   * @property {boolean} [failIfNotExists=this.client.options.failIfNotExists] Whether to error if the referenced\n   * message does not exist (creates a standard message in this case when false)\n   */\n\n  /**\n   * The options for sending a message.\n   * @typedef {BaseMessageOptions} BaseMessageCreateOptions\n   * @property {boolean} [tts=false] Whether the message should be spoken aloud\n   * @property {string} [nonce=''] The nonce for the message\n   * @property {StickerResolvable[]} [stickers=[]] The stickers to send in the message\n   * @property {MessageFlags} [flags] Which flags to set for the message.\n   * <info>Only `MessageFlags.SuppressEmbeds` and `MessageFlags.SuppressNotifications` can be set.</info>\n   */\n\n  /**\n   * The options for sending a message.\n   * @typedef {BaseMessageCreateOptions} MessageCreateOptions\n   * @property {ReplyOptions} [reply] The options for replying to a message\n   */\n\n  /**\n   * Options provided to control parsing of mentions by Discord\n   * @typedef {Object} MessageMentionOptions\n   * @property {MessageMentionTypes[]} [parse] Types of mentions to be parsed\n   * @property {Snowflake[]} [users] Snowflakes of Users to be parsed as mentions\n   * @property {Snowflake[]} [roles] Snowflakes of Roles to be parsed as mentions\n   * @property {boolean} [repliedUser=true] Whether the author of the Message being replied to should be pinged\n   */\n\n  /**\n   * Types of mentions to enable in MessageMentionOptions.\n   * - `roles`\n   * - `users`\n   * - `everyone`\n   * @typedef {string} MessageMentionTypes\n   */\n\n  /**\n   * @typedef {Object} FileOptions\n   * @property {BufferResolvable} attachment File to attach\n   * @property {string} [name='file.jpg'] Filename of the attachment\n   * @property {string} description The description of the file\n   */\n\n  /**\n   * Sends a message to this channel.\n   * @param {string|MessagePayload|MessageCreateOptions} options The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Send a basic message\n   * channel.send('hello!')\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a remote file\n   * channel.send({\n   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send a local file\n   * channel.send({\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg',\n   *     description: 'A description of the file'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async send(options) {\n    const User = require('../User');\n    const { GuildMember } = require('../GuildMember');\n\n    if (this instanceof User || this instanceof GuildMember) {\n      const dm = await this.createDM();\n      return dm.send(options);\n    }\n\n    let messagePayload;\n\n    if (options instanceof MessagePayload) {\n      messagePayload = options.resolveBody();\n    } else {\n      messagePayload = MessagePayload.create(this, options).resolveBody();\n    }\n\n    const { body, files } = await messagePayload.resolveFiles();\n    const d = await this.client.rest.post(Routes.channelMessages(this.id), { body, files });\n\n    return this.messages.cache.get(d.id) ?? this.messages._add(d);\n  }\n\n  /**\n   * Sends a typing indicator in the channel.\n   * @returns {Promise<void>} Resolves upon the typing status being sent\n   * @example\n   * // Start typing in a channel\n   * channel.sendTyping();\n   */\n  async sendTyping() {\n    await this.client.rest.post(Routes.channelTyping(this.id));\n  }\n\n  /**\n   * Creates a Message Collector.\n   * @param {MessageCollectorOptions} [options={}] The options to pass to the collector\n   * @returns {MessageCollector}\n   * @example\n   * // Create a message collector\n   * const filter = m => m.content.includes('discord');\n   * const collector = channel.createMessageCollector({ filter, time: 15_000 });\n   * collector.on('collect', m => console.log(`Collected ${m.content}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createMessageCollector(options = {}) {\n    return new MessageCollector(this, options);\n  }\n\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {MessageCollectorOptions} AwaitMessagesOptions\n   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n   */\n\n  /**\n   * Similar to createMessageCollector but in promise form.\n   * Resolves with a collection of messages that pass the specified filter.\n   * @param {AwaitMessagesOptions} [options={}] Optional options to pass to the internal collector\n   * @returns {Promise<Collection<Snowflake, Message>>}\n   * @example\n   * // Await !vote messages\n   * const filter = m => m.content.startsWith('!vote');\n   * // Errors: ['time'] treats ending because of the time limit as an error\n   * channel.awaitMessages({ filter, max: 4, time: 60_000, errors: ['time'] })\n   *   .then(collected => console.log(collected.size))\n   *   .catch(collected => console.log(`After a minute, only ${collected.size} out of 4 voted.`));\n   */\n  awaitMessages(options = {}) {\n    return new Promise((resolve, reject) => {\n      const collector = this.createMessageCollector(options);\n      collector.once('end', (collection, reason) => {\n        if (options.errors?.includes(reason)) {\n          reject(collection);\n        } else {\n          resolve(collection);\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates a component interaction collector.\n   * @param {MessageComponentCollectorOptions} [options={}] Options to send to the collector\n   * @returns {InteractionCollector}\n   * @example\n   * // Create a button interaction collector\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * const collector = channel.createMessageComponentCollector({ filter, time: 15_000 });\n   * collector.on('collect', i => console.log(`Collected ${i.customId}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createMessageComponentCollector(options = {}) {\n    return new InteractionCollector(this.client, {\n      ...options,\n      interactionType: InteractionType.MessageComponent,\n      channel: this,\n    });\n  }\n\n  /**\n   * Collects a single component interaction that passes the filter.\n   * The Promise will reject if the time expires.\n   * @param {AwaitMessageComponentOptions} [options={}] Options to pass to the internal collector\n   * @returns {Promise<MessageComponentInteraction>}\n   * @example\n   * // Collect a message component interaction\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * channel.awaitMessageComponent({ filter, time: 15_000 })\n   *   .then(interaction => console.log(`${interaction.customId} was clicked!`))\n   *   .catch(console.error);\n   */\n  awaitMessageComponent(options = {}) {\n    const _options = { ...options, max: 1 };\n    return new Promise((resolve, reject) => {\n      const collector = this.createMessageComponentCollector(_options);\n      collector.once('end', (interactions, reason) => {\n        const interaction = interactions.first();\n        if (interaction) resolve(interaction);\n        else reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));\n      });\n    });\n  }\n\n  /**\n   * Bulk deletes given messages that are newer than two weeks.\n   * @param {Collection<Snowflake, Message>|MessageResolvable[]|number} messages\n   * Messages or number of messages to delete\n   * @param {boolean} [filterOld=false] Filter messages to remove those which are older than two weeks automatically\n   * @returns {Promise<Collection<Snowflake, Message|undefined>>} Returns the deleted messages\n   * @example\n   * // Bulk delete messages\n   * channel.bulkDelete(5)\n   *   .then(messages => console.log(`Bulk deleted ${messages.size} messages`))\n   *   .catch(console.error);\n   */\n  async bulkDelete(messages, filterOld = false) {\n    if (Array.isArray(messages) || messages instanceof Collection) {\n      let messageIds = messages instanceof Collection ? [...messages.keys()] : messages.map(m => m.id ?? m);\n      if (filterOld) {\n        messageIds = messageIds.filter(\n          id => Date.now() - DiscordSnowflake.timestampFrom(id) < MaxBulkDeletableMessageAge,\n        );\n      }\n      if (messageIds.length === 0) return new Collection();\n      if (messageIds.length === 1) {\n        const message = this.client.actions.MessageDelete.getMessage(\n          {\n            message_id: messageIds[0],\n          },\n          this,\n        );\n        await this.client.rest.delete(Routes.channelMessage(this.id, messageIds[0]));\n        return message ? new Collection([[message.id, message]]) : new Collection();\n      }\n      await this.client.rest.post(Routes.channelBulkDelete(this.id), { body: { messages: messageIds } });\n      return messageIds.reduce(\n        (col, id) =>\n          col.set(\n            id,\n            this.client.actions.MessageDeleteBulk.getMessage(\n              {\n                message_id: id,\n              },\n              this,\n            ),\n          ),\n        new Collection(),\n      );\n    }\n    if (!isNaN(messages)) {\n      const msgs = await this.messages.fetch({ limit: messages });\n      return this.bulkDelete(msgs, filterOld);\n    }\n    throw new DiscordjsTypeError(ErrorCodes.MessageBulkDeleteType);\n  }\n\n  /**\n   * Fetches all webhooks for the channel.\n   * @returns {Promise<Collection<Snowflake, Webhook>>}\n   * @example\n   * // Fetch webhooks\n   * channel.fetchWebhooks()\n   *   .then(hooks => console.log(`This channel has ${hooks.size} hooks`))\n   *   .catch(console.error);\n   */\n  fetchWebhooks() {\n    return this.guild.channels.fetchWebhooks(this.id);\n  }\n\n  /**\n   * Options used to create a {@link Webhook}.\n   * @typedef {Object} ChannelWebhookCreateOptions\n   * @property {string} name The name of the webhook\n   * @property {?(BufferResolvable|Base64Resolvable)} [avatar] Avatar for the webhook\n   * @property {string} [reason] Reason for creating the webhook\n   */\n\n  /**\n   * Creates a webhook for the channel.\n   * @param {ChannelWebhookCreateOptions} [options] Options for creating the webhook\n   * @returns {Promise<Webhook>} Returns the created Webhook\n   * @example\n   * // Create a webhook for the current channel\n   * channel.createWebhook({\n   *   name: 'Snek',\n   *   avatar: 'https://i.imgur.com/mI8XcpG.jpg',\n   *   reason: 'Needed a cool new Webhook'\n   * })\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  createWebhook(options) {\n    return this.guild.channels.createWebhook({ channel: this.id, ...options });\n  }\n\n  /**\n   * Sets the rate limit per user (slowmode) for this channel.\n   * @param {number} rateLimitPerUser The new rate limit in seconds\n   * @param {string} [reason] Reason for changing the channel's rate limit\n   * @returns {Promise<this>}\n   */\n  setRateLimitPerUser(rateLimitPerUser, reason) {\n    return this.edit({ rateLimitPerUser, reason });\n  }\n\n  /**\n   * Sets whether this channel is flagged as NSFW.\n   * @param {boolean} [nsfw=true] Whether the channel should be considered NSFW\n   * @param {string} [reason] Reason for changing the channel's NSFW flag\n   * @returns {Promise<this>}\n   */\n  setNSFW(nsfw = true, reason) {\n    return this.edit({ nsfw, reason });\n  }\n\n  static applyToClass(structure, full = false, ignore = []) {\n    const props = ['send'];\n    if (full) {\n      props.push(\n        'lastMessage',\n        'lastPinAt',\n        'bulkDelete',\n        'sendTyping',\n        'createMessageCollector',\n        'awaitMessages',\n        'createMessageComponentCollector',\n        'awaitMessageComponent',\n        'fetchWebhooks',\n        'createWebhook',\n        'setRateLimitPerUser',\n        'setNSFW',\n      );\n    }\n    for (const prop of props) {\n      if (ignore.includes(prop)) continue;\n      Object.defineProperty(\n        structure.prototype,\n        prop,\n        Object.getOwnPropertyDescriptor(TextBasedChannel.prototype, prop),\n      );\n    }\n  }\n}\n\nmodule.exports = TextBasedChannel;\n\n// Fixes Circular\n// eslint-disable-next-line import/order\nconst GuildMessageManager = require('../../managers/GuildMessageManager');\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}