{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __name = (target, value) => __defProp(target, \"name\", {\n  value,\n  configurable: true\n});\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  AbortError: () => AbortError,\n  AsyncEventEmitter: () => AsyncEventEmitter\n});\nmodule.exports = __toCommonJS(src_exports);\nfunction validateListener(input) {\n  if (typeof input !== \"function\") {\n    throw new TypeError(`The listener argument must be a function. Received ${typeof input}`);\n  }\n}\n__name(validateListener, \"validateListener\");\nfunction validateAbortSignal(input) {\n  if (input && !(input instanceof AbortSignal)) {\n    throw new TypeError(`The signal option must be an AbortSignal. Received ${input}`);\n  }\n}\n__name(validateAbortSignal, \"validateAbortSignal\");\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++) {\n    list[index] = list[index + 1];\n  }\n  list.pop();\n}\n__name(spliceOne, \"spliceOne\");\nfunction arrayClone(arr) {\n  switch (arr.length) {\n    case 2:\n      return [arr[0], arr[1]];\n    case 3:\n      return [arr[0], arr[1], arr[2]];\n    case 4:\n      return [arr[0], arr[1], arr[2], arr[3]];\n    case 5:\n      return [arr[0], arr[1], arr[2], arr[3], arr[4]];\n    case 6:\n      return [arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]];\n  }\n  return arr.slice();\n}\n__name(arrayClone, \"arrayClone\");\nfunction identicalSequenceRange(a, b) {\n  for (let i = 0; i < a.length - 3; i++) {\n    const pos = b.indexOf(a[i]);\n    if (pos !== -1) {\n      const rest = b.length - pos;\n      if (rest > 3) {\n        let len = 1;\n        const maxLen = Math.min(a.length - i, rest);\n        while (maxLen > len && a[i + len] === b[pos + len]) {\n          len++;\n        }\n        if (len > 3) {\n          return [len, i];\n        }\n      }\n    }\n  }\n  return [0, 0];\n}\n__name(identicalSequenceRange, \"identicalSequenceRange\");\nfunction enhanceStackTrace(err, own) {\n  let ctorInfo = \"\";\n  try {\n    const {\n      name\n    } = this.constructor;\n    if (name !== \"AsyncEventEmitter\") ctorInfo = ` on ${name} instance`;\n  } catch {}\n  const sep = `\nEmitted 'error' event${ctorInfo} at:\n`;\n  const errStack = err.stack.split(\"\\n\").slice(1);\n  const ownStack = own.stack.split(\"\\n\").slice(1);\n  const {\n    0: len,\n    1: off\n  } = identicalSequenceRange(ownStack, errStack);\n  if (len > 0) {\n    ownStack.splice(off + 1, len - 2, \"    [... lines matching original stack trace ...]\");\n  }\n  return err.stack + sep + ownStack.join(\"\\n\");\n}\n__name(enhanceStackTrace, \"enhanceStackTrace\");\nvar AsyncEventEmitter = class {\n  constructor() {\n    this._events = {\n      __proto__: null\n    };\n    this._eventCount = 0;\n    this._maxListeners = 10;\n    this._internalPromiseMap = /* @__PURE__ */new Map();\n    this._wrapperId = 0n;\n  }\n  addListener(eventName, listener) {\n    validateListener(listener);\n    const wrapped = this._wrapListener(eventName, listener, false);\n    this._addListener(eventName, wrapped, false);\n    return this;\n  }\n  on(eventName, listener) {\n    return this.addListener(eventName, listener);\n  }\n  once(eventName, listener) {\n    validateListener(listener);\n    const wrapped = this._wrapListener(eventName, listener, true);\n    this._addListener(eventName, wrapped, false);\n    return this;\n  }\n  removeListener(eventName, listener) {\n    validateListener(listener);\n    const events = this._events;\n    const eventList = events[eventName];\n    if (eventList === void 0) {\n      return this;\n    }\n    if (eventList === listener || eventList.listener === listener) {\n      if (--this._eventCount === 0) {\n        this._events = {\n          __proto__: null\n        };\n      } else {\n        delete events[eventName];\n        if (events.removeListener) {\n          this.emit(\"removeListener\", eventName, eventList.listener ?? eventList);\n        }\n      }\n    } else if (typeof eventList !== \"function\") {\n      let position = -1;\n      for (let i = eventList.length - 1; i >= 0; i--) {\n        if (eventList[i] === listener || eventList[i].listener === listener) {\n          position = i;\n          break;\n        }\n      }\n      if (position < 0) {\n        return this;\n      }\n      if (position === 0) {\n        eventList.shift();\n      } else {\n        spliceOne(eventList, position);\n      }\n      if (eventList.length === 0) {\n        delete events[eventName];\n        --this._eventCount;\n      }\n      if (events.removeListener !== void 0) {\n        this.emit(\"removeListener\", eventName, listener);\n      }\n    }\n    return this;\n  }\n  off(eventName, listener) {\n    return this.removeListener(eventName, listener);\n  }\n  removeAllListeners(event) {\n    const events = this._events;\n    if (events.removeListener === void 0) {\n      if (!event) {\n        this._events = {\n          __proto__: null\n        };\n        this._eventCount = 0;\n      } else if (events[event] !== void 0) {\n        if (--this._eventCount === 0) {\n          this._events = {\n            __proto__: null\n          };\n        } else {\n          delete events[event];\n        }\n      }\n      return this;\n    }\n    if (!event) {\n      for (const key of Reflect.ownKeys(events)) {\n        if (key === \"removeListener\") {\n          continue;\n        }\n        this.removeAllListeners(key);\n      }\n      this.removeAllListeners(\"removeListener\");\n      this._events = {\n        __proto__: null\n      };\n      this._eventCount = 0;\n      return this;\n    }\n    const listeners = events[event];\n    if (typeof listeners === \"function\") {\n      this.removeListener(event, listeners);\n    } else if (listeners !== void 0) {\n      for (let i = listeners.length - 1; i >= 0; i--) {\n        this.removeListener(event, listeners[i]);\n      }\n    }\n    return this;\n  }\n  setMaxListeners(n) {\n    if (typeof n !== \"number\" || n < 0 || Number.isNaN(n)) {\n      throw new RangeError(`Expected to get a non-negative number for \"setMaxListeners\", got ${n} instead`);\n    }\n    this._maxListeners = n;\n    return this;\n  }\n  getMaxListeners() {\n    return this._maxListeners;\n  }\n  listeners(eventName) {\n    const eventList = this._events[eventName];\n    if (eventList === void 0) {\n      return [];\n    }\n    if (typeof eventList === \"function\") {\n      return [eventList.listener ?? eventList];\n    }\n    const ret = arrayClone(eventList);\n    for (let i = 0; i < ret.length; ++i) {\n      const orig = ret[i].listener;\n      if (typeof orig === \"function\") {\n        ret[i] = orig;\n      }\n    }\n    return ret;\n  }\n  rawListeners(eventName) {\n    const eventList = this._events[eventName];\n    if (eventList === void 0) {\n      return [];\n    }\n    if (typeof eventList === \"function\") {\n      return [eventList];\n    }\n    return arrayClone(eventList);\n  }\n  emit(eventName, ...args) {\n    let doError = eventName === \"error\";\n    const events = this._events;\n    if (events !== void 0) {\n      doError = doError && events.error === void 0;\n    } else if (!doError) {\n      return false;\n    }\n    if (doError) {\n      let er;\n      if (args.length > 0) {\n        er = args[0];\n      }\n      if (er instanceof Error) {\n        try {\n          const capture = {};\n          Error.captureStackTrace(capture, AsyncEventEmitter.prototype.emit);\n          Object.defineProperty(er, \"stack\", {\n            value: enhanceStackTrace.call(this, er, capture),\n            configurable: true\n          });\n        } catch {}\n        throw er; // Unhandled 'error' event\n      }\n      const stringifiedError = String(er);\n      const err = new Error(`Unhandled 'error' event emitted, received ${stringifiedError}`);\n      err.context = er;\n      throw err; // Unhandled 'error' event\n    }\n    const handlers = events[eventName];\n    if (handlers === void 0) {\n      return false;\n    }\n    if (typeof handlers === \"function\") {\n      const result = handlers.apply(this, args);\n      if (result !== void 0 && result !== null) {\n        handleMaybeAsync(this, result);\n      }\n    } else {\n      const len = handlers.length;\n      const listeners = arrayClone(handlers);\n      for (let i = 0; i < len; ++i) {\n        const result = listeners[i].apply(this, args);\n        if (result !== void 0 && result !== null) {\n          handleMaybeAsync(this, result);\n        }\n      }\n    }\n    return true;\n  }\n  listenerCount(eventName) {\n    const events = this._events;\n    if (events === void 0) {\n      return 0;\n    }\n    const eventListeners = events[eventName];\n    if (typeof eventListeners === \"function\") {\n      return 1;\n    }\n    return eventListeners?.length ?? 0;\n  }\n  prependListener(eventName, listener) {\n    validateListener(listener);\n    const wrapped = this._wrapListener(eventName, listener, false);\n    this._addListener(eventName, wrapped, true);\n    return this;\n  }\n  prependOnceListener(eventName, listener) {\n    validateListener(listener);\n    const wrapped = this._wrapListener(eventName, listener, true);\n    this._addListener(eventName, wrapped, true);\n    return this;\n  }\n  eventNames() {\n    return this._eventCount > 0 ? Reflect.ownKeys(this._events) : [];\n  }\n  async waitForAllListenersToComplete() {\n    const promises = [...this._internalPromiseMap.values()];\n    if (promises.length === 0) {\n      return false;\n    }\n    await Promise.all(promises);\n    return true;\n  }\n  _addListener(eventName, wrappedListener, prepend) {\n    if (this._events.newListener !== void 0) {\n      this.emit(\"newListener\", eventName, wrappedListener.listener ?? wrappedListener);\n    }\n    let existing = this._events[eventName];\n    if (existing === void 0) {\n      existing = this._events[eventName] = wrappedListener;\n      ++this._eventCount;\n    } else if (typeof existing === \"function\") {\n      existing = this._events[eventName] = prepend ? [wrappedListener, existing] : [existing, wrappedListener];\n    } else if (prepend) {\n      existing.unshift(wrappedListener);\n    } else {\n      existing.push(wrappedListener);\n    }\n    if (this._maxListeners > 0 && existing.length > this._maxListeners && !existing._hasWarnedAboutMaxListeners) {\n      existing._hasWarnedAboutMaxListeners = true;\n      const warningMessage = [`Possible AsyncEventEmitter memory leak detected. ${existing.length} ${String(eventName)} listeners added to ${this.constructor.name}.`, `Use emitter.setMaxListeners() to increase the limit.`].join(\" \");\n      console.warn(warningMessage);\n    }\n  }\n  _wrapListener(eventName, listener, once) {\n    if (!once) {\n      return listener;\n    }\n    const state = {\n      fired: false,\n      wrapFn: void 0,\n      eventEmitter: this,\n      eventName,\n      listener\n    };\n    const aliased = onceWrapper;\n    const wrapped = aliased.bind(state);\n    wrapped.listener = listener;\n    state.wrapFn = wrapped;\n    return wrapped;\n  }\n  static listenerCount(emitter, eventName) {\n    return emitter.listenerCount(eventName);\n  }\n  static async once(emitter, eventName, options = {}) {\n    const signal = options?.signal;\n    validateAbortSignal(signal);\n    if (signal?.aborted) {\n      throw new AbortError(void 0, {\n        cause: getReason(signal)\n      });\n    }\n    return new Promise((resolve, reject) => {\n      const errorListener = /* @__PURE__ */__name(err => {\n        emitter.removeListener(eventName, resolver);\n        if (signal) {\n          eventTargetAgnosticRemoveListener(emitter, eventName, abortListener);\n        }\n        reject(err);\n      }, \"errorListener\");\n      const resolver = /* @__PURE__ */__name((...args) => {\n        emitter.removeListener(\"error\", errorListener);\n        if (signal) {\n          eventTargetAgnosticRemoveListener(signal, \"abort\", abortListener);\n        }\n        resolve(args);\n      }, \"resolver\");\n      emitter.once(eventName, resolver);\n      if (eventName !== \"error\") {\n        emitter.once(\"error\", errorListener);\n      }\n      const abortListener = /* @__PURE__ */__name(() => {\n        eventTargetAgnosticRemoveListener(emitter, eventName, resolver);\n        eventTargetAgnosticRemoveListener(emitter, \"error\", errorListener);\n        reject(new AbortError(void 0, {\n          cause: getReason(signal)\n        }));\n      }, \"abortListener\");\n      if (signal) {\n        eventTargetAgnosticAddListener(signal, \"abort\", abortListener, {\n          once: true\n        });\n      }\n    });\n  }\n  static on(emitter, eventName, options = {}) {\n    const signal = options?.signal;\n    validateAbortSignal(signal);\n    if (signal?.aborted) {\n      throw new AbortError(void 0, {\n        cause: getReason(signal)\n      });\n    }\n    const unconsumedEvents = [];\n    const unconsumedPromises = [];\n    let error = null;\n    let finished = false;\n    const abortListener = /* @__PURE__ */__name(() => {\n      errorHandler(new AbortError(void 0, {\n        cause: getReason(signal)\n      }));\n    }, \"abortListener\");\n    const eventHandler = /* @__PURE__ */__name((...args) => {\n      const promise = unconsumedPromises.shift();\n      if (promise) {\n        promise.resolve(createIterResult(args, false));\n      } else {\n        unconsumedEvents.push(args);\n      }\n    }, \"eventHandler\");\n    const errorHandler = /* @__PURE__ */__name(err => {\n      finished = true;\n      const toError = unconsumedPromises.shift();\n      if (toError) {\n        toError.reject(err);\n      } else {\n        error = err;\n      }\n      void iterator.return();\n    }, \"errorHandler\");\n    const iterator = Object.setPrototypeOf({\n      next() {\n        const value = unconsumedEvents.shift();\n        if (value) {\n          return Promise.resolve(createIterResult(value, false));\n        }\n        if (error) {\n          const p = Promise.reject(error);\n          error = null;\n          return p;\n        }\n        if (finished) {\n          return Promise.resolve(createIterResult(void 0, true));\n        }\n        return new Promise((resolve, reject) => {\n          unconsumedPromises.push({\n            resolve,\n            reject\n          });\n        });\n      },\n      return() {\n        emitter.off(eventName, eventHandler);\n        emitter.off(\"error\", errorHandler);\n        if (signal) {\n          eventTargetAgnosticRemoveListener(signal, \"abort\", abortListener);\n        }\n        finished = true;\n        const doneResult = createIterResult(void 0, true);\n        for (const promise of unconsumedPromises) {\n          promise.resolve(doneResult);\n        }\n        return Promise.resolve(doneResult);\n      },\n      throw(err) {\n        if (!err || !(err instanceof Error)) {\n          throw new TypeError(`Expected Error instance to be thrown in AsyncEventEmitter.AsyncIterator. Got ${err}`);\n        }\n        error = err;\n        emitter.off(eventName, eventHandler);\n        emitter.off(\"error\", errorHandler);\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      }\n    }, AsyncIteratorPrototype);\n    emitter.on(eventName, eventHandler);\n    if (eventName !== \"error\") {\n      emitter.on(\"error\", errorHandler);\n    }\n    if (signal) {\n      eventTargetAgnosticAddListener(signal, \"abort\", abortListener);\n    }\n    return iterator;\n  }\n};\n__name(AsyncEventEmitter, \"AsyncEventEmitter\");\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.eventEmitter.removeListener(this.eventName, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0) {\n      return this.listener.call(this.eventEmitter);\n    }\n    return this.listener.apply(this.eventEmitter, arguments);\n  }\n}\n__name(onceWrapper, \"onceWrapper\");\nfunction getReason(signal) {\n  return signal?.reason;\n}\n__name(getReason, \"getReason\");\nfunction eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {\n  if (typeof emitter.off === \"function\") {\n    emitter.off(name, listener);\n  } else if (typeof emitter.removeEventListener === \"function\") {\n    emitter.removeEventListener(name, listener, flags);\n  }\n}\n__name(eventTargetAgnosticRemoveListener, \"eventTargetAgnosticRemoveListener\");\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === \"function\") {\n    if (flags?.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === \"function\") {\n    emitter.addEventListener(name, listener, flags);\n  }\n}\n__name(eventTargetAgnosticAddListener, \"eventTargetAgnosticAddListener\");\nvar AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {}).prototype);\nfunction createIterResult(value, done) {\n  return {\n    value,\n    done\n  };\n}\n__name(createIterResult, \"createIterResult\");\nvar AbortError = class extends Error {\n  constructor(message = \"The operation was aborted\", options = void 0) {\n    if (options !== void 0 && typeof options !== \"object\") {\n      throw new TypeError(`Failed to create AbortError: options is not an object or undefined`);\n    }\n    super(message, options);\n    this.code = \"ABORT_ERR\";\n    this.name = \"AbortError\";\n  }\n};\n__name(AbortError, \"AbortError\");\nfunction handleMaybeAsync(emitter, result) {\n  try {\n    const fin = result.finally;\n    if (typeof fin === \"function\") {\n      const promiseId = String(++emitter[\"_wrapperId\"]);\n      emitter[\"_internalPromiseMap\"].set(promiseId, result);\n      fin.call(result, /* @__PURE__ */__name(function final() {\n        emitter[\"_internalPromiseMap\"].delete(promiseId);\n      }, \"final\"));\n    }\n  } catch (err) {\n    emitter.emit(\"error\", err);\n  }\n}\n__name(handleMaybeAsync, \"handleMaybeAsync\");\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  AbortError,\n  AsyncEventEmitter\n});","map":{"version":3,"names":["src_exports","__export","AbortError","AsyncEventEmitter","module","exports","__toCommonJS","validateListener","input","TypeError","__name","validateAbortSignal","AbortSignal","spliceOne","list","index","length","pop","arrayClone","arr","slice","identicalSequenceRange","a","b","i","pos","indexOf","rest","len","maxLen","Math","min","enhanceStackTrace","err","own","ctorInfo","name","constructor","sep","errStack","stack","split","ownStack","off","splice","join","_events","__proto__","_eventCount","_maxListeners","_internalPromiseMap","Map","_wrapperId","addListener","eventName","listener","wrapped","_wrapListener","_addListener","on","once","removeListener","events","eventList","emit","position","shift","removeAllListeners","event","key","Reflect","ownKeys","listeners","setMaxListeners","n","Number","isNaN","RangeError","getMaxListeners","ret","orig","rawListeners","args","doError","error","er","Error","capture","captureStackTrace","prototype","Object","defineProperty","value","call","configurable","stringifiedError","String","context","handlers","result","apply","handleMaybeAsync","listenerCount","eventListeners","prependListener","prependOnceListener","eventNames","waitForAllListenersToComplete","promises","values","Promise","all","wrappedListener","prepend","newListener","existing","unshift","push","_hasWarnedAboutMaxListeners","warningMessage","console","warn","state","fired","wrapFn","eventEmitter","aliased","onceWrapper","bind","emitter","options","signal","aborted","cause","getReason","resolve","reject","errorListener","resolver","eventTargetAgnosticRemoveListener","abortListener","eventTargetAgnosticAddListener","unconsumedEvents","unconsumedPromises","finished","errorHandler","eventHandler","promise","createIterResult","toError","iterator","return","setPrototypeOf","next","p","doneResult","throw","Symbol","asyncIterator","AsyncIteratorPrototype","arguments","reason","flags","removeEventListener","addEventListener","getPrototypeOf","done","message","code","fin","finally","promiseId","set","final","delete"],"sources":["C:\\Users\\hetit\\node_modules\\@vladfrangu\\async_event_emitter\\src\\index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/dot-notation */\nfunction validateListener(input: unknown): asserts input is (...args: unknown[]) => Awaitable<void> {\n\tif (typeof input !== 'function') {\n\t\tthrow new TypeError(`The listener argument must be a function. Received ${typeof input}`);\n\t}\n}\n\nfunction validateAbortSignal(input: unknown): asserts input is AbortSignal | undefined {\n\t// Only validate that the signal is a signal if its defined\n\tif (input && !(input instanceof AbortSignal)) {\n\t\tthrow new TypeError(`The signal option must be an AbortSignal. Received ${input}`);\n\t}\n}\n\n// Inspired from https://github.com/nodejs/node/blob/42ad967d68137df1a80a877e7b5ad56403fc157f/lib/internal/util.js#L397\nfunction spliceOne(list: unknown[], index: number) {\n\tfor (; index + 1 < list.length; index++) {\n\t\tlist[index] = list[index + 1];\n\t}\n\n\tlist.pop();\n}\n\n// Inspired from https://github.com/nodejs/node/blob/42ad967d68137df1a80a877e7b5ad56403fc157f/lib/events.js#L889\nfunction arrayClone<T extends unknown[]>(arr: T): T {\n\t// At least since V8 8.3, this implementation is faster than the previous\n\t// which always used a simple for-loop\n\tswitch (arr.length) {\n\t\tcase 2:\n\t\t\treturn [arr[0], arr[1]] as T;\n\t\tcase 3:\n\t\t\treturn [arr[0], arr[1], arr[2]] as T;\n\t\tcase 4:\n\t\t\treturn [arr[0], arr[1], arr[2], arr[3]] as T;\n\t\tcase 5:\n\t\t\treturn [arr[0], arr[1], arr[2], arr[3], arr[4]] as T;\n\t\tcase 6:\n\t\t\treturn [arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]] as T;\n\t}\n\n\treturn arr.slice() as T;\n}\n\n// Inspired from https://github.com/nodejs/node/blob/42ad967d68137df1a80a877e7b5ad56403fc157f/lib/events.js#L427-L475\nfunction identicalSequenceRange(a: unknown[], b: unknown[]): [number, number] {\n\tfor (let i = 0; i < a.length - 3; i++) {\n\t\t// Find the first entry of b that matches the current entry of a.\n\t\tconst pos = b.indexOf(a[i]);\n\t\tif (pos !== -1) {\n\t\t\tconst rest = b.length - pos;\n\t\t\tif (rest > 3) {\n\t\t\t\tlet len = 1;\n\t\t\t\tconst maxLen = Math.min(a.length - i, rest);\n\t\t\t\t// Count the number of consecutive entries.\n\t\t\t\twhile (maxLen > len && a[i + len] === b[pos + len]) {\n\t\t\t\t\tlen++;\n\t\t\t\t}\n\t\t\t\tif (len > 3) {\n\t\t\t\t\treturn [len, i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [0, 0];\n}\n\nfunction enhanceStackTrace(this: AsyncEventEmitter<any>, err: Error, own: Error) {\n\tlet ctorInfo = '';\n\ttry {\n\t\tconst { name } = this.constructor;\n\t\tif (name !== 'AsyncEventEmitter') ctorInfo = ` on ${name} instance`;\n\t} catch {\n\t\t// Continue regardless of error.\n\t}\n\tconst sep = `\\nEmitted 'error' event${ctorInfo} at:\\n`;\n\n\tconst errStack = err.stack!.split('\\n').slice(1);\n\tconst ownStack = own.stack!.split('\\n').slice(1);\n\n\tconst { 0: len, 1: off } = identicalSequenceRange(ownStack, errStack);\n\tif (len > 0) {\n\t\townStack.splice(off + 1, len - 2, '    [... lines matching original stack trace ...]');\n\t}\n\n\treturn err.stack + sep + ownStack.join('\\n');\n}\n\ninterface InternalEventMap extends Array<Listener | WrappedOnce> {\n\t_hasWarnedAboutMaxListeners?: boolean;\n}\n\nexport class AsyncEventEmitter<Events extends Record<PropertyKey, unknown[]> = Record<PropertyKey, unknown[]> & AsyncEventEmitterPredefinedEvents> {\n\tprivate _events: Record<keyof Events | keyof AsyncEventEmitterPredefinedEvents, Listener | WrappedOnce | InternalEventMap> = {\n\t\t__proto__: null\n\t} as Record<keyof Events | keyof AsyncEventEmitterPredefinedEvents, Listener | WrappedOnce | InternalEventMap>;\n\n\tprivate _eventCount = 0;\n\tprivate _maxListeners = 10;\n\tprivate _internalPromiseMap: Map<string, Promise<void>> = new Map();\n\tprivate _wrapperId = 0n;\n\n\tpublic addListener<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(\n\t\teventName: K,\n\t\tlistener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => void\n\t): this {\n\t\tvalidateListener(listener);\n\n\t\tconst wrapped = this._wrapListener(eventName, listener, false);\n\n\t\tthis._addListener(eventName, wrapped, false);\n\n\t\treturn this;\n\t}\n\n\tpublic on<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(\n\t\teventName: K,\n\t\tlistener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => void\n\t): this {\n\t\treturn this.addListener(eventName, listener);\n\t}\n\n\tpublic once<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(\n\t\teventName: K,\n\t\tlistener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => void\n\t): this {\n\t\tvalidateListener(listener);\n\n\t\tconst wrapped = this._wrapListener(eventName, listener, true);\n\n\t\tthis._addListener(eventName, wrapped, false);\n\n\t\treturn this;\n\t}\n\n\tpublic removeListener<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(\n\t\teventName: K,\n\t\tlistener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => void\n\t): this {\n\t\tvalidateListener(listener);\n\n\t\tconst events = this._events;\n\t\tconst eventList = events[eventName];\n\n\t\tif (eventList === undefined) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (eventList === listener || (eventList as WrappedOnce).listener === listener) {\n\t\t\tif (--this._eventCount === 0) {\n\t\t\t\tthis._events = { __proto__: null } as Record<\n\t\t\t\t\tkeyof Events | keyof AsyncEventEmitterPredefinedEvents,\n\t\t\t\t\tListener | WrappedOnce | InternalEventMap\n\t\t\t\t>;\n\t\t\t} else {\n\t\t\t\tdelete events[eventName];\n\t\t\t\tif (events.removeListener) {\n\t\t\t\t\tthis.emit('removeListener', eventName as string, (eventList as WrappedOnce).listener ?? eventList);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (typeof eventList !== 'function') {\n\t\t\tlet position = -1;\n\n\t\t\tfor (let i = eventList.length - 1; i >= 0; i--) {\n\t\t\t\tif (eventList[i] === listener || (eventList[i] as WrappedOnce).listener === listener) {\n\t\t\t\t\tposition = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (position < 0) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (position === 0) {\n\t\t\t\teventList.shift();\n\t\t\t} else {\n\t\t\t\tspliceOne(eventList, position);\n\t\t\t}\n\n\t\t\tif (eventList.length === 0) {\n\t\t\t\tdelete events[eventName];\n\t\t\t\t--this._eventCount;\n\t\t\t}\n\n\t\t\tif (events.removeListener !== undefined) {\n\t\t\t\t// Thanks TypeScript for the cast...\n\t\t\t\tthis.emit('removeListener', eventName as string | symbol, listener);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tpublic off<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(\n\t\teventName: K,\n\t\tlistener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => void\n\t): this {\n\t\treturn this.removeListener(eventName, listener);\n\t}\n\n\tpublic removeAllListeners<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(event?: K | undefined): this {\n\t\tconst events = this._events;\n\n\t\t// Not listening for removeListener, no need to emit\n\t\tif (events.removeListener === undefined) {\n\t\t\tif (!event) {\n\t\t\t\tthis._events = { __proto__: null } as Record<keyof Events | keyof AsyncEventEmitterPredefinedEvents, InternalEventMap>;\n\t\t\t\tthis._eventCount = 0;\n\t\t\t} else if (events[event] !== undefined) {\n\t\t\t\tif (--this._eventCount === 0) {\n\t\t\t\t\tthis._events = { __proto__: null } as Record<keyof Events | keyof AsyncEventEmitterPredefinedEvents, InternalEventMap>;\n\t\t\t\t} else {\n\t\t\t\t\tdelete events[event];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\t// Emit removeListener for all listeners on all events\n\t\tif (!event) {\n\t\t\tfor (const key of Reflect.ownKeys(events)) {\n\t\t\t\tif (key === 'removeListener') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthis.removeAllListeners(key);\n\t\t\t}\n\n\t\t\tthis.removeAllListeners('removeListener');\n\t\t\tthis._events = { __proto__: null } as Record<keyof Events | keyof AsyncEventEmitterPredefinedEvents, InternalEventMap>;\n\t\t\tthis._eventCount = 0;\n\n\t\t\treturn this;\n\t\t}\n\n\t\tconst listeners = events[event];\n\n\t\tif (typeof listeners === 'function') {\n\t\t\tthis.removeListener(event, listeners);\n\t\t} else if (listeners !== undefined) {\n\t\t\t// LIFO order\n\t\t\tfor (let i = listeners.length - 1; i >= 0; i--) {\n\t\t\t\tthis.removeListener(event, listeners[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tpublic setMaxListeners(n: number): this {\n\t\tif (typeof n !== 'number' || n < 0 || Number.isNaN(n)) {\n\t\t\tthrow new RangeError(`Expected to get a non-negative number for \"setMaxListeners\", got ${n} instead`);\n\t\t}\n\n\t\tthis._maxListeners = n;\n\n\t\treturn this;\n\t}\n\n\tpublic getMaxListeners(): number {\n\t\treturn this._maxListeners;\n\t}\n\n\tpublic listeners<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(eventName: K): Listener<Events[keyof Events]>['listener'][] {\n\t\tconst eventList = this._events[eventName];\n\n\t\tif (eventList === undefined) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif (typeof eventList === 'function') {\n\t\t\treturn [eventList.listener ?? eventList];\n\t\t}\n\n\t\tconst ret = arrayClone(eventList) as Listener<Events[keyof Events]>['listener'][];\n\n\t\tfor (let i = 0; i < ret.length; ++i) {\n\t\t\tconst orig = (ret[i] as WrappedOnce).listener;\n\t\t\tif (typeof orig === 'function') {\n\t\t\t\tret[i] = orig;\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tpublic rawListeners<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(eventName: K): Listener<Events[keyof Events]>[] {\n\t\tconst eventList = this._events[eventName];\n\n\t\tif (eventList === undefined) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif (typeof eventList === 'function') {\n\t\t\treturn [eventList];\n\t\t}\n\n\t\treturn arrayClone(eventList) as Listener<Events[keyof Events]>[];\n\t}\n\n\tpublic emit<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(\n\t\teventName: K,\n\t\t...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]\n\t): boolean {\n\t\tlet doError = eventName === 'error';\n\n\t\tconst events = this._events;\n\t\tif (events !== undefined) {\n\t\t\tdoError = doError && events.error === undefined;\n\t\t} else if (!doError) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (doError) {\n\t\t\tlet er: unknown;\n\n\t\t\tif (args.length > 0) {\n\t\t\t\t// eslint-disable-next-line prefer-destructuring\n\t\t\t\ter = args[0];\n\t\t\t}\n\n\t\t\tif (er instanceof Error) {\n\t\t\t\ttry {\n\t\t\t\t\tconst capture = {};\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\t\t\t\t\tError.captureStackTrace(capture, AsyncEventEmitter.prototype.emit);\n\t\t\t\t\tObject.defineProperty(er, 'stack', {\n\t\t\t\t\t\tvalue: enhanceStackTrace.call(this, er, capture as Error),\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t});\n\t\t\t\t} catch {\n\t\t\t\t\t// Continue regardless of error\n\t\t\t\t}\n\n\t\t\t\tthrow er; // Unhandled 'error' event\n\t\t\t}\n\n\t\t\tconst stringifiedError = String(er);\n\n\t\t\t// Give some error to user\n\t\t\tconst err = new Error(`Unhandled 'error' event emitted, received ${stringifiedError}`);\n\t\t\t// @ts-expect-error Add context to error too\n\t\t\terr.context = er;\n\n\t\t\tthrow err; // Unhandled 'error' event\n\t\t}\n\n\t\tconst handlers = events[eventName];\n\n\t\tif (handlers === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof handlers === 'function') {\n\t\t\tconst result = handlers.apply(this, args);\n\n\t\t\tif (result !== undefined && result !== null) {\n\t\t\t\thandleMaybeAsync(this, result);\n\t\t\t}\n\t\t} else {\n\t\t\tconst len = handlers.length;\n\t\t\tconst listeners = arrayClone(handlers as InternalEventMap);\n\n\t\t\tfor (let i = 0; i < len; ++i) {\n\t\t\t\t// We call all listeners regardless of the result, as we already handle possible error emits in the wrapped func\n\t\t\t\tconst result = listeners[i].apply(this, args);\n\n\t\t\t\tif (result !== undefined && result !== null) {\n\t\t\t\t\thandleMaybeAsync(this, result);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic listenerCount<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(eventName: K): number {\n\t\tconst events = this._events;\n\n\t\tif (events === undefined) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst eventListeners = events[eventName];\n\n\t\tif (typeof eventListeners === 'function') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn eventListeners?.length ?? 0;\n\t}\n\n\tpublic prependListener<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(\n\t\teventName: K,\n\t\tlistener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => void\n\t): this {\n\t\tvalidateListener(listener);\n\n\t\tconst wrapped = this._wrapListener(eventName, listener, false);\n\n\t\tthis._addListener(eventName, wrapped, true);\n\n\t\treturn this;\n\t}\n\n\tpublic prependOnceListener<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(\n\t\teventName: K,\n\t\tlistener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => void\n\t): this {\n\t\tvalidateListener(listener);\n\n\t\tconst wrapped = this._wrapListener(eventName, listener, true);\n\n\t\tthis._addListener(eventName, wrapped, true);\n\n\t\treturn this;\n\t}\n\n\tpublic eventNames(): (keyof Events | keyof AsyncEventEmitterPredefinedEvents)[] {\n\t\treturn this._eventCount > 0 ? Reflect.ownKeys(this._events) : [];\n\t}\n\n\tpublic async waitForAllListenersToComplete() {\n\t\tconst promises = [...this._internalPromiseMap.values()];\n\n\t\tif (promises.length === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tawait Promise.all(promises);\n\n\t\treturn true;\n\t}\n\n\tprivate _addListener<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(\n\t\teventName: K,\n\t\twrappedListener: Listener | WrappedOnce,\n\t\tprepend: boolean\n\t) {\n\t\t// Emit newListener first in the event someone is listening for it\n\t\tif (this._events.newListener !== undefined) {\n\t\t\t// Thanks TypeScript for the cast...\n\t\t\tthis.emit('newListener', eventName as string | symbol, (wrappedListener as WrappedOnce).listener ?? wrappedListener);\n\t\t}\n\n\t\tlet existing = this._events[eventName];\n\n\t\tif (existing === undefined) {\n\t\t\t// eslint-disable-next-line no-multi-assign\n\t\t\texisting = this._events[eventName] = wrappedListener;\n\t\t\t++this._eventCount;\n\t\t} else if (typeof existing === 'function') {\n\t\t\t// Adding the second element, need to change to array.\n\t\t\t// eslint-disable-next-line no-multi-assign\n\t\t\texisting = this._events[eventName] = prepend ? [wrappedListener, existing] : [existing, wrappedListener];\n\t\t\t// If we've already got an array, just append.\n\t\t} else if (prepend) {\n\t\t\texisting.unshift(wrappedListener);\n\t\t} else {\n\t\t\texisting.push(wrappedListener);\n\t\t}\n\n\t\tif (this._maxListeners > 0 && existing.length > this._maxListeners && !existing._hasWarnedAboutMaxListeners) {\n\t\t\texisting._hasWarnedAboutMaxListeners = true;\n\t\t\tconst warningMessage = [\n\t\t\t\t`Possible AsyncEventEmitter memory leak detected. ${existing.length} ${String(eventName)} listeners added to ${\n\t\t\t\t\tthis.constructor.name\n\t\t\t\t}.`,\n\t\t\t\t`Use emitter.setMaxListeners() to increase the limit.`\n\t\t\t].join(' ');\n\t\t\tconsole.warn(warningMessage);\n\t\t}\n\t}\n\n\tprivate _wrapListener<K extends keyof Events | keyof AsyncEventEmitterPredefinedEvents>(\n\t\teventName: K,\n\t\tlistener: (...args: K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]) => Awaitable<void>,\n\t\tonce: boolean\n\t): Listener | WrappedOnce {\n\t\tif (!once) {\n\t\t\treturn listener as Listener;\n\t\t}\n\n\t\tconst state = {\n\t\t\tfired: false,\n\t\t\twrapFn: undefined!,\n\t\t\teventEmitter: this,\n\t\t\teventName,\n\t\t\tlistener\n\t\t} as WrappedOnceState<K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]>;\n\n\t\tconst aliased = onceWrapper<K extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]>;\n\n\t\tconst wrapped = aliased.bind(state) as WrappedOnce<\n\t\t\tK extends keyof AsyncEventEmitterPredefinedEvents ? AsyncEventEmitterPredefinedEvents[K] : Events[K]\n\t\t>;\n\t\twrapped.listener = listener;\n\t\tstate.wrapFn = wrapped;\n\n\t\treturn wrapped as WrappedOnce;\n\t}\n\n\tpublic static listenerCount<\n\t\tEmitter extends AsyncEventEmitter<any>,\n\t\tEventNames = Emitter extends AsyncEventEmitter<infer Events> ? Events : never,\n\t\tEventName extends PropertyKey = EventNames extends never ? string | symbol : keyof EventNames\n\t>(emitter: Emitter, eventName: EventName | keyof AsyncEventEmitterPredefinedEvents) {\n\t\treturn emitter.listenerCount(eventName);\n\t}\n\n\tpublic static async once<\n\t\tEmitter extends AsyncEventEmitter<any>,\n\t\tEventNames extends Record<PropertyKey, unknown[]> = Emitter extends AsyncEventEmitter<infer Events> ? Events : Record<PropertyKey, unknown[]>,\n\t\tEventName extends PropertyKey = keyof EventNames | keyof AsyncEventEmitterPredefinedEvents,\n\t\tEventResult extends unknown[] = EventName extends keyof AsyncEventEmitterPredefinedEvents\n\t\t\t? AsyncEventEmitterPredefinedEvents[EventName]\n\t\t\t: EventNames[EventName]\n\t>(emitter: Emitter, eventName: EventName, options: AbortableMethods = {}) {\n\t\tconst signal = options?.signal;\n\t\tvalidateAbortSignal(signal);\n\n\t\tif (signal?.aborted) {\n\t\t\tthrow new AbortError(undefined, { cause: getReason(signal) });\n\t\t}\n\n\t\treturn new Promise<EventResult>((resolve, reject) => {\n\t\t\tconst errorListener = (err: unknown) => {\n\t\t\t\temitter.removeListener(eventName, resolver);\n\n\t\t\t\tif (signal) {\n\t\t\t\t\teventTargetAgnosticRemoveListener(emitter, eventName, abortListener);\n\t\t\t\t}\n\n\t\t\t\treject(err);\n\t\t\t};\n\n\t\t\tconst resolver = (...args: unknown[]) => {\n\t\t\t\temitter.removeListener('error', errorListener);\n\n\t\t\t\tif (signal) {\n\t\t\t\t\teventTargetAgnosticRemoveListener(signal, 'abort', abortListener);\n\t\t\t\t}\n\n\t\t\t\tresolve(args as EventResult);\n\t\t\t};\n\n\t\t\temitter.once(eventName, resolver);\n\t\t\tif (eventName !== 'error') {\n\t\t\t\temitter.once('error', errorListener);\n\t\t\t}\n\n\t\t\tconst abortListener = () => {\n\t\t\t\teventTargetAgnosticRemoveListener(emitter, eventName, resolver);\n\t\t\t\teventTargetAgnosticRemoveListener(emitter, 'error', errorListener);\n\t\t\t\treject(new AbortError(undefined, { cause: getReason(signal) }));\n\t\t\t};\n\n\t\t\tif (signal) {\n\t\t\t\teventTargetAgnosticAddListener(signal, 'abort', abortListener, { once: true });\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic static on<\n\t\tEmitter extends AsyncEventEmitter<any>,\n\t\tEventNames extends Record<PropertyKey, unknown[]> = Emitter extends AsyncEventEmitter<infer Events> ? Events : Record<PropertyKey, unknown[]>,\n\t\tEventName extends PropertyKey = keyof EventNames | keyof AsyncEventEmitterPredefinedEvents,\n\t\tEventResult extends unknown[] = EventName extends keyof AsyncEventEmitterPredefinedEvents\n\t\t\t? AsyncEventEmitterPredefinedEvents[EventName]\n\t\t\t: EventNames[EventName]\n\t>(emitter: Emitter, eventName: EventName, options: AbortableMethods = {}): AsyncGenerator<EventResult, void> {\n\t\tconst signal = options?.signal;\n\t\tvalidateAbortSignal(signal);\n\n\t\tif (signal?.aborted) {\n\t\t\tthrow new AbortError(undefined, { cause: getReason(signal) });\n\t\t}\n\n\t\tconst unconsumedEvents: unknown[][] = [];\n\t\tconst unconsumedPromises: { resolve: (value?: unknown) => void; reject: (reason?: unknown) => void }[] = [];\n\t\tlet error: unknown = null;\n\t\tlet finished = false;\n\n\t\tconst abortListener = () => {\n\t\t\terrorHandler(new AbortError(undefined, { cause: getReason(signal) }));\n\t\t};\n\n\t\tconst eventHandler = (...args: unknown[]) => {\n\t\t\tconst promise = unconsumedPromises.shift();\n\t\t\tif (promise) {\n\t\t\t\tpromise.resolve(createIterResult(args, false));\n\t\t\t} else {\n\t\t\t\tunconsumedEvents.push(args);\n\t\t\t}\n\t\t};\n\n\t\tconst errorHandler = (err: unknown) => {\n\t\t\tfinished = true;\n\n\t\t\tconst toError = unconsumedPromises.shift();\n\n\t\t\tif (toError) {\n\t\t\t\ttoError.reject(err);\n\t\t\t} else {\n\t\t\t\terror = err;\n\t\t\t}\n\n\t\t\tvoid iterator.return();\n\t\t};\n\n\t\tconst iterator: AsyncGenerator<EventResult, void> = Object.setPrototypeOf(\n\t\t\t{\n\t\t\t\tnext() {\n\t\t\t\t\t// First, we consume all unread events\n\t\t\t\t\tconst value = unconsumedEvents.shift();\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\treturn Promise.resolve(createIterResult(value, false));\n\t\t\t\t\t}\n\n\t\t\t\t\t// Then we error, if an error happened\n\t\t\t\t\t// This happens one time if at all, because after 'error'\n\t\t\t\t\t// we stop listening\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tconst p = Promise.reject(error);\n\t\t\t\t\t\t// Only the first element errors\n\t\t\t\t\t\terror = null;\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the iterator is finished, resolve to done\n\t\t\t\t\tif (finished) {\n\t\t\t\t\t\treturn Promise.resolve(createIterResult(undefined, true));\n\t\t\t\t\t}\n\n\t\t\t\t\t// Wait until an event happens\n\t\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\t\tunconsumedPromises.push({ resolve, reject });\n\t\t\t\t\t});\n\t\t\t\t},\n\n\t\t\t\treturn() {\n\t\t\t\t\temitter.off(eventName, eventHandler);\n\t\t\t\t\temitter.off('error', errorHandler);\n\n\t\t\t\t\tif (signal) {\n\t\t\t\t\t\teventTargetAgnosticRemoveListener(signal, 'abort', abortListener);\n\t\t\t\t\t}\n\n\t\t\t\t\tfinished = true;\n\n\t\t\t\t\tconst doneResult = createIterResult(undefined, true);\n\t\t\t\t\tfor (const promise of unconsumedPromises) {\n\t\t\t\t\t\tpromise.resolve(doneResult);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Promise.resolve(doneResult);\n\t\t\t\t},\n\n\t\t\t\tthrow(err: unknown) {\n\t\t\t\t\tif (!err || !(err instanceof Error)) {\n\t\t\t\t\t\tthrow new TypeError(`Expected Error instance to be thrown in AsyncEventEmitter.AsyncIterator. Got ${err}`);\n\t\t\t\t\t}\n\n\t\t\t\t\terror = err;\n\t\t\t\t\temitter.off(eventName, eventHandler);\n\t\t\t\t\temitter.off('error', errorHandler);\n\t\t\t\t},\n\n\t\t\t\t[Symbol.asyncIterator]() {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t},\n\t\t\tAsyncIteratorPrototype\n\t\t);\n\n\t\temitter.on(eventName, eventHandler);\n\t\tif (eventName !== 'error') {\n\t\t\temitter.on('error', errorHandler);\n\t\t}\n\n\t\tif (signal) {\n\t\t\teventTargetAgnosticAddListener(signal, 'abort', abortListener);\n\t\t}\n\n\t\treturn iterator;\n\t}\n}\n\nexport interface AsyncEventEmitterPredefinedEvents {\n\tnewListener: [eventName: string | symbol, listener: (...args: any[]) => Awaitable<void>];\n\tremoveListener: [eventName: string | symbol, listener: (...args: any[]) => Awaitable<void>];\n}\n\ninterface WrappedOnceState<Args extends any[] = any[]> {\n\tlistener: (...args: Args) => Awaitable<void>;\n\tfired: boolean;\n\teventName: string | symbol;\n\teventEmitter: AsyncEventEmitter<any>;\n\twrapFn: (...args: Args) => Awaitable<void>;\n}\n\nexport interface WrappedOnce<Args extends any[] = any[]> {\n\t(...args: Args): Awaitable<void>;\n\tlistener: (...args: Args) => Awaitable<void>;\n\t_hasWarnedAboutMaxListeners?: boolean;\n}\n\nexport interface Listener<Args extends any[] = any[]> {\n\t(...args: Args): Awaitable<void>;\n\tlistener: (...args: Args) => Awaitable<void>;\n\t_hasWarnedAboutMaxListeners?: boolean;\n}\n\nexport type Awaitable<T> = T | Promise<T>;\n\nexport interface AbortableMethods {\n\tsignal?: AbortSignal;\n}\n\n// @ts-ignore Not all paths returning is fine just fine:tm:\nfunction onceWrapper<Args extends any[] = any[]>(this: WrappedOnceState<Args>) {\n\tif (!this.fired) {\n\t\tthis.eventEmitter.removeListener(this.eventName, this.wrapFn);\n\t\tthis.fired = true;\n\t\t// eslint-disable-next-line @typescript-eslint/dot-notation\n\t\tif (arguments.length === 0) {\n\t\t\t// @ts-expect-error Types can be hell\n\t\t\treturn this.listener.call(this.eventEmitter);\n\t\t}\n\n\t\t// eslint-disable-next-line prefer-rest-params\n\t\treturn this.listener.apply(this.eventEmitter, arguments as unknown as Args);\n\t}\n}\n\n/**\n * A TypeScript not-compliant way of accessing AbortSignal#reason\n * Because DOM types have it, NodeJS types don't. -w-\n */\nfunction getReason(signal: any) {\n\treturn signal?.reason;\n}\n\nfunction eventTargetAgnosticRemoveListener(emitter: any, name: PropertyKey, listener: (...args: unknown[]) => any, flags?: InternalAgnosticFlags) {\n\tif (typeof emitter.off === 'function') {\n\t\temitter.off(name, listener);\n\t} else if (typeof emitter.removeEventListener === 'function') {\n\t\temitter.removeEventListener(name, listener, flags);\n\t}\n}\n\nfunction eventTargetAgnosticAddListener(emitter: any, name: string | symbol, listener: (...args: unknown[]) => any, flags?: InternalAgnosticFlags) {\n\tif (typeof emitter.on === 'function') {\n\t\tif (flags?.once) {\n\t\t\temitter.once!(name, listener);\n\t\t} else {\n\t\t\temitter.on(name, listener);\n\t\t}\n\t} else if (typeof emitter.addEventListener === 'function') {\n\t\temitter.addEventListener(name, listener, flags);\n\t}\n}\n\ninterface InternalAgnosticFlags {\n\tonce?: boolean;\n}\n\n// eslint-disable-next-line func-names, @typescript-eslint/no-empty-function\nconst AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {}).prototype);\n\nfunction createIterResult(value: unknown, done: boolean) {\n\treturn { value, done };\n}\n\nexport interface AbortErrorOptions {\n\tcause?: unknown;\n}\n\nexport class AbortError extends Error {\n\tpublic readonly code = 'ABORT_ERR';\n\tpublic override readonly name = 'AbortError';\n\n\tpublic constructor(message = 'The operation was aborted', options: AbortErrorOptions | undefined = undefined) {\n\t\tif (options !== undefined && typeof options !== 'object') {\n\t\t\tthrow new TypeError(`Failed to create AbortError: options is not an object or undefined`);\n\t\t}\n\n\t\tsuper(message, options);\n\t}\n}\n\nfunction handleMaybeAsync(emitter: AsyncEventEmitter<any>, result: any) {\n\ttry {\n\t\tconst fin = result.finally;\n\n\t\tif (typeof fin === 'function') {\n\t\t\tconst promiseId = String(++emitter['_wrapperId']);\n\t\t\temitter['_internalPromiseMap'].set(promiseId, result);\n\t\t\tfin.call(result, function final() {\n\t\t\t\temitter['_internalPromiseMap'].delete(promiseId);\n\t\t\t});\n\t\t}\n\t} catch (err) {\n\t\temitter.emit('error', err);\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}