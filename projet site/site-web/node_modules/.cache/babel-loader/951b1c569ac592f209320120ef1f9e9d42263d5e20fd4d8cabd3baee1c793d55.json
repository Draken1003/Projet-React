{"ast":null,"code":"'use strict';\n\nconst {\n  Routes\n} = require('discord-api-types/v10');\nconst User = require('./User');\nconst DataResolver = require('../util/DataResolver');\n\n/**\n * Represents the logged in client's Discord user.\n * @extends {User}\n */\nclass ClientUser extends User {\n  _patch(data) {\n    super._patch(data);\n    if ('verified' in data) {\n      /**\n       * Whether or not this account has been verified\n       * @type {boolean}\n       */\n      this.verified = data.verified;\n    }\n    if ('mfa_enabled' in data) {\n      /**\n       * If the bot's {@link ClientApplication#owner Owner} has MFA enabled on their account\n       * @type {?boolean}\n       */\n      this.mfaEnabled = typeof data.mfa_enabled === 'boolean' ? data.mfa_enabled : null;\n    } else {\n      this.mfaEnabled ??= null;\n    }\n    if ('token' in data) this.client.token = data.token;\n  }\n\n  /**\n   * Represents the client user's presence\n   * @type {ClientPresence}\n   * @readonly\n   */\n  get presence() {\n    return this.client.presence;\n  }\n\n  /**\n   * Data used to edit the logged in client\n   * @typedef {Object} ClientUserEditOptions\n   * @property {string} [username] The new username\n   * @property {?(BufferResolvable|Base64Resolvable)} [avatar] The new avatar\n   */\n\n  /**\n   * Edits the logged in client.\n   * @param {ClientUserEditOptions} options The options to provide\n   * @returns {Promise<ClientUser>}\n   */\n  async edit({\n    username,\n    avatar\n  }) {\n    const data = await this.client.rest.patch(Routes.user(), {\n      body: {\n        username,\n        avatar: avatar && (await DataResolver.resolveImage(avatar))\n      }\n    });\n    this.client.token = data.token;\n    this.client.rest.setToken(data.token);\n    const {\n      updated\n    } = this.client.actions.UserUpdate.handle(data);\n    return updated ?? this;\n  }\n\n  /**\n   * Sets the username of the logged in client.\n   * <info>Changing usernames in Discord is heavily rate limited, with only 2 requests\n   * every hour. Use this sparingly!</info>\n   * @param {string} username The new username\n   * @returns {Promise<ClientUser>}\n   * @example\n   * // Set username\n   * client.user.setUsername('discordjs')\n   *   .then(user => console.log(`My new username is ${user.username}`))\n   *   .catch(console.error);\n   */\n  setUsername(username) {\n    return this.edit({\n      username\n    });\n  }\n\n  /**\n   * Sets the avatar of the logged in client.\n   * @param {?(BufferResolvable|Base64Resolvable)} avatar The new avatar\n   * @returns {Promise<ClientUser>}\n   * @example\n   * // Set avatar\n   * client.user.setAvatar('./avatar.png')\n   *   .then(user => console.log(`New avatar set!`))\n   *   .catch(console.error);\n   */\n  setAvatar(avatar) {\n    return this.edit({\n      avatar\n    });\n  }\n\n  /**\n   * Options for setting activities\n   * @typedef {Object} ActivitiesOptions\n   * @property {string} name Name of the activity\n   * @property {string} [state] State of the activity\n   * @property {ActivityType} [type] Type of the activity\n   * @property {string} [url] Twitch / YouTube stream URL\n   */\n\n  /**\n   * Data resembling a raw Discord presence.\n   * @typedef {Object} PresenceData\n   * @property {PresenceStatusData} [status] Status of the user\n   * @property {boolean} [afk] Whether the user is AFK\n   * @property {ActivitiesOptions[]} [activities] Activity the user is playing\n   * @property {number|number[]} [shardId] Shard id(s) to have the activity set on\n   */\n\n  /**\n   * Sets the full presence of the client user.\n   * @param {PresenceData} data Data for the presence\n   * @returns {ClientPresence}\n   * @example\n   * // Set the client user's presence\n   * client.user.setPresence({ activities: [{ name: 'with discord.js' }], status: 'idle' });\n   */\n  setPresence(data) {\n    return this.client.presence.set(data);\n  }\n\n  /**\n   * A user's status. Must be one of:\n   * * `online`\n   * * `idle`\n   * * `invisible`\n   * * `dnd` (do not disturb)\n   * @typedef {string} PresenceStatusData\n   */\n\n  /**\n   * Sets the status of the client user.\n   * @param {PresenceStatusData} status Status to change to\n   * @param {number|number[]} [shardId] Shard id(s) to have the activity set on\n   * @returns {ClientPresence}\n   * @example\n   * // Set the client user's status\n   * client.user.setStatus('idle');\n   */\n  setStatus(status, shardId) {\n    return this.setPresence({\n      status,\n      shardId\n    });\n  }\n\n  /**\n   * Options for setting an activity.\n   * @typedef {Object} ActivityOptions\n   * @property {string} name Name of the activity\n   * @property {string} [state] State of the activity\n   * @property {string} [url] Twitch / YouTube stream URL\n   * @property {ActivityType} [type] Type of the activity\n   * @property {number|number[]} [shardId] Shard Id(s) to have the activity set on\n   */\n\n  /**\n   * Sets the activity the client user is playing.\n   * @param {string|ActivityOptions} name Activity being played, or options for setting the activity\n   * @param {ActivityOptions} [options] Options for setting the activity\n   * @returns {ClientPresence}\n   * @example\n   * // Set the client user's activity\n   * client.user.setActivity('discord.js', { type: ActivityType.Watching });\n   */\n  setActivity(name, options = {}) {\n    if (!name) return this.setPresence({\n      activities: [],\n      shardId: options.shardId\n    });\n    const activity = Object.assign({}, options, typeof name === 'object' ? name : {\n      name\n    });\n    return this.setPresence({\n      activities: [activity],\n      shardId: activity.shardId\n    });\n  }\n\n  /**\n   * Sets/removes the AFK flag for the client user.\n   * @param {boolean} [afk=true] Whether or not the user is AFK\n   * @param {number|number[]} [shardId] Shard Id(s) to have the AFK flag set on\n   * @returns {ClientPresence}\n   */\n  setAFK(afk = true, shardId) {\n    return this.setPresence({\n      afk,\n      shardId\n    });\n  }\n}\nmodule.exports = ClientUser;","map":{"version":3,"names":["Routes","require","User","DataResolver","ClientUser","_patch","data","verified","mfaEnabled","mfa_enabled","client","token","presence","edit","username","avatar","rest","patch","user","body","resolveImage","setToken","updated","actions","UserUpdate","handle","setUsername","setAvatar","setPresence","set","setStatus","status","shardId","setActivity","name","options","activities","activity","Object","assign","setAFK","afk","module","exports"],"sources":["C:/Users/hetit/node_modules/discord.js/src/structures/ClientUser.js"],"sourcesContent":["'use strict';\n\nconst { Routes } = require('discord-api-types/v10');\nconst User = require('./User');\nconst DataResolver = require('../util/DataResolver');\n\n/**\n * Represents the logged in client's Discord user.\n * @extends {User}\n */\nclass ClientUser extends User {\n  _patch(data) {\n    super._patch(data);\n\n    if ('verified' in data) {\n      /**\n       * Whether or not this account has been verified\n       * @type {boolean}\n       */\n      this.verified = data.verified;\n    }\n\n    if ('mfa_enabled' in data) {\n      /**\n       * If the bot's {@link ClientApplication#owner Owner} has MFA enabled on their account\n       * @type {?boolean}\n       */\n      this.mfaEnabled = typeof data.mfa_enabled === 'boolean' ? data.mfa_enabled : null;\n    } else {\n      this.mfaEnabled ??= null;\n    }\n\n    if ('token' in data) this.client.token = data.token;\n  }\n\n  /**\n   * Represents the client user's presence\n   * @type {ClientPresence}\n   * @readonly\n   */\n  get presence() {\n    return this.client.presence;\n  }\n\n  /**\n   * Data used to edit the logged in client\n   * @typedef {Object} ClientUserEditOptions\n   * @property {string} [username] The new username\n   * @property {?(BufferResolvable|Base64Resolvable)} [avatar] The new avatar\n   */\n\n  /**\n   * Edits the logged in client.\n   * @param {ClientUserEditOptions} options The options to provide\n   * @returns {Promise<ClientUser>}\n   */\n  async edit({ username, avatar }) {\n    const data = await this.client.rest.patch(Routes.user(), {\n      body: { username, avatar: avatar && (await DataResolver.resolveImage(avatar)) },\n    });\n\n    this.client.token = data.token;\n    this.client.rest.setToken(data.token);\n    const { updated } = this.client.actions.UserUpdate.handle(data);\n    return updated ?? this;\n  }\n\n  /**\n   * Sets the username of the logged in client.\n   * <info>Changing usernames in Discord is heavily rate limited, with only 2 requests\n   * every hour. Use this sparingly!</info>\n   * @param {string} username The new username\n   * @returns {Promise<ClientUser>}\n   * @example\n   * // Set username\n   * client.user.setUsername('discordjs')\n   *   .then(user => console.log(`My new username is ${user.username}`))\n   *   .catch(console.error);\n   */\n  setUsername(username) {\n    return this.edit({ username });\n  }\n\n  /**\n   * Sets the avatar of the logged in client.\n   * @param {?(BufferResolvable|Base64Resolvable)} avatar The new avatar\n   * @returns {Promise<ClientUser>}\n   * @example\n   * // Set avatar\n   * client.user.setAvatar('./avatar.png')\n   *   .then(user => console.log(`New avatar set!`))\n   *   .catch(console.error);\n   */\n  setAvatar(avatar) {\n    return this.edit({ avatar });\n  }\n\n  /**\n   * Options for setting activities\n   * @typedef {Object} ActivitiesOptions\n   * @property {string} name Name of the activity\n   * @property {string} [state] State of the activity\n   * @property {ActivityType} [type] Type of the activity\n   * @property {string} [url] Twitch / YouTube stream URL\n   */\n\n  /**\n   * Data resembling a raw Discord presence.\n   * @typedef {Object} PresenceData\n   * @property {PresenceStatusData} [status] Status of the user\n   * @property {boolean} [afk] Whether the user is AFK\n   * @property {ActivitiesOptions[]} [activities] Activity the user is playing\n   * @property {number|number[]} [shardId] Shard id(s) to have the activity set on\n   */\n\n  /**\n   * Sets the full presence of the client user.\n   * @param {PresenceData} data Data for the presence\n   * @returns {ClientPresence}\n   * @example\n   * // Set the client user's presence\n   * client.user.setPresence({ activities: [{ name: 'with discord.js' }], status: 'idle' });\n   */\n  setPresence(data) {\n    return this.client.presence.set(data);\n  }\n\n  /**\n   * A user's status. Must be one of:\n   * * `online`\n   * * `idle`\n   * * `invisible`\n   * * `dnd` (do not disturb)\n   * @typedef {string} PresenceStatusData\n   */\n\n  /**\n   * Sets the status of the client user.\n   * @param {PresenceStatusData} status Status to change to\n   * @param {number|number[]} [shardId] Shard id(s) to have the activity set on\n   * @returns {ClientPresence}\n   * @example\n   * // Set the client user's status\n   * client.user.setStatus('idle');\n   */\n  setStatus(status, shardId) {\n    return this.setPresence({ status, shardId });\n  }\n\n  /**\n   * Options for setting an activity.\n   * @typedef {Object} ActivityOptions\n   * @property {string} name Name of the activity\n   * @property {string} [state] State of the activity\n   * @property {string} [url] Twitch / YouTube stream URL\n   * @property {ActivityType} [type] Type of the activity\n   * @property {number|number[]} [shardId] Shard Id(s) to have the activity set on\n   */\n\n  /**\n   * Sets the activity the client user is playing.\n   * @param {string|ActivityOptions} name Activity being played, or options for setting the activity\n   * @param {ActivityOptions} [options] Options for setting the activity\n   * @returns {ClientPresence}\n   * @example\n   * // Set the client user's activity\n   * client.user.setActivity('discord.js', { type: ActivityType.Watching });\n   */\n  setActivity(name, options = {}) {\n    if (!name) return this.setPresence({ activities: [], shardId: options.shardId });\n\n    const activity = Object.assign({}, options, typeof name === 'object' ? name : { name });\n    return this.setPresence({ activities: [activity], shardId: activity.shardId });\n  }\n\n  /**\n   * Sets/removes the AFK flag for the client user.\n   * @param {boolean} [afk=true] Whether or not the user is AFK\n   * @param {number|number[]} [shardId] Shard Id(s) to have the AFK flag set on\n   * @returns {ClientPresence}\n   */\n  setAFK(afk = true, shardId) {\n    return this.setPresence({ afk, shardId });\n  }\n}\n\nmodule.exports = ClientUser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}