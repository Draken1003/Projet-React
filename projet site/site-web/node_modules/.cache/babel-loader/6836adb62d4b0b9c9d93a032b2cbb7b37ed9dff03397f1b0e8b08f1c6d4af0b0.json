{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('node:events');\nconst {\n  setTimeout,\n  clearTimeout\n} = require('node:timers');\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../../errors');\nconst {\n  flatten\n} = require('../../util/Util');\n\n/**\n * Filter to be applied to the collector.\n * @typedef {Function} CollectorFilter\n * @param {...*} args Any arguments received by the listener\n * @param {Collection} collection The items collected by this collector\n * @returns {boolean|Promise<boolean>}\n */\n\n/**\n * Options to be applied to the collector.\n * @typedef {Object} CollectorOptions\n * @property {CollectorFilter} [filter] The filter applied to this collector\n * @property {number} [time] How long to run the collector for in milliseconds\n * @property {number} [idle] How long to stop the collector after inactivity in milliseconds\n * @property {boolean} [dispose=false] Whether to dispose data when it's deleted\n */\n\n/**\n * Abstract class for defining a new Collector.\n * @extends {EventEmitter}\n * @abstract\n */\nclass Collector extends EventEmitter {\n  constructor(client, options = {}) {\n    super();\n\n    /**\n     * The client that instantiated this Collector\n     * @name Collector#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n\n    /**\n     * The filter applied to this collector\n     * @type {CollectorFilter}\n     * @returns {boolean|Promise<boolean>}\n     */\n    this.filter = options.filter ?? (() => true);\n\n    /**\n     * The options of this collector\n     * @type {CollectorOptions}\n     */\n    this.options = options;\n\n    /**\n     * The items collected by this collector\n     * @type {Collection}\n     */\n    this.collected = new Collection();\n\n    /**\n     * Whether this collector has finished collecting\n     * @type {boolean}\n     */\n    this.ended = false;\n\n    /**\n     * Timeout for cleanup\n     * @type {?Timeout}\n     * @private\n     */\n    this._timeout = null;\n\n    /**\n     * Timeout for cleanup due to inactivity\n     * @type {?Timeout}\n     * @private\n     */\n    this._idletimeout = null;\n\n    /**\n     * The reason the collector ended\n     * @type {string|null}\n     * @private\n     */\n    this._endReason = null;\n    if (typeof this.filter !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'options.filter', 'function');\n    }\n    this.handleCollect = this.handleCollect.bind(this);\n    this.handleDispose = this.handleDispose.bind(this);\n    if (options.time) this._timeout = setTimeout(() => this.stop('time'), options.time).unref();\n    if (options.idle) this._idletimeout = setTimeout(() => this.stop('idle'), options.idle).unref();\n\n    /**\n     * The timestamp at which this collector last collected an item\n     * @type {?number}\n     */\n    this.lastCollectedTimestamp = null;\n  }\n\n  /**\n   * The Date at which this collector last collected an item\n   * @type {?Date}\n   */\n  get lastCollectedAt() {\n    return this.lastCollectedTimestamp && new Date(this.lastCollectedTimestamp);\n  }\n\n  /**\n   * Call this to handle an event as a collectable element. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @returns {Promise<void>}\n   * @emits Collector#collect\n   */\n  async handleCollect(...args) {\n    const collectedId = await this.collect(...args);\n    if (collectedId) {\n      const filterResult = await this.filter(...args, this.collected);\n      if (filterResult) {\n        this.collected.set(collectedId, args[0]);\n\n        /**\n         * Emitted whenever an element is collected.\n         * @event Collector#collect\n         * @param {...*} args The arguments emitted by the listener\n         */\n        this.emit('collect', ...args);\n        this.lastCollectedTimestamp = Date.now();\n        if (this._idletimeout) {\n          clearTimeout(this._idletimeout);\n          this._idletimeout = setTimeout(() => this.stop('idle'), this.options.idle).unref();\n        }\n      } else {\n        /**\n         * Emitted whenever an element is not collected by the collector.\n         * @event Collector#ignore\n         * @param {...*} args The arguments emitted by the listener\n         */\n        this.emit('ignore', ...args);\n      }\n    }\n    this.checkEnd();\n  }\n\n  /**\n   * Call this to remove an element from the collection. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @returns {Promise<void>}\n   * @emits Collector#dispose\n   */\n  async handleDispose(...args) {\n    if (!this.options.dispose) return;\n    const dispose = this.dispose(...args);\n    if (!dispose || !(await this.filter(...args)) || !this.collected.has(dispose)) return;\n    this.collected.delete(dispose);\n\n    /**\n     * Emitted whenever an element is disposed of.\n     * @event Collector#dispose\n     * @param {...*} args The arguments emitted by the listener\n     */\n    this.emit('dispose', ...args);\n    this.checkEnd();\n  }\n\n  /**\n   * Returns a promise that resolves with the next collected element;\n   * rejects with collected elements if the collector finishes without receiving a next element\n   * @type {Promise}\n   * @readonly\n   */\n  get next() {\n    return new Promise((resolve, reject) => {\n      if (this.ended) {\n        reject(this.collected);\n        return;\n      }\n      const cleanup = () => {\n        this.removeListener('collect', onCollect);\n        this.removeListener('end', onEnd);\n      };\n      const onCollect = item => {\n        cleanup();\n        resolve(item);\n      };\n      const onEnd = () => {\n        cleanup();\n        reject(this.collected);\n      };\n      this.on('collect', onCollect);\n      this.on('end', onEnd);\n    });\n  }\n\n  /**\n   * Stops this collector and emits the `end` event.\n   * @param {string} [reason='user'] The reason this collector is ending\n   * @emits Collector#end\n   */\n  stop(reason = 'user') {\n    if (this.ended) return;\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = null;\n    }\n    if (this._idletimeout) {\n      clearTimeout(this._idletimeout);\n      this._idletimeout = null;\n    }\n    this._endReason = reason;\n    this.ended = true;\n\n    /**\n     * Emitted when the collector is finished collecting.\n     * @event Collector#end\n     * @param {Collection} collected The elements collected by the collector\n     * @param {string} reason The reason the collector ended\n     */\n    this.emit('end', this.collected, reason);\n  }\n\n  /**\n   * Options used to reset the timeout and idle timer of a {@link Collector}.\n   * @typedef {Object} CollectorResetTimerOptions\n   * @property {number} [time] How long to run the collector for (in milliseconds)\n   * @property {number} [idle] How long to wait to stop the collector after inactivity (in milliseconds)\n   */\n\n  /**\n   * Resets the collector's timeout and idle timer.\n   * @param {CollectorResetTimerOptions} [options] Options for resetting\n   */\n  resetTimer({\n    time,\n    idle\n  } = {}) {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = setTimeout(() => this.stop('time'), time ?? this.options.time).unref();\n    }\n    if (this._idletimeout) {\n      clearTimeout(this._idletimeout);\n      this._idletimeout = setTimeout(() => this.stop('idle'), idle ?? this.options.idle).unref();\n    }\n  }\n\n  /**\n   * Checks whether the collector should end, and if so, ends it.\n   * @returns {boolean} Whether the collector ended or not\n   */\n  checkEnd() {\n    const reason = this.endReason;\n    if (reason) this.stop(reason);\n    return Boolean(reason);\n  }\n\n  /**\n   * Allows collectors to be consumed with for-await-of loops\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of}\n   */\n  async *[Symbol.asyncIterator]() {\n    const queue = [];\n    const onCollect = (...item) => queue.push(item);\n    this.on('collect', onCollect);\n    try {\n      while (queue.length || !this.ended) {\n        if (queue.length) {\n          yield queue.shift();\n        } else {\n          // eslint-disable-next-line no-await-in-loop\n          await new Promise(resolve => {\n            const tick = () => {\n              this.removeListener('collect', tick);\n              this.removeListener('end', tick);\n              return resolve();\n            };\n            this.on('collect', tick);\n            this.on('end', tick);\n          });\n        }\n      }\n    } finally {\n      this.removeListener('collect', onCollect);\n    }\n  }\n  toJSON() {\n    return flatten(this);\n  }\n\n  /* eslint-disable no-empty-function */\n  /**\n   * The reason this collector has ended with, or null if it hasn't ended yet\n   * @type {?string}\n   * @readonly\n   */\n  get endReason() {\n    return this._endReason;\n  }\n\n  /**\n   * Handles incoming events from the `handleCollect` function. Returns null if the event should not\n   * be collected, or returns an object describing the data that should be stored.\n   * @see Collector#handleCollect\n   * @param {...*} args Any args the event listener emits\n   * @returns {?(*|Promise<?*>)} Data to insert into collection, if any\n   * @abstract\n   */\n  collect() {}\n\n  /**\n   * Handles incoming events from the `handleDispose`. Returns null if the event should not\n   * be disposed, or returns the key that should be removed.\n   * @see Collector#handleDispose\n   * @param {...*} args Any args the event listener emits\n   * @returns {?*} Key to remove from the collection, if any\n   * @abstract\n   */\n  dispose() {}\n  /* eslint-enable no-empty-function */\n}\nmodule.exports = Collector;","map":{"version":3,"names":["EventEmitter","require","setTimeout","clearTimeout","Collection","DiscordjsTypeError","ErrorCodes","flatten","Collector","constructor","client","options","Object","defineProperty","value","filter","collected","ended","_timeout","_idletimeout","_endReason","InvalidType","handleCollect","bind","handleDispose","time","stop","unref","idle","lastCollectedTimestamp","lastCollectedAt","Date","args","collectedId","collect","filterResult","set","emit","now","checkEnd","dispose","has","delete","next","Promise","resolve","reject","cleanup","removeListener","onCollect","onEnd","item","on","reason","resetTimer","endReason","Boolean","Symbol","asyncIterator","queue","push","length","shift","tick","toJSON","module","exports"],"sources":["C:/Users/hetit/node_modules/discord.js/src/structures/interfaces/Collector.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('node:events');\nconst { setTimeout, clearTimeout } = require('node:timers');\nconst { Collection } = require('@discordjs/collection');\nconst { DiscordjsTypeError, ErrorCodes } = require('../../errors');\nconst { flatten } = require('../../util/Util');\n\n/**\n * Filter to be applied to the collector.\n * @typedef {Function} CollectorFilter\n * @param {...*} args Any arguments received by the listener\n * @param {Collection} collection The items collected by this collector\n * @returns {boolean|Promise<boolean>}\n */\n\n/**\n * Options to be applied to the collector.\n * @typedef {Object} CollectorOptions\n * @property {CollectorFilter} [filter] The filter applied to this collector\n * @property {number} [time] How long to run the collector for in milliseconds\n * @property {number} [idle] How long to stop the collector after inactivity in milliseconds\n * @property {boolean} [dispose=false] Whether to dispose data when it's deleted\n */\n\n/**\n * Abstract class for defining a new Collector.\n * @extends {EventEmitter}\n * @abstract\n */\nclass Collector extends EventEmitter {\n  constructor(client, options = {}) {\n    super();\n\n    /**\n     * The client that instantiated this Collector\n     * @name Collector#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', { value: client });\n\n    /**\n     * The filter applied to this collector\n     * @type {CollectorFilter}\n     * @returns {boolean|Promise<boolean>}\n     */\n    this.filter = options.filter ?? (() => true);\n\n    /**\n     * The options of this collector\n     * @type {CollectorOptions}\n     */\n    this.options = options;\n\n    /**\n     * The items collected by this collector\n     * @type {Collection}\n     */\n    this.collected = new Collection();\n\n    /**\n     * Whether this collector has finished collecting\n     * @type {boolean}\n     */\n    this.ended = false;\n\n    /**\n     * Timeout for cleanup\n     * @type {?Timeout}\n     * @private\n     */\n    this._timeout = null;\n\n    /**\n     * Timeout for cleanup due to inactivity\n     * @type {?Timeout}\n     * @private\n     */\n    this._idletimeout = null;\n\n    /**\n     * The reason the collector ended\n     * @type {string|null}\n     * @private\n     */\n    this._endReason = null;\n\n    if (typeof this.filter !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'options.filter', 'function');\n    }\n\n    this.handleCollect = this.handleCollect.bind(this);\n    this.handleDispose = this.handleDispose.bind(this);\n\n    if (options.time) this._timeout = setTimeout(() => this.stop('time'), options.time).unref();\n    if (options.idle) this._idletimeout = setTimeout(() => this.stop('idle'), options.idle).unref();\n\n    /**\n     * The timestamp at which this collector last collected an item\n     * @type {?number}\n     */\n    this.lastCollectedTimestamp = null;\n  }\n\n  /**\n   * The Date at which this collector last collected an item\n   * @type {?Date}\n   */\n  get lastCollectedAt() {\n    return this.lastCollectedTimestamp && new Date(this.lastCollectedTimestamp);\n  }\n\n  /**\n   * Call this to handle an event as a collectable element. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @returns {Promise<void>}\n   * @emits Collector#collect\n   */\n  async handleCollect(...args) {\n    const collectedId = await this.collect(...args);\n\n    if (collectedId) {\n      const filterResult = await this.filter(...args, this.collected);\n      if (filterResult) {\n        this.collected.set(collectedId, args[0]);\n\n        /**\n         * Emitted whenever an element is collected.\n         * @event Collector#collect\n         * @param {...*} args The arguments emitted by the listener\n         */\n        this.emit('collect', ...args);\n\n        this.lastCollectedTimestamp = Date.now();\n        if (this._idletimeout) {\n          clearTimeout(this._idletimeout);\n          this._idletimeout = setTimeout(() => this.stop('idle'), this.options.idle).unref();\n        }\n      } else {\n        /**\n         * Emitted whenever an element is not collected by the collector.\n         * @event Collector#ignore\n         * @param {...*} args The arguments emitted by the listener\n         */\n        this.emit('ignore', ...args);\n      }\n    }\n    this.checkEnd();\n  }\n\n  /**\n   * Call this to remove an element from the collection. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @returns {Promise<void>}\n   * @emits Collector#dispose\n   */\n  async handleDispose(...args) {\n    if (!this.options.dispose) return;\n\n    const dispose = this.dispose(...args);\n    if (!dispose || !(await this.filter(...args)) || !this.collected.has(dispose)) return;\n    this.collected.delete(dispose);\n\n    /**\n     * Emitted whenever an element is disposed of.\n     * @event Collector#dispose\n     * @param {...*} args The arguments emitted by the listener\n     */\n    this.emit('dispose', ...args);\n    this.checkEnd();\n  }\n\n  /**\n   * Returns a promise that resolves with the next collected element;\n   * rejects with collected elements if the collector finishes without receiving a next element\n   * @type {Promise}\n   * @readonly\n   */\n  get next() {\n    return new Promise((resolve, reject) => {\n      if (this.ended) {\n        reject(this.collected);\n        return;\n      }\n\n      const cleanup = () => {\n        this.removeListener('collect', onCollect);\n        this.removeListener('end', onEnd);\n      };\n\n      const onCollect = item => {\n        cleanup();\n        resolve(item);\n      };\n\n      const onEnd = () => {\n        cleanup();\n        reject(this.collected);\n      };\n\n      this.on('collect', onCollect);\n      this.on('end', onEnd);\n    });\n  }\n\n  /**\n   * Stops this collector and emits the `end` event.\n   * @param {string} [reason='user'] The reason this collector is ending\n   * @emits Collector#end\n   */\n  stop(reason = 'user') {\n    if (this.ended) return;\n\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = null;\n    }\n    if (this._idletimeout) {\n      clearTimeout(this._idletimeout);\n      this._idletimeout = null;\n    }\n\n    this._endReason = reason;\n    this.ended = true;\n\n    /**\n     * Emitted when the collector is finished collecting.\n     * @event Collector#end\n     * @param {Collection} collected The elements collected by the collector\n     * @param {string} reason The reason the collector ended\n     */\n    this.emit('end', this.collected, reason);\n  }\n\n  /**\n   * Options used to reset the timeout and idle timer of a {@link Collector}.\n   * @typedef {Object} CollectorResetTimerOptions\n   * @property {number} [time] How long to run the collector for (in milliseconds)\n   * @property {number} [idle] How long to wait to stop the collector after inactivity (in milliseconds)\n   */\n\n  /**\n   * Resets the collector's timeout and idle timer.\n   * @param {CollectorResetTimerOptions} [options] Options for resetting\n   */\n  resetTimer({ time, idle } = {}) {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = setTimeout(() => this.stop('time'), time ?? this.options.time).unref();\n    }\n    if (this._idletimeout) {\n      clearTimeout(this._idletimeout);\n      this._idletimeout = setTimeout(() => this.stop('idle'), idle ?? this.options.idle).unref();\n    }\n  }\n\n  /**\n   * Checks whether the collector should end, and if so, ends it.\n   * @returns {boolean} Whether the collector ended or not\n   */\n  checkEnd() {\n    const reason = this.endReason;\n    if (reason) this.stop(reason);\n    return Boolean(reason);\n  }\n\n  /**\n   * Allows collectors to be consumed with for-await-of loops\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of}\n   */\n  async *[Symbol.asyncIterator]() {\n    const queue = [];\n    const onCollect = (...item) => queue.push(item);\n    this.on('collect', onCollect);\n\n    try {\n      while (queue.length || !this.ended) {\n        if (queue.length) {\n          yield queue.shift();\n        } else {\n          // eslint-disable-next-line no-await-in-loop\n          await new Promise(resolve => {\n            const tick = () => {\n              this.removeListener('collect', tick);\n              this.removeListener('end', tick);\n              return resolve();\n            };\n            this.on('collect', tick);\n            this.on('end', tick);\n          });\n        }\n      }\n    } finally {\n      this.removeListener('collect', onCollect);\n    }\n  }\n\n  toJSON() {\n    return flatten(this);\n  }\n\n  /* eslint-disable no-empty-function */\n  /**\n   * The reason this collector has ended with, or null if it hasn't ended yet\n   * @type {?string}\n   * @readonly\n   */\n  get endReason() {\n    return this._endReason;\n  }\n\n  /**\n   * Handles incoming events from the `handleCollect` function. Returns null if the event should not\n   * be collected, or returns an object describing the data that should be stored.\n   * @see Collector#handleCollect\n   * @param {...*} args Any args the event listener emits\n   * @returns {?(*|Promise<?*>)} Data to insert into collection, if any\n   * @abstract\n   */\n  collect() {}\n\n  /**\n   * Handles incoming events from the `handleDispose`. Returns null if the event should not\n   * be disposed, or returns the key that should be removed.\n   * @see Collector#handleDispose\n   * @param {...*} args Any args the event listener emits\n   * @returns {?*} Key to remove from the collection, if any\n   * @abstract\n   */\n  dispose() {}\n  /* eslint-enable no-empty-function */\n}\n\nmodule.exports = Collector;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}