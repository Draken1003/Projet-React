{"ast":null,"code":"'use strict';\n\nconst {\n  messageLink\n} = require('@discordjs/builders');\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  DiscordSnowflake\n} = require('@sapphire/snowflake');\nconst {\n  InteractionType,\n  ChannelType,\n  MessageType,\n  MessageFlags,\n  PermissionFlagsBits\n} = require('discord-api-types/v10');\nconst Attachment = require('./Attachment');\nconst Base = require('./Base');\nconst ClientApplication = require('./ClientApplication');\nconst Embed = require('./Embed');\nconst InteractionCollector = require('./InteractionCollector');\nconst Mentions = require('./MessageMentions');\nconst MessagePayload = require('./MessagePayload');\nconst ReactionCollector = require('./ReactionCollector');\nconst {\n  Sticker\n} = require('./Sticker');\nconst {\n  DiscordjsError,\n  ErrorCodes\n} = require('../errors');\nconst ReactionManager = require('../managers/ReactionManager');\nconst {\n  createComponent\n} = require('../util/Components');\nconst {\n  NonSystemMessageTypes,\n  MaxBulkDeletableMessageAge,\n  DeletableMessageTypes\n} = require('../util/Constants');\nconst MessageFlagsBitField = require('../util/MessageFlagsBitField');\nconst PermissionsBitField = require('../util/PermissionsBitField');\nconst {\n  cleanContent,\n  resolvePartialEmoji\n} = require('../util/Util');\n\n/**\n * Represents a message on Discord.\n * @extends {Base}\n */\nclass Message extends Base {\n  constructor(client, data) {\n    super(client);\n\n    /**\n     * The id of the channel the message was sent in\n     * @type {Snowflake}\n     */\n    this.channelId = data.channel_id;\n\n    /**\n     * The id of the guild the message was sent in, if any\n     * @type {?Snowflake}\n     */\n    this.guildId = data.guild_id ?? this.channel?.guild?.id ?? null;\n    this._patch(data);\n  }\n  _patch(data) {\n    /**\n     * The message's id\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    /**\n     * The timestamp the message was sent at\n     * @type {number}\n     */\n    this.createdTimestamp = DiscordSnowflake.timestampFrom(this.id);\n    if ('type' in data) {\n      /**\n       * The type of the message\n       * @type {?MessageType}\n       */\n      this.type = data.type;\n\n      /**\n       * Whether or not this message was sent by Discord, not actually a user (e.g. pin notifications)\n       * @type {?boolean}\n       */\n      this.system = !NonSystemMessageTypes.includes(this.type);\n    } else {\n      this.system ??= null;\n      this.type ??= null;\n    }\n    if ('content' in data) {\n      /**\n       * The content of the message.\n       * <info>This property requires the {@link GatewayIntentBits.MessageContent} privileged intent\n       * in a guild for messages that do not mention the client.</info>\n       * @type {?string}\n       */\n      this.content = data.content;\n    } else {\n      this.content ??= null;\n    }\n    if ('author' in data) {\n      /**\n       * The author of the message\n       * @type {?User}\n       */\n      this.author = this.client.users._add(data.author, !data.webhook_id);\n    } else {\n      this.author ??= null;\n    }\n    if ('pinned' in data) {\n      /**\n       * Whether or not this message is pinned\n       * @type {?boolean}\n       */\n      this.pinned = Boolean(data.pinned);\n    } else {\n      this.pinned ??= null;\n    }\n    if ('tts' in data) {\n      /**\n       * Whether or not the message was Text-To-Speech\n       * @type {?boolean}\n       */\n      this.tts = data.tts;\n    } else {\n      this.tts ??= null;\n    }\n    if ('nonce' in data) {\n      /**\n       * A random number or string used for checking message delivery\n       * <warn>This is only received after the message was sent successfully, and\n       * lost if re-fetched</warn>\n       * @type {?string}\n       */\n      this.nonce = data.nonce;\n    } else {\n      this.nonce ??= null;\n    }\n    if ('embeds' in data) {\n      /**\n       * An array of embeds in the message - e.g. YouTube Player.\n       * <info>This property requires the {@link GatewayIntentBits.MessageContent} privileged intent\n       * in a guild for messages that do not mention the client.</info>\n       * @type {Embed[]}\n       */\n      this.embeds = data.embeds.map(e => new Embed(e));\n    } else {\n      this.embeds = this.embeds?.slice() ?? [];\n    }\n    if ('components' in data) {\n      /**\n       * An array of of action rows in the message.\n       * <info>This property requires the {@link GatewayIntentBits.MessageContent} privileged intent\n       * in a guild for messages that do not mention the client.</info>\n       * @type {ActionRow[]}\n       */\n      this.components = data.components.map(c => createComponent(c));\n    } else {\n      this.components = this.components?.slice() ?? [];\n    }\n    if ('attachments' in data) {\n      /**\n       * A collection of attachments in the message - e.g. Pictures - mapped by their ids.\n       * <info>This property requires the {@link GatewayIntentBits.MessageContent} privileged intent\n       * in a guild for messages that do not mention the client.</info>\n       * @type {Collection<Snowflake, Attachment>}\n       */\n      this.attachments = new Collection();\n      if (data.attachments) {\n        for (const attachment of data.attachments) {\n          this.attachments.set(attachment.id, new Attachment(attachment));\n        }\n      }\n    } else {\n      this.attachments = new Collection(this.attachments);\n    }\n    if ('sticker_items' in data || 'stickers' in data) {\n      /**\n       * A collection of stickers in the message\n       * @type {Collection<Snowflake, Sticker>}\n       */\n      this.stickers = new Collection((data.sticker_items ?? data.stickers)?.map(s => [s.id, new Sticker(this.client, s)]));\n    } else {\n      this.stickers = new Collection(this.stickers);\n    }\n    if ('position' in data) {\n      /**\n       * A generally increasing integer (there may be gaps or duplicates) that represents\n       * the approximate position of the message in a thread.\n       * @type {?number}\n       */\n      this.position = data.position;\n    } else {\n      this.position ??= null;\n    }\n    if ('role_subscription_data' in data) {\n      /**\n       * Role subscription data found on {@link MessageType.RoleSubscriptionPurchase} messages.\n       * @typedef {Object} RoleSubscriptionData\n       * @property {Snowflake} roleSubscriptionListingId The id of the SKU and listing the user is subscribed to\n       * @property {string} tierName The name of the tier the user is subscribed to\n       * @property {number} totalMonthsSubscribed The total number of months the user has been subscribed for\n       * @property {boolean} isRenewal Whether this notification is a renewal\n       */\n\n      /**\n       * The data of the role subscription purchase or renewal.\n       * <info>This is present on {@link MessageType.RoleSubscriptionPurchase} messages.</info>\n       * @type {?RoleSubscriptionData}\n       */\n      this.roleSubscriptionData = {\n        roleSubscriptionListingId: data.role_subscription_data.role_subscription_listing_id,\n        tierName: data.role_subscription_data.tier_name,\n        totalMonthsSubscribed: data.role_subscription_data.total_months_subscribed,\n        isRenewal: data.role_subscription_data.is_renewal\n      };\n    } else {\n      this.roleSubscriptionData ??= null;\n    }\n\n    // Discord sends null if the message has not been edited\n    if (data.edited_timestamp) {\n      /**\n       * The timestamp the message was last edited at (if applicable)\n       * @type {?number}\n       */\n      this.editedTimestamp = Date.parse(data.edited_timestamp);\n    } else {\n      this.editedTimestamp ??= null;\n    }\n    if ('reactions' in data) {\n      /**\n       * A manager of the reactions belonging to this message\n       * @type {ReactionManager}\n       */\n      this.reactions = new ReactionManager(this);\n      if (data.reactions?.length > 0) {\n        for (const reaction of data.reactions) {\n          this.reactions._add(reaction);\n        }\n      }\n    } else {\n      this.reactions ??= new ReactionManager(this);\n    }\n    if (!this.mentions) {\n      /**\n       * All valid mentions that the message contains\n       * @type {MessageMentions}\n       */\n      this.mentions = new Mentions(this, data.mentions, data.mention_roles, data.mention_everyone, data.mention_channels, data.referenced_message?.author);\n    } else {\n      this.mentions = new Mentions(this, data.mentions ?? this.mentions.users, data.mention_roles ?? this.mentions.roles, data.mention_everyone ?? this.mentions.everyone, data.mention_channels ?? this.mentions.crosspostedChannels, data.referenced_message?.author ?? this.mentions.repliedUser);\n    }\n    if ('webhook_id' in data) {\n      /**\n       * The id of the webhook that sent the message, if applicable\n       * @type {?Snowflake}\n       */\n      this.webhookId = data.webhook_id;\n    } else {\n      this.webhookId ??= null;\n    }\n    if ('application' in data) {\n      /**\n       * Supplemental application information for group activities\n       * @type {?ClientApplication}\n       */\n      this.groupActivityApplication = new ClientApplication(this.client, data.application);\n    } else {\n      this.groupActivityApplication ??= null;\n    }\n    if ('application_id' in data) {\n      /**\n       * The id of the application of the interaction that sent this message, if any\n       * @type {?Snowflake}\n       */\n      this.applicationId = data.application_id;\n    } else {\n      this.applicationId ??= null;\n    }\n    if ('activity' in data) {\n      /**\n       * Group activity\n       * @type {?MessageActivity}\n       */\n      this.activity = {\n        partyId: data.activity.party_id,\n        type: data.activity.type\n      };\n    } else {\n      this.activity ??= null;\n    }\n    if ('thread' in data) {\n      this.client.channels._add(data.thread, this.guild);\n    }\n    if (this.member && data.member) {\n      this.member._patch(data.member);\n    } else if (data.member && this.guild && this.author) {\n      this.guild.members._add(Object.assign(data.member, {\n        user: this.author\n      }));\n    }\n    if ('flags' in data) {\n      /**\n       * Flags that are applied to the message\n       * @type {Readonly<MessageFlagsBitField>}\n       */\n      this.flags = new MessageFlagsBitField(data.flags).freeze();\n    } else {\n      this.flags = new MessageFlagsBitField(this.flags).freeze();\n    }\n\n    /**\n     * Reference data sent in a message that contains ids identifying the referenced message.\n     * This can be present in the following types of message:\n     * * Crossposted messages (`MessageFlags.Crossposted`)\n     * * {@link MessageType.ChannelFollowAdd}\n     * * {@link MessageType.ChannelPinnedMessage}\n     * * {@link MessageType.Reply}\n     * * {@link MessageType.ThreadStarterMessage}\n     * @see {@link https://discord.com/developers/docs/resources/channel#message-types}\n     * @typedef {Object} MessageReference\n     * @property {Snowflake} channelId The channel's id the message was referenced\n     * @property {?Snowflake} guildId The guild's id the message was referenced\n     * @property {?Snowflake} messageId The message's id that was referenced\n     */\n\n    if ('message_reference' in data) {\n      /**\n       * Message reference data\n       * @type {?MessageReference}\n       */\n      this.reference = {\n        channelId: data.message_reference.channel_id,\n        guildId: data.message_reference.guild_id,\n        messageId: data.message_reference.message_id\n      };\n    } else {\n      this.reference ??= null;\n    }\n    if (data.referenced_message) {\n      this.channel?.messages._add({\n        guild_id: data.message_reference?.guild_id,\n        ...data.referenced_message\n      });\n    }\n\n    /**\n     * Partial data of the interaction that a message is a reply to\n     * @typedef {Object} MessageInteraction\n     * @property {Snowflake} id The interaction's id\n     * @property {InteractionType} type The type of the interaction\n     * @property {string} commandName The name of the interaction's application command,\n     * as well as the subcommand and subcommand group, where applicable\n     * @property {User} user The user that invoked the interaction\n     */\n\n    if (data.interaction) {\n      /**\n       * Partial data of the interaction that this message is a reply to\n       * @type {?MessageInteraction}\n       */\n      this.interaction = {\n        id: data.interaction.id,\n        type: data.interaction.type,\n        commandName: data.interaction.name,\n        user: this.client.users._add(data.interaction.user)\n      };\n    } else {\n      this.interaction ??= null;\n    }\n  }\n\n  /**\n   * The channel that the message was sent in\n   * @type {TextBasedChannels}\n   * @readonly\n   */\n  get channel() {\n    return this.client.channels.resolve(this.channelId);\n  }\n\n  /**\n   * Whether or not this message is a partial\n   * @type {boolean}\n   * @readonly\n   */\n  get partial() {\n    return typeof this.content !== 'string' || !this.author;\n  }\n\n  /**\n   * Represents the author of the message as a guild member.\n   * Only available if the message comes from a guild where the author is still a member\n   * @type {?GuildMember}\n   * @readonly\n   */\n  get member() {\n    return this.guild?.members.resolve(this.author) ?? null;\n  }\n\n  /**\n   * The time the message was sent at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The time the message was last edited at (if applicable)\n   * @type {?Date}\n   * @readonly\n   */\n  get editedAt() {\n    return this.editedTimestamp && new Date(this.editedTimestamp);\n  }\n\n  /**\n   * The guild the message was sent in (if in a guild channel)\n   * @type {?Guild}\n   * @readonly\n   */\n  get guild() {\n    return this.client.guilds.resolve(this.guildId) ?? this.channel?.guild ?? null;\n  }\n\n  /**\n   * Whether this message has a thread associated with it\n   * @type {boolean}\n   * @readonly\n   */\n  get hasThread() {\n    return this.flags.has(MessageFlags.HasThread);\n  }\n\n  /**\n   * The thread started by this message\n   * <info>This property is not suitable for checking whether a message has a thread,\n   * use {@link Message#hasThread} instead.</info>\n   * @type {?ThreadChannel}\n   * @readonly\n   */\n  get thread() {\n    return this.channel?.threads?.resolve(this.id) ?? null;\n  }\n\n  /**\n   * The URL to jump to this message\n   * @type {string}\n   * @readonly\n   */\n  get url() {\n    return this.inGuild() ? messageLink(this.channelId, this.id, this.guildId) : messageLink(this.channelId, this.id);\n  }\n\n  /**\n   * The message contents with all mentions replaced by the equivalent text.\n   * If mentions cannot be resolved to a name, the relevant mention in the message content will not be converted.\n   * @type {?string}\n   * @readonly\n   */\n  get cleanContent() {\n    // eslint-disable-next-line eqeqeq\n    return this.content != null ? cleanContent(this.content, this.channel) : null;\n  }\n\n  /**\n   * Creates a reaction collector.\n   * @param {ReactionCollectorOptions} [options={}] Options to send to the collector\n   * @returns {ReactionCollector}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === 'ðŸ‘Œ' && user.id === 'someId';\n   * const collector = message.createReactionCollector({ filter, time: 15_000 });\n   * collector.on('collect', r => console.log(`Collected ${r.emoji.name}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createReactionCollector(options = {}) {\n    return new ReactionCollector(this, options);\n  }\n\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {ReactionCollectorOptions} AwaitReactionsOptions\n   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n   */\n\n  /**\n   * Similar to createReactionCollector but in promise form.\n   * Resolves with a collection of reactions that pass the specified filter.\n   * @param {AwaitReactionsOptions} [options={}] Optional options to pass to the internal collector\n   * @returns {Promise<Collection<string | Snowflake, MessageReaction>>}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === 'ðŸ‘Œ' && user.id === 'someId'\n   * message.awaitReactions({ filter, time: 15_000 })\n   *   .then(collected => console.log(`Collected ${collected.size} reactions`))\n   *   .catch(console.error);\n   */\n  awaitReactions(options = {}) {\n    return new Promise((resolve, reject) => {\n      const collector = this.createReactionCollector(options);\n      collector.once('end', (reactions, reason) => {\n        if (options.errors?.includes(reason)) reject(reactions);else resolve(reactions);\n      });\n    });\n  }\n\n  /**\n   * @typedef {CollectorOptions} MessageComponentCollectorOptions\n   * @property {ComponentType} [componentType] The type of component to listen for\n   * @property {number} [max] The maximum total amount of interactions to collect\n   * @property {number} [maxComponents] The maximum number of components to collect\n   * @property {number} [maxUsers] The maximum number of users to interact\n   */\n\n  /**\n   * Creates a message component interaction collector.\n   * @param {MessageComponentCollectorOptions} [options={}] Options to send to the collector\n   * @returns {InteractionCollector}\n   * @example\n   * // Create a message component interaction collector\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * const collector = message.createMessageComponentCollector({ filter, time: 15_000 });\n   * collector.on('collect', i => console.log(`Collected ${i.customId}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createMessageComponentCollector(options = {}) {\n    return new InteractionCollector(this.client, {\n      ...options,\n      interactionType: InteractionType.MessageComponent,\n      message: this\n    });\n  }\n\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {Object} AwaitMessageComponentOptions\n   * @property {CollectorFilter} [filter] The filter applied to this collector\n   * @property {number} [time] Time to wait for an interaction before rejecting\n   * @property {ComponentType} [componentType] The type of component interaction to collect\n   * @property {number} [idle] Time to wait without another message component interaction before ending the collector\n   * @property {boolean} [dispose] Whether to remove the message component interaction after collecting\n   * @property {InteractionResponse} [interactionResponse] The interaction response to collect interactions from\n   */\n\n  /**\n   * Collects a single component interaction that passes the filter.\n   * The Promise will reject if the time expires.\n   * @param {AwaitMessageComponentOptions} [options={}] Options to pass to the internal collector\n   * @returns {Promise<MessageComponentInteraction>}\n   * @example\n   * // Collect a message component interaction\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * message.awaitMessageComponent({ filter, time: 15_000 })\n   *   .then(interaction => console.log(`${interaction.customId} was clicked!`))\n   *   .catch(console.error);\n   */\n  awaitMessageComponent(options = {}) {\n    const _options = {\n      ...options,\n      max: 1\n    };\n    return new Promise((resolve, reject) => {\n      const collector = this.createMessageComponentCollector(_options);\n      collector.once('end', (interactions, reason) => {\n        const interaction = interactions.first();\n        if (interaction) resolve(interaction);else reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));\n      });\n    });\n  }\n\n  /**\n   * Whether the message is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    const precheck = Boolean(this.author.id === this.client.user.id && (!this.guild || this.channel?.viewable));\n\n    // Regardless of permissions thread messages cannot be edited if\n    // the thread is archived or the thread is locked and the bot does not have permission to manage threads.\n    if (this.channel?.isThread()) {\n      if (this.channel.archived) return false;\n      if (this.channel.locked) {\n        const permissions = this.channel.permissionsFor(this.client.user);\n        if (!permissions?.has(PermissionFlagsBits.ManageThreads, true)) return false;\n      }\n    }\n    return precheck;\n  }\n\n  /**\n   * Whether the message is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    if (!DeletableMessageTypes.includes(this.type)) return false;\n    if (!this.guild) {\n      return this.author.id === this.client.user.id;\n    }\n    // DMChannel does not have viewable property, so check viewable after proved that message is on a guild.\n    if (!this.channel?.viewable) {\n      return false;\n    }\n    const permissions = this.channel?.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    // This flag allows deleting even if timed out\n    if (permissions.has(PermissionFlagsBits.Administrator, false)) return true;\n\n    // The auto moderation action message author is the reference message author\n    return this.type !== MessageType.AutoModerationAction && this.author.id === this.client.user.id || permissions.has(PermissionFlagsBits.ManageMessages, false) && !this.guild.members.me.isCommunicationDisabled();\n  }\n\n  /**\n   * Whether the message is bulk deletable by the client user\n   * @type {boolean}\n   * @readonly\n   * @example\n   * // Filter for bulk deletable messages\n   * channel.bulkDelete(messages.filter(message => message.bulkDeletable));\n   */\n  get bulkDeletable() {\n    return (this.inGuild() && Date.now() - this.createdTimestamp < MaxBulkDeletableMessageAge && this.deletable && this.channel?.permissionsFor(this.client.user).has(PermissionFlagsBits.ManageMessages, false)) ?? false;\n  }\n\n  /**\n   * Whether the message is pinnable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get pinnable() {\n    const {\n      channel\n    } = this;\n    return Boolean(!this.system && (!this.guild || channel?.viewable && channel?.permissionsFor(this.client.user)?.has(PermissionFlagsBits.ManageMessages, false)));\n  }\n\n  /**\n   * Fetches the Message this crosspost/reply/pin-add references, if available to the client\n   * @returns {Promise<Message>}\n   */\n  async fetchReference() {\n    if (!this.reference) throw new DiscordjsError(ErrorCodes.MessageReferenceMissing);\n    const {\n      channelId,\n      messageId\n    } = this.reference;\n    const channel = this.client.channels.resolve(channelId);\n    if (!channel) throw new DiscordjsError(ErrorCodes.GuildChannelResolve);\n    const message = await channel.messages.fetch(messageId);\n    return message;\n  }\n\n  /**\n   * Whether the message is crosspostable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get crosspostable() {\n    const bitfield = PermissionFlagsBits.SendMessages | (this.author.id === this.client.user.id ? PermissionsBitField.DefaultBit : PermissionFlagsBits.ManageMessages);\n    const {\n      channel\n    } = this;\n    return Boolean(channel?.type === ChannelType.GuildAnnouncement && !this.flags.has(MessageFlags.Crossposted) && this.type === MessageType.Default && channel.viewable && channel.permissionsFor(this.client.user)?.has(bitfield, false));\n  }\n\n  /**\n   * Edits the content of the message.\n   * @param {string|MessagePayload|MessageEditOptions} options The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Update the content of a message\n   * message.edit('This is my new content!')\n   *   .then(msg => console.log(`Updated the content of a message to ${msg.content}`))\n   *   .catch(console.error);\n   */\n  edit(options) {\n    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));\n    return this.channel.messages.edit(this, options);\n  }\n\n  /**\n   * Publishes a message in an announcement channel to all channels following it.\n   * @returns {Promise<Message>}\n   * @example\n   * // Crosspost a message\n   * if (message.channel.type === ChannelType.GuildAnnouncement) {\n   *   message.crosspost()\n   *     .then(() => console.log('Crossposted message'))\n   *     .catch(console.error);\n   * }\n   */\n  crosspost() {\n    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));\n    return this.channel.messages.crosspost(this.id);\n  }\n\n  /**\n   * Pins this message to the channel's pinned messages.\n   * @param {string} [reason] Reason for pinning\n   * @returns {Promise<Message>}\n   * @example\n   * // Pin a message\n   * message.pin()\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  async pin(reason) {\n    if (!this.channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);\n    await this.channel.messages.pin(this.id, reason);\n    return this;\n  }\n\n  /**\n   * Unpins this message from the channel's pinned messages.\n   * @param {string} [reason] Reason for unpinning\n   * @returns {Promise<Message>}\n   * @example\n   * // Unpin a message\n   * message.unpin()\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  async unpin(reason) {\n    if (!this.channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);\n    await this.channel.messages.unpin(this.id, reason);\n    return this;\n  }\n\n  /**\n   * Adds a reaction to the message.\n   * @param {EmojiIdentifierResolvable} emoji The emoji to react with\n   * @returns {Promise<MessageReaction>}\n   * @example\n   * // React to a message with a unicode emoji\n   * message.react('ðŸ¤”')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // React to a message with a custom emoji\n   * message.react(message.guild.emojis.cache.get('123456789012345678'))\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async react(emoji) {\n    if (!this.channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);\n    await this.channel.messages.react(this.id, emoji);\n    return this.client.actions.MessageReactionAdd.handle({\n      [this.client.actions.injectedUser]: this.client.user,\n      [this.client.actions.injectedChannel]: this.channel,\n      [this.client.actions.injectedMessage]: this,\n      emoji: resolvePartialEmoji(emoji)\n    }, true).reaction;\n  }\n\n  /**\n   * Deletes the message.\n   * @returns {Promise<Message>}\n   * @example\n   * // Delete a message\n   * message.delete()\n   *   .then(msg => console.log(`Deleted message from ${msg.author.username}`))\n   *   .catch(console.error);\n   */\n  async delete() {\n    if (!this.channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);\n    await this.channel.messages.delete(this.id);\n    return this;\n  }\n\n  /**\n   * Options provided when sending a message as an inline reply.\n   * @typedef {BaseMessageCreateOptions} MessageReplyOptions\n   * @property {boolean} [failIfNotExists=this.client.options.failIfNotExists] Whether to error if the referenced\n   * message does not exist (creates a standard message in this case when false)\n   */\n\n  /**\n   * Send an inline reply to this message.\n   * @param {string|MessagePayload|MessageReplyOptions} options The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Reply to a message\n   * message.reply('This is a reply!')\n   *   .then(() => console.log(`Replied to message \"${message.content}\"`))\n   *   .catch(console.error);\n   */\n  reply(options) {\n    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));\n    let data;\n    if (options instanceof MessagePayload) {\n      data = options;\n    } else {\n      data = MessagePayload.create(this, options, {\n        reply: {\n          messageReference: this,\n          failIfNotExists: options?.failIfNotExists ?? this.client.options.failIfNotExists\n        }\n      });\n    }\n    return this.channel.send(data);\n  }\n\n  /**\n   * Options for starting a thread on a message.\n   * @typedef {Object} StartThreadOptions\n   * @property {string} name The name of the new thread\n   * @property {ThreadAutoArchiveDuration} [autoArchiveDuration=this.channel.defaultAutoArchiveDuration] The amount of\n   * time after which the thread should automatically archive in case of no recent activity\n   * @property {string} [reason] Reason for creating the thread\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the thread in seconds\n   */\n\n  /**\n   * Create a new public thread from this message\n   * @see GuildTextThreadManager#create\n   * @param {StartThreadOptions} [options] Options for starting a thread on this message\n   * @returns {Promise<ThreadChannel>}\n   */\n  startThread(options = {}) {\n    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));\n    if (![ChannelType.GuildText, ChannelType.GuildAnnouncement].includes(this.channel.type)) {\n      return Promise.reject(new DiscordjsError(ErrorCodes.MessageThreadParent));\n    }\n    if (this.hasThread) return Promise.reject(new DiscordjsError(ErrorCodes.MessageExistingThread));\n    return this.channel.threads.create({\n      ...options,\n      startMessage: this\n    });\n  }\n\n  /**\n   * Fetch this message.\n   * @param {boolean} [force=true] Whether to skip the cache check and request the API\n   * @returns {Promise<Message>}\n   */\n  fetch(force = true) {\n    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));\n    return this.channel.messages.fetch({\n      message: this.id,\n      force\n    });\n  }\n\n  /**\n   * Fetches the webhook used to create this message.\n   * @returns {Promise<?Webhook>}\n   */\n  fetchWebhook() {\n    if (!this.webhookId) return Promise.reject(new DiscordjsError(ErrorCodes.WebhookMessage));\n    if (this.webhookId === this.applicationId) return Promise.reject(new DiscordjsError(ErrorCodes.WebhookApplication));\n    return this.client.fetchWebhook(this.webhookId);\n  }\n\n  /**\n   * Suppresses or unsuppresses embeds on a message.\n   * @param {boolean} [suppress=true] If the embeds should be suppressed or not\n   * @returns {Promise<Message>}\n   */\n  suppressEmbeds(suppress = true) {\n    const flags = new MessageFlagsBitField(this.flags.bitfield);\n    if (suppress) {\n      flags.add(MessageFlags.SuppressEmbeds);\n    } else {\n      flags.remove(MessageFlags.SuppressEmbeds);\n    }\n    return this.edit({\n      flags\n    });\n  }\n\n  /**\n   * Removes the attachments from this message.\n   * @returns {Promise<Message>}\n   */\n  removeAttachments() {\n    return this.edit({\n      attachments: []\n    });\n  }\n\n  /**\n   * Resolves a component by a custom id.\n   * @param {string} customId The custom id to resolve against\n   * @returns {?MessageActionRowComponent}\n   */\n  resolveComponent(customId) {\n    return this.components.flatMap(row => row.components).find(component => component.customId === customId) ?? null;\n  }\n\n  /**\n   * Used mainly internally. Whether two messages are identical in properties. If you want to compare messages\n   * without checking all the properties, use `message.id === message2.id`, which is much more efficient. This\n   * method allows you to see if there are differences in content, embeds, attachments, nonce and tts properties.\n   * @param {Message} message The message to compare it to\n   * @param {APIMessage} rawData Raw data passed through the WebSocket about this message\n   * @returns {boolean}\n   */\n  equals(message, rawData) {\n    if (!message) return false;\n    const embedUpdate = !message.author && !message.attachments;\n    if (embedUpdate) return this.id === message.id && this.embeds.length === message.embeds.length;\n    let equal = this.id === message.id && this.author.id === message.author.id && this.content === message.content && this.tts === message.tts && this.nonce === message.nonce && this.embeds.length === message.embeds.length && this.attachments.length === message.attachments.length;\n    if (equal && rawData) {\n      equal = this.mentions.everyone === message.mentions.everyone && this.createdTimestamp === Date.parse(rawData.timestamp) && this.editedTimestamp === Date.parse(rawData.edited_timestamp);\n    }\n    return equal;\n  }\n\n  /**\n   * Whether this message is from a guild.\n   * @returns {boolean}\n   */\n  inGuild() {\n    return Boolean(this.guildId);\n  }\n\n  /**\n   * When concatenated with a string, this automatically concatenates the message's content instead of the object.\n   * @returns {string}\n   * @example\n   * // Logs: Message: This is a message!\n   * console.log(`Message: ${message}`);\n   */\n  toString() {\n    return this.content;\n  }\n  toJSON() {\n    return super.toJSON({\n      channel: 'channelId',\n      author: 'authorId',\n      groupActivityApplication: 'groupActivityApplicationId',\n      guild: 'guildId',\n      cleanContent: true,\n      member: false,\n      reactions: false\n    });\n  }\n}\nexports.Message = Message;","map":{"version":3,"names":["messageLink","require","Collection","DiscordSnowflake","InteractionType","ChannelType","MessageType","MessageFlags","PermissionFlagsBits","Attachment","Base","ClientApplication","Embed","InteractionCollector","Mentions","MessagePayload","ReactionCollector","Sticker","DiscordjsError","ErrorCodes","ReactionManager","createComponent","NonSystemMessageTypes","MaxBulkDeletableMessageAge","DeletableMessageTypes","MessageFlagsBitField","PermissionsBitField","cleanContent","resolvePartialEmoji","Message","constructor","client","data","channelId","channel_id","guildId","guild_id","channel","guild","id","_patch","createdTimestamp","timestampFrom","type","system","includes","content","author","users","_add","webhook_id","pinned","Boolean","tts","nonce","embeds","map","e","slice","components","c","attachments","attachment","set","stickers","sticker_items","s","position","roleSubscriptionData","roleSubscriptionListingId","role_subscription_data","role_subscription_listing_id","tierName","tier_name","totalMonthsSubscribed","total_months_subscribed","isRenewal","is_renewal","edited_timestamp","editedTimestamp","Date","parse","reactions","length","reaction","mentions","mention_roles","mention_everyone","mention_channels","referenced_message","roles","everyone","crosspostedChannels","repliedUser","webhookId","groupActivityApplication","application","applicationId","application_id","activity","partyId","party_id","channels","thread","member","members","Object","assign","user","flags","freeze","reference","message_reference","messageId","message_id","messages","interaction","commandName","name","resolve","partial","createdAt","editedAt","guilds","hasThread","has","HasThread","threads","url","inGuild","createReactionCollector","options","awaitReactions","Promise","reject","collector","once","reason","errors","createMessageComponentCollector","interactionType","MessageComponent","message","awaitMessageComponent","_options","max","interactions","first","InteractionCollectorError","editable","precheck","viewable","isThread","archived","locked","permissions","permissionsFor","ManageThreads","deletable","Administrator","AutoModerationAction","ManageMessages","me","isCommunicationDisabled","bulkDeletable","now","pinnable","fetchReference","MessageReferenceMissing","GuildChannelResolve","fetch","crosspostable","bitfield","SendMessages","DefaultBit","GuildAnnouncement","Crossposted","Default","edit","ChannelNotCached","crosspost","pin","unpin","react","emoji","actions","MessageReactionAdd","handle","injectedUser","injectedChannel","injectedMessage","delete","reply","create","messageReference","failIfNotExists","send","startThread","GuildText","MessageThreadParent","MessageExistingThread","startMessage","force","fetchWebhook","WebhookMessage","WebhookApplication","suppressEmbeds","suppress","add","SuppressEmbeds","remove","removeAttachments","resolveComponent","customId","flatMap","row","find","component","equals","rawData","embedUpdate","equal","timestamp","toString","toJSON","exports"],"sources":["C:/Users/hetit/node_modules/discord.js/src/structures/Message.js"],"sourcesContent":["'use strict';\n\nconst { messageLink } = require('@discordjs/builders');\nconst { Collection } = require('@discordjs/collection');\nconst { DiscordSnowflake } = require('@sapphire/snowflake');\nconst {\n  InteractionType,\n  ChannelType,\n  MessageType,\n  MessageFlags,\n  PermissionFlagsBits,\n} = require('discord-api-types/v10');\nconst Attachment = require('./Attachment');\nconst Base = require('./Base');\nconst ClientApplication = require('./ClientApplication');\nconst Embed = require('./Embed');\nconst InteractionCollector = require('./InteractionCollector');\nconst Mentions = require('./MessageMentions');\nconst MessagePayload = require('./MessagePayload');\nconst ReactionCollector = require('./ReactionCollector');\nconst { Sticker } = require('./Sticker');\nconst { DiscordjsError, ErrorCodes } = require('../errors');\nconst ReactionManager = require('../managers/ReactionManager');\nconst { createComponent } = require('../util/Components');\nconst { NonSystemMessageTypes, MaxBulkDeletableMessageAge, DeletableMessageTypes } = require('../util/Constants');\nconst MessageFlagsBitField = require('../util/MessageFlagsBitField');\nconst PermissionsBitField = require('../util/PermissionsBitField');\nconst { cleanContent, resolvePartialEmoji } = require('../util/Util');\n\n/**\n * Represents a message on Discord.\n * @extends {Base}\n */\nclass Message extends Base {\n  constructor(client, data) {\n    super(client);\n\n    /**\n     * The id of the channel the message was sent in\n     * @type {Snowflake}\n     */\n    this.channelId = data.channel_id;\n\n    /**\n     * The id of the guild the message was sent in, if any\n     * @type {?Snowflake}\n     */\n    this.guildId = data.guild_id ?? this.channel?.guild?.id ?? null;\n\n    this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The message's id\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    /**\n     * The timestamp the message was sent at\n     * @type {number}\n     */\n    this.createdTimestamp = DiscordSnowflake.timestampFrom(this.id);\n\n    if ('type' in data) {\n      /**\n       * The type of the message\n       * @type {?MessageType}\n       */\n      this.type = data.type;\n\n      /**\n       * Whether or not this message was sent by Discord, not actually a user (e.g. pin notifications)\n       * @type {?boolean}\n       */\n      this.system = !NonSystemMessageTypes.includes(this.type);\n    } else {\n      this.system ??= null;\n      this.type ??= null;\n    }\n\n    if ('content' in data) {\n      /**\n       * The content of the message.\n       * <info>This property requires the {@link GatewayIntentBits.MessageContent} privileged intent\n       * in a guild for messages that do not mention the client.</info>\n       * @type {?string}\n       */\n      this.content = data.content;\n    } else {\n      this.content ??= null;\n    }\n\n    if ('author' in data) {\n      /**\n       * The author of the message\n       * @type {?User}\n       */\n      this.author = this.client.users._add(data.author, !data.webhook_id);\n    } else {\n      this.author ??= null;\n    }\n\n    if ('pinned' in data) {\n      /**\n       * Whether or not this message is pinned\n       * @type {?boolean}\n       */\n      this.pinned = Boolean(data.pinned);\n    } else {\n      this.pinned ??= null;\n    }\n\n    if ('tts' in data) {\n      /**\n       * Whether or not the message was Text-To-Speech\n       * @type {?boolean}\n       */\n      this.tts = data.tts;\n    } else {\n      this.tts ??= null;\n    }\n\n    if ('nonce' in data) {\n      /**\n       * A random number or string used for checking message delivery\n       * <warn>This is only received after the message was sent successfully, and\n       * lost if re-fetched</warn>\n       * @type {?string}\n       */\n      this.nonce = data.nonce;\n    } else {\n      this.nonce ??= null;\n    }\n\n    if ('embeds' in data) {\n      /**\n       * An array of embeds in the message - e.g. YouTube Player.\n       * <info>This property requires the {@link GatewayIntentBits.MessageContent} privileged intent\n       * in a guild for messages that do not mention the client.</info>\n       * @type {Embed[]}\n       */\n      this.embeds = data.embeds.map(e => new Embed(e));\n    } else {\n      this.embeds = this.embeds?.slice() ?? [];\n    }\n\n    if ('components' in data) {\n      /**\n       * An array of of action rows in the message.\n       * <info>This property requires the {@link GatewayIntentBits.MessageContent} privileged intent\n       * in a guild for messages that do not mention the client.</info>\n       * @type {ActionRow[]}\n       */\n      this.components = data.components.map(c => createComponent(c));\n    } else {\n      this.components = this.components?.slice() ?? [];\n    }\n\n    if ('attachments' in data) {\n      /**\n       * A collection of attachments in the message - e.g. Pictures - mapped by their ids.\n       * <info>This property requires the {@link GatewayIntentBits.MessageContent} privileged intent\n       * in a guild for messages that do not mention the client.</info>\n       * @type {Collection<Snowflake, Attachment>}\n       */\n      this.attachments = new Collection();\n      if (data.attachments) {\n        for (const attachment of data.attachments) {\n          this.attachments.set(attachment.id, new Attachment(attachment));\n        }\n      }\n    } else {\n      this.attachments = new Collection(this.attachments);\n    }\n\n    if ('sticker_items' in data || 'stickers' in data) {\n      /**\n       * A collection of stickers in the message\n       * @type {Collection<Snowflake, Sticker>}\n       */\n      this.stickers = new Collection(\n        (data.sticker_items ?? data.stickers)?.map(s => [s.id, new Sticker(this.client, s)]),\n      );\n    } else {\n      this.stickers = new Collection(this.stickers);\n    }\n\n    if ('position' in data) {\n      /**\n       * A generally increasing integer (there may be gaps or duplicates) that represents\n       * the approximate position of the message in a thread.\n       * @type {?number}\n       */\n      this.position = data.position;\n    } else {\n      this.position ??= null;\n    }\n\n    if ('role_subscription_data' in data) {\n      /**\n       * Role subscription data found on {@link MessageType.RoleSubscriptionPurchase} messages.\n       * @typedef {Object} RoleSubscriptionData\n       * @property {Snowflake} roleSubscriptionListingId The id of the SKU and listing the user is subscribed to\n       * @property {string} tierName The name of the tier the user is subscribed to\n       * @property {number} totalMonthsSubscribed The total number of months the user has been subscribed for\n       * @property {boolean} isRenewal Whether this notification is a renewal\n       */\n\n      /**\n       * The data of the role subscription purchase or renewal.\n       * <info>This is present on {@link MessageType.RoleSubscriptionPurchase} messages.</info>\n       * @type {?RoleSubscriptionData}\n       */\n      this.roleSubscriptionData = {\n        roleSubscriptionListingId: data.role_subscription_data.role_subscription_listing_id,\n        tierName: data.role_subscription_data.tier_name,\n        totalMonthsSubscribed: data.role_subscription_data.total_months_subscribed,\n        isRenewal: data.role_subscription_data.is_renewal,\n      };\n    } else {\n      this.roleSubscriptionData ??= null;\n    }\n\n    // Discord sends null if the message has not been edited\n    if (data.edited_timestamp) {\n      /**\n       * The timestamp the message was last edited at (if applicable)\n       * @type {?number}\n       */\n      this.editedTimestamp = Date.parse(data.edited_timestamp);\n    } else {\n      this.editedTimestamp ??= null;\n    }\n\n    if ('reactions' in data) {\n      /**\n       * A manager of the reactions belonging to this message\n       * @type {ReactionManager}\n       */\n      this.reactions = new ReactionManager(this);\n      if (data.reactions?.length > 0) {\n        for (const reaction of data.reactions) {\n          this.reactions._add(reaction);\n        }\n      }\n    } else {\n      this.reactions ??= new ReactionManager(this);\n    }\n\n    if (!this.mentions) {\n      /**\n       * All valid mentions that the message contains\n       * @type {MessageMentions}\n       */\n      this.mentions = new Mentions(\n        this,\n        data.mentions,\n        data.mention_roles,\n        data.mention_everyone,\n        data.mention_channels,\n        data.referenced_message?.author,\n      );\n    } else {\n      this.mentions = new Mentions(\n        this,\n        data.mentions ?? this.mentions.users,\n        data.mention_roles ?? this.mentions.roles,\n        data.mention_everyone ?? this.mentions.everyone,\n        data.mention_channels ?? this.mentions.crosspostedChannels,\n        data.referenced_message?.author ?? this.mentions.repliedUser,\n      );\n    }\n\n    if ('webhook_id' in data) {\n      /**\n       * The id of the webhook that sent the message, if applicable\n       * @type {?Snowflake}\n       */\n      this.webhookId = data.webhook_id;\n    } else {\n      this.webhookId ??= null;\n    }\n\n    if ('application' in data) {\n      /**\n       * Supplemental application information for group activities\n       * @type {?ClientApplication}\n       */\n      this.groupActivityApplication = new ClientApplication(this.client, data.application);\n    } else {\n      this.groupActivityApplication ??= null;\n    }\n\n    if ('application_id' in data) {\n      /**\n       * The id of the application of the interaction that sent this message, if any\n       * @type {?Snowflake}\n       */\n      this.applicationId = data.application_id;\n    } else {\n      this.applicationId ??= null;\n    }\n\n    if ('activity' in data) {\n      /**\n       * Group activity\n       * @type {?MessageActivity}\n       */\n      this.activity = {\n        partyId: data.activity.party_id,\n        type: data.activity.type,\n      };\n    } else {\n      this.activity ??= null;\n    }\n\n    if ('thread' in data) {\n      this.client.channels._add(data.thread, this.guild);\n    }\n\n    if (this.member && data.member) {\n      this.member._patch(data.member);\n    } else if (data.member && this.guild && this.author) {\n      this.guild.members._add(Object.assign(data.member, { user: this.author }));\n    }\n\n    if ('flags' in data) {\n      /**\n       * Flags that are applied to the message\n       * @type {Readonly<MessageFlagsBitField>}\n       */\n      this.flags = new MessageFlagsBitField(data.flags).freeze();\n    } else {\n      this.flags = new MessageFlagsBitField(this.flags).freeze();\n    }\n\n    /**\n     * Reference data sent in a message that contains ids identifying the referenced message.\n     * This can be present in the following types of message:\n     * * Crossposted messages (`MessageFlags.Crossposted`)\n     * * {@link MessageType.ChannelFollowAdd}\n     * * {@link MessageType.ChannelPinnedMessage}\n     * * {@link MessageType.Reply}\n     * * {@link MessageType.ThreadStarterMessage}\n     * @see {@link https://discord.com/developers/docs/resources/channel#message-types}\n     * @typedef {Object} MessageReference\n     * @property {Snowflake} channelId The channel's id the message was referenced\n     * @property {?Snowflake} guildId The guild's id the message was referenced\n     * @property {?Snowflake} messageId The message's id that was referenced\n     */\n\n    if ('message_reference' in data) {\n      /**\n       * Message reference data\n       * @type {?MessageReference}\n       */\n      this.reference = {\n        channelId: data.message_reference.channel_id,\n        guildId: data.message_reference.guild_id,\n        messageId: data.message_reference.message_id,\n      };\n    } else {\n      this.reference ??= null;\n    }\n\n    if (data.referenced_message) {\n      this.channel?.messages._add({ guild_id: data.message_reference?.guild_id, ...data.referenced_message });\n    }\n\n    /**\n     * Partial data of the interaction that a message is a reply to\n     * @typedef {Object} MessageInteraction\n     * @property {Snowflake} id The interaction's id\n     * @property {InteractionType} type The type of the interaction\n     * @property {string} commandName The name of the interaction's application command,\n     * as well as the subcommand and subcommand group, where applicable\n     * @property {User} user The user that invoked the interaction\n     */\n\n    if (data.interaction) {\n      /**\n       * Partial data of the interaction that this message is a reply to\n       * @type {?MessageInteraction}\n       */\n      this.interaction = {\n        id: data.interaction.id,\n        type: data.interaction.type,\n        commandName: data.interaction.name,\n        user: this.client.users._add(data.interaction.user),\n      };\n    } else {\n      this.interaction ??= null;\n    }\n  }\n\n  /**\n   * The channel that the message was sent in\n   * @type {TextBasedChannels}\n   * @readonly\n   */\n  get channel() {\n    return this.client.channels.resolve(this.channelId);\n  }\n\n  /**\n   * Whether or not this message is a partial\n   * @type {boolean}\n   * @readonly\n   */\n  get partial() {\n    return typeof this.content !== 'string' || !this.author;\n  }\n\n  /**\n   * Represents the author of the message as a guild member.\n   * Only available if the message comes from a guild where the author is still a member\n   * @type {?GuildMember}\n   * @readonly\n   */\n  get member() {\n    return this.guild?.members.resolve(this.author) ?? null;\n  }\n\n  /**\n   * The time the message was sent at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The time the message was last edited at (if applicable)\n   * @type {?Date}\n   * @readonly\n   */\n  get editedAt() {\n    return this.editedTimestamp && new Date(this.editedTimestamp);\n  }\n\n  /**\n   * The guild the message was sent in (if in a guild channel)\n   * @type {?Guild}\n   * @readonly\n   */\n  get guild() {\n    return this.client.guilds.resolve(this.guildId) ?? this.channel?.guild ?? null;\n  }\n\n  /**\n   * Whether this message has a thread associated with it\n   * @type {boolean}\n   * @readonly\n   */\n  get hasThread() {\n    return this.flags.has(MessageFlags.HasThread);\n  }\n\n  /**\n   * The thread started by this message\n   * <info>This property is not suitable for checking whether a message has a thread,\n   * use {@link Message#hasThread} instead.</info>\n   * @type {?ThreadChannel}\n   * @readonly\n   */\n  get thread() {\n    return this.channel?.threads?.resolve(this.id) ?? null;\n  }\n\n  /**\n   * The URL to jump to this message\n   * @type {string}\n   * @readonly\n   */\n  get url() {\n    return this.inGuild() ? messageLink(this.channelId, this.id, this.guildId) : messageLink(this.channelId, this.id);\n  }\n\n  /**\n   * The message contents with all mentions replaced by the equivalent text.\n   * If mentions cannot be resolved to a name, the relevant mention in the message content will not be converted.\n   * @type {?string}\n   * @readonly\n   */\n  get cleanContent() {\n    // eslint-disable-next-line eqeqeq\n    return this.content != null ? cleanContent(this.content, this.channel) : null;\n  }\n\n  /**\n   * Creates a reaction collector.\n   * @param {ReactionCollectorOptions} [options={}] Options to send to the collector\n   * @returns {ReactionCollector}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === 'ðŸ‘Œ' && user.id === 'someId';\n   * const collector = message.createReactionCollector({ filter, time: 15_000 });\n   * collector.on('collect', r => console.log(`Collected ${r.emoji.name}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createReactionCollector(options = {}) {\n    return new ReactionCollector(this, options);\n  }\n\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {ReactionCollectorOptions} AwaitReactionsOptions\n   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n   */\n\n  /**\n   * Similar to createReactionCollector but in promise form.\n   * Resolves with a collection of reactions that pass the specified filter.\n   * @param {AwaitReactionsOptions} [options={}] Optional options to pass to the internal collector\n   * @returns {Promise<Collection<string | Snowflake, MessageReaction>>}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === 'ðŸ‘Œ' && user.id === 'someId'\n   * message.awaitReactions({ filter, time: 15_000 })\n   *   .then(collected => console.log(`Collected ${collected.size} reactions`))\n   *   .catch(console.error);\n   */\n  awaitReactions(options = {}) {\n    return new Promise((resolve, reject) => {\n      const collector = this.createReactionCollector(options);\n      collector.once('end', (reactions, reason) => {\n        if (options.errors?.includes(reason)) reject(reactions);\n        else resolve(reactions);\n      });\n    });\n  }\n\n  /**\n   * @typedef {CollectorOptions} MessageComponentCollectorOptions\n   * @property {ComponentType} [componentType] The type of component to listen for\n   * @property {number} [max] The maximum total amount of interactions to collect\n   * @property {number} [maxComponents] The maximum number of components to collect\n   * @property {number} [maxUsers] The maximum number of users to interact\n   */\n\n  /**\n   * Creates a message component interaction collector.\n   * @param {MessageComponentCollectorOptions} [options={}] Options to send to the collector\n   * @returns {InteractionCollector}\n   * @example\n   * // Create a message component interaction collector\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * const collector = message.createMessageComponentCollector({ filter, time: 15_000 });\n   * collector.on('collect', i => console.log(`Collected ${i.customId}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createMessageComponentCollector(options = {}) {\n    return new InteractionCollector(this.client, {\n      ...options,\n      interactionType: InteractionType.MessageComponent,\n      message: this,\n    });\n  }\n\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {Object} AwaitMessageComponentOptions\n   * @property {CollectorFilter} [filter] The filter applied to this collector\n   * @property {number} [time] Time to wait for an interaction before rejecting\n   * @property {ComponentType} [componentType] The type of component interaction to collect\n   * @property {number} [idle] Time to wait without another message component interaction before ending the collector\n   * @property {boolean} [dispose] Whether to remove the message component interaction after collecting\n   * @property {InteractionResponse} [interactionResponse] The interaction response to collect interactions from\n   */\n\n  /**\n   * Collects a single component interaction that passes the filter.\n   * The Promise will reject if the time expires.\n   * @param {AwaitMessageComponentOptions} [options={}] Options to pass to the internal collector\n   * @returns {Promise<MessageComponentInteraction>}\n   * @example\n   * // Collect a message component interaction\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * message.awaitMessageComponent({ filter, time: 15_000 })\n   *   .then(interaction => console.log(`${interaction.customId} was clicked!`))\n   *   .catch(console.error);\n   */\n  awaitMessageComponent(options = {}) {\n    const _options = { ...options, max: 1 };\n    return new Promise((resolve, reject) => {\n      const collector = this.createMessageComponentCollector(_options);\n      collector.once('end', (interactions, reason) => {\n        const interaction = interactions.first();\n        if (interaction) resolve(interaction);\n        else reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));\n      });\n    });\n  }\n\n  /**\n   * Whether the message is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    const precheck = Boolean(this.author.id === this.client.user.id && (!this.guild || this.channel?.viewable));\n\n    // Regardless of permissions thread messages cannot be edited if\n    // the thread is archived or the thread is locked and the bot does not have permission to manage threads.\n    if (this.channel?.isThread()) {\n      if (this.channel.archived) return false;\n      if (this.channel.locked) {\n        const permissions = this.channel.permissionsFor(this.client.user);\n        if (!permissions?.has(PermissionFlagsBits.ManageThreads, true)) return false;\n      }\n    }\n\n    return precheck;\n  }\n\n  /**\n   * Whether the message is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    if (!DeletableMessageTypes.includes(this.type)) return false;\n\n    if (!this.guild) {\n      return this.author.id === this.client.user.id;\n    }\n    // DMChannel does not have viewable property, so check viewable after proved that message is on a guild.\n    if (!this.channel?.viewable) {\n      return false;\n    }\n\n    const permissions = this.channel?.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    // This flag allows deleting even if timed out\n    if (permissions.has(PermissionFlagsBits.Administrator, false)) return true;\n\n    // The auto moderation action message author is the reference message author\n    return (\n      (this.type !== MessageType.AutoModerationAction && this.author.id === this.client.user.id) ||\n      (permissions.has(PermissionFlagsBits.ManageMessages, false) && !this.guild.members.me.isCommunicationDisabled())\n    );\n  }\n\n  /**\n   * Whether the message is bulk deletable by the client user\n   * @type {boolean}\n   * @readonly\n   * @example\n   * // Filter for bulk deletable messages\n   * channel.bulkDelete(messages.filter(message => message.bulkDeletable));\n   */\n  get bulkDeletable() {\n    return (\n      (this.inGuild() &&\n        Date.now() - this.createdTimestamp < MaxBulkDeletableMessageAge &&\n        this.deletable &&\n        this.channel?.permissionsFor(this.client.user).has(PermissionFlagsBits.ManageMessages, false)) ??\n      false\n    );\n  }\n\n  /**\n   * Whether the message is pinnable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get pinnable() {\n    const { channel } = this;\n    return Boolean(\n      !this.system &&\n        (!this.guild ||\n          (channel?.viewable &&\n            channel?.permissionsFor(this.client.user)?.has(PermissionFlagsBits.ManageMessages, false))),\n    );\n  }\n\n  /**\n   * Fetches the Message this crosspost/reply/pin-add references, if available to the client\n   * @returns {Promise<Message>}\n   */\n  async fetchReference() {\n    if (!this.reference) throw new DiscordjsError(ErrorCodes.MessageReferenceMissing);\n    const { channelId, messageId } = this.reference;\n    const channel = this.client.channels.resolve(channelId);\n    if (!channel) throw new DiscordjsError(ErrorCodes.GuildChannelResolve);\n    const message = await channel.messages.fetch(messageId);\n    return message;\n  }\n\n  /**\n   * Whether the message is crosspostable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get crosspostable() {\n    const bitfield =\n      PermissionFlagsBits.SendMessages |\n      (this.author.id === this.client.user.id ? PermissionsBitField.DefaultBit : PermissionFlagsBits.ManageMessages);\n    const { channel } = this;\n    return Boolean(\n      channel?.type === ChannelType.GuildAnnouncement &&\n        !this.flags.has(MessageFlags.Crossposted) &&\n        this.type === MessageType.Default &&\n        channel.viewable &&\n        channel.permissionsFor(this.client.user)?.has(bitfield, false),\n    );\n  }\n\n  /**\n   * Edits the content of the message.\n   * @param {string|MessagePayload|MessageEditOptions} options The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Update the content of a message\n   * message.edit('This is my new content!')\n   *   .then(msg => console.log(`Updated the content of a message to ${msg.content}`))\n   *   .catch(console.error);\n   */\n  edit(options) {\n    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));\n    return this.channel.messages.edit(this, options);\n  }\n\n  /**\n   * Publishes a message in an announcement channel to all channels following it.\n   * @returns {Promise<Message>}\n   * @example\n   * // Crosspost a message\n   * if (message.channel.type === ChannelType.GuildAnnouncement) {\n   *   message.crosspost()\n   *     .then(() => console.log('Crossposted message'))\n   *     .catch(console.error);\n   * }\n   */\n  crosspost() {\n    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));\n    return this.channel.messages.crosspost(this.id);\n  }\n\n  /**\n   * Pins this message to the channel's pinned messages.\n   * @param {string} [reason] Reason for pinning\n   * @returns {Promise<Message>}\n   * @example\n   * // Pin a message\n   * message.pin()\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  async pin(reason) {\n    if (!this.channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);\n    await this.channel.messages.pin(this.id, reason);\n    return this;\n  }\n\n  /**\n   * Unpins this message from the channel's pinned messages.\n   * @param {string} [reason] Reason for unpinning\n   * @returns {Promise<Message>}\n   * @example\n   * // Unpin a message\n   * message.unpin()\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  async unpin(reason) {\n    if (!this.channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);\n    await this.channel.messages.unpin(this.id, reason);\n    return this;\n  }\n\n  /**\n   * Adds a reaction to the message.\n   * @param {EmojiIdentifierResolvable} emoji The emoji to react with\n   * @returns {Promise<MessageReaction>}\n   * @example\n   * // React to a message with a unicode emoji\n   * message.react('ðŸ¤”')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // React to a message with a custom emoji\n   * message.react(message.guild.emojis.cache.get('123456789012345678'))\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async react(emoji) {\n    if (!this.channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);\n    await this.channel.messages.react(this.id, emoji);\n\n    return this.client.actions.MessageReactionAdd.handle(\n      {\n        [this.client.actions.injectedUser]: this.client.user,\n        [this.client.actions.injectedChannel]: this.channel,\n        [this.client.actions.injectedMessage]: this,\n        emoji: resolvePartialEmoji(emoji),\n      },\n      true,\n    ).reaction;\n  }\n\n  /**\n   * Deletes the message.\n   * @returns {Promise<Message>}\n   * @example\n   * // Delete a message\n   * message.delete()\n   *   .then(msg => console.log(`Deleted message from ${msg.author.username}`))\n   *   .catch(console.error);\n   */\n  async delete() {\n    if (!this.channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);\n    await this.channel.messages.delete(this.id);\n    return this;\n  }\n\n  /**\n   * Options provided when sending a message as an inline reply.\n   * @typedef {BaseMessageCreateOptions} MessageReplyOptions\n   * @property {boolean} [failIfNotExists=this.client.options.failIfNotExists] Whether to error if the referenced\n   * message does not exist (creates a standard message in this case when false)\n   */\n\n  /**\n   * Send an inline reply to this message.\n   * @param {string|MessagePayload|MessageReplyOptions} options The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Reply to a message\n   * message.reply('This is a reply!')\n   *   .then(() => console.log(`Replied to message \"${message.content}\"`))\n   *   .catch(console.error);\n   */\n  reply(options) {\n    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));\n    let data;\n\n    if (options instanceof MessagePayload) {\n      data = options;\n    } else {\n      data = MessagePayload.create(this, options, {\n        reply: {\n          messageReference: this,\n          failIfNotExists: options?.failIfNotExists ?? this.client.options.failIfNotExists,\n        },\n      });\n    }\n    return this.channel.send(data);\n  }\n\n  /**\n   * Options for starting a thread on a message.\n   * @typedef {Object} StartThreadOptions\n   * @property {string} name The name of the new thread\n   * @property {ThreadAutoArchiveDuration} [autoArchiveDuration=this.channel.defaultAutoArchiveDuration] The amount of\n   * time after which the thread should automatically archive in case of no recent activity\n   * @property {string} [reason] Reason for creating the thread\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the thread in seconds\n   */\n\n  /**\n   * Create a new public thread from this message\n   * @see GuildTextThreadManager#create\n   * @param {StartThreadOptions} [options] Options for starting a thread on this message\n   * @returns {Promise<ThreadChannel>}\n   */\n  startThread(options = {}) {\n    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));\n    if (![ChannelType.GuildText, ChannelType.GuildAnnouncement].includes(this.channel.type)) {\n      return Promise.reject(new DiscordjsError(ErrorCodes.MessageThreadParent));\n    }\n    if (this.hasThread) return Promise.reject(new DiscordjsError(ErrorCodes.MessageExistingThread));\n    return this.channel.threads.create({ ...options, startMessage: this });\n  }\n\n  /**\n   * Fetch this message.\n   * @param {boolean} [force=true] Whether to skip the cache check and request the API\n   * @returns {Promise<Message>}\n   */\n  fetch(force = true) {\n    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));\n    return this.channel.messages.fetch({ message: this.id, force });\n  }\n\n  /**\n   * Fetches the webhook used to create this message.\n   * @returns {Promise<?Webhook>}\n   */\n  fetchWebhook() {\n    if (!this.webhookId) return Promise.reject(new DiscordjsError(ErrorCodes.WebhookMessage));\n    if (this.webhookId === this.applicationId) return Promise.reject(new DiscordjsError(ErrorCodes.WebhookApplication));\n    return this.client.fetchWebhook(this.webhookId);\n  }\n\n  /**\n   * Suppresses or unsuppresses embeds on a message.\n   * @param {boolean} [suppress=true] If the embeds should be suppressed or not\n   * @returns {Promise<Message>}\n   */\n  suppressEmbeds(suppress = true) {\n    const flags = new MessageFlagsBitField(this.flags.bitfield);\n\n    if (suppress) {\n      flags.add(MessageFlags.SuppressEmbeds);\n    } else {\n      flags.remove(MessageFlags.SuppressEmbeds);\n    }\n\n    return this.edit({ flags });\n  }\n\n  /**\n   * Removes the attachments from this message.\n   * @returns {Promise<Message>}\n   */\n  removeAttachments() {\n    return this.edit({ attachments: [] });\n  }\n\n  /**\n   * Resolves a component by a custom id.\n   * @param {string} customId The custom id to resolve against\n   * @returns {?MessageActionRowComponent}\n   */\n  resolveComponent(customId) {\n    return this.components.flatMap(row => row.components).find(component => component.customId === customId) ?? null;\n  }\n\n  /**\n   * Used mainly internally. Whether two messages are identical in properties. If you want to compare messages\n   * without checking all the properties, use `message.id === message2.id`, which is much more efficient. This\n   * method allows you to see if there are differences in content, embeds, attachments, nonce and tts properties.\n   * @param {Message} message The message to compare it to\n   * @param {APIMessage} rawData Raw data passed through the WebSocket about this message\n   * @returns {boolean}\n   */\n  equals(message, rawData) {\n    if (!message) return false;\n    const embedUpdate = !message.author && !message.attachments;\n    if (embedUpdate) return this.id === message.id && this.embeds.length === message.embeds.length;\n\n    let equal =\n      this.id === message.id &&\n      this.author.id === message.author.id &&\n      this.content === message.content &&\n      this.tts === message.tts &&\n      this.nonce === message.nonce &&\n      this.embeds.length === message.embeds.length &&\n      this.attachments.length === message.attachments.length;\n\n    if (equal && rawData) {\n      equal =\n        this.mentions.everyone === message.mentions.everyone &&\n        this.createdTimestamp === Date.parse(rawData.timestamp) &&\n        this.editedTimestamp === Date.parse(rawData.edited_timestamp);\n    }\n\n    return equal;\n  }\n\n  /**\n   * Whether this message is from a guild.\n   * @returns {boolean}\n   */\n  inGuild() {\n    return Boolean(this.guildId);\n  }\n\n  /**\n   * When concatenated with a string, this automatically concatenates the message's content instead of the object.\n   * @returns {string}\n   * @example\n   * // Logs: Message: This is a message!\n   * console.log(`Message: ${message}`);\n   */\n  toString() {\n    return this.content;\n  }\n\n  toJSON() {\n    return super.toJSON({\n      channel: 'channelId',\n      author: 'authorId',\n      groupActivityApplication: 'groupActivityApplicationId',\n      guild: 'guildId',\n      cleanContent: true,\n      member: false,\n      reactions: false,\n    });\n  }\n}\n\nexports.Message = Message;\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAM;EAAEA;AAAY,CAAC,GAAGC,OAAO,CAAC,qBAAqB,CAAC;AACtD,MAAM;EAAEC;AAAW,CAAC,GAAGD,OAAO,CAAC,uBAAuB,CAAC;AACvD,MAAM;EAAEE;AAAiB,CAAC,GAAGF,OAAO,CAAC,qBAAqB,CAAC;AAC3D,MAAM;EACJG,eAAe;EACfC,WAAW;EACXC,WAAW;EACXC,YAAY;EACZC;AACF,CAAC,GAAGP,OAAO,CAAC,uBAAuB,CAAC;AACpC,MAAMQ,UAAU,GAAGR,OAAO,CAAC,cAAc,CAAC;AAC1C,MAAMS,IAAI,GAAGT,OAAO,CAAC,QAAQ,CAAC;AAC9B,MAAMU,iBAAiB,GAAGV,OAAO,CAAC,qBAAqB,CAAC;AACxD,MAAMW,KAAK,GAAGX,OAAO,CAAC,SAAS,CAAC;AAChC,MAAMY,oBAAoB,GAAGZ,OAAO,CAAC,wBAAwB,CAAC;AAC9D,MAAMa,QAAQ,GAAGb,OAAO,CAAC,mBAAmB,CAAC;AAC7C,MAAMc,cAAc,GAAGd,OAAO,CAAC,kBAAkB,CAAC;AAClD,MAAMe,iBAAiB,GAAGf,OAAO,CAAC,qBAAqB,CAAC;AACxD,MAAM;EAAEgB;AAAQ,CAAC,GAAGhB,OAAO,CAAC,WAAW,CAAC;AACxC,MAAM;EAAEiB,cAAc;EAAEC;AAAW,CAAC,GAAGlB,OAAO,CAAC,WAAW,CAAC;AAC3D,MAAMmB,eAAe,GAAGnB,OAAO,CAAC,6BAA6B,CAAC;AAC9D,MAAM;EAAEoB;AAAgB,CAAC,GAAGpB,OAAO,CAAC,oBAAoB,CAAC;AACzD,MAAM;EAAEqB,qBAAqB;EAAEC,0BAA0B;EAAEC;AAAsB,CAAC,GAAGvB,OAAO,CAAC,mBAAmB,CAAC;AACjH,MAAMwB,oBAAoB,GAAGxB,OAAO,CAAC,8BAA8B,CAAC;AACpE,MAAMyB,mBAAmB,GAAGzB,OAAO,CAAC,6BAA6B,CAAC;AAClE,MAAM;EAAE0B,YAAY;EAAEC;AAAoB,CAAC,GAAG3B,OAAO,CAAC,cAAc,CAAC;;AAErE;AACA;AACA;AACA;AACA,MAAM4B,OAAO,SAASnB,IAAI,CAAC;EACzBoB,WAAWA,CAACC,MAAM,EAAEC,IAAI,EAAE;IACxB,KAAK,CAACD,MAAM,CAAC;;IAEb;AACJ;AACA;AACA;IACI,IAAI,CAACE,SAAS,GAAGD,IAAI,CAACE,UAAU;;IAEhC;AACJ;AACA;AACA;IACI,IAAI,CAACC,OAAO,GAAGH,IAAI,CAACI,QAAQ,IAAI,IAAI,CAACC,OAAO,EAAEC,KAAK,EAAEC,EAAE,IAAI,IAAI;IAE/D,IAAI,CAACC,MAAM,CAACR,IAAI,CAAC;EACnB;EAEAQ,MAAMA,CAACR,IAAI,EAAE;IACX;AACJ;AACA;AACA;IACI,IAAI,CAACO,EAAE,GAAGP,IAAI,CAACO,EAAE;;IAEjB;AACJ;AACA;AACA;IACI,IAAI,CAACE,gBAAgB,GAAGtC,gBAAgB,CAACuC,aAAa,CAAC,IAAI,CAACH,EAAE,CAAC;IAE/D,IAAI,MAAM,IAAIP,IAAI,EAAE;MAClB;AACN;AACA;AACA;MACM,IAAI,CAACW,IAAI,GAAGX,IAAI,CAACW,IAAI;;MAErB;AACN;AACA;AACA;MACM,IAAI,CAACC,MAAM,GAAG,CAACtB,qBAAqB,CAACuB,QAAQ,CAAC,IAAI,CAACF,IAAI,CAAC;IAC1D,CAAC,MAAM;MACL,IAAI,CAACC,MAAM,KAAK,IAAI;MACpB,IAAI,CAACD,IAAI,KAAK,IAAI;IACpB;IAEA,IAAI,SAAS,IAAIX,IAAI,EAAE;MACrB;AACN;AACA;AACA;AACA;AACA;MACM,IAAI,CAACc,OAAO,GAAGd,IAAI,CAACc,OAAO;IAC7B,CAAC,MAAM;MACL,IAAI,CAACA,OAAO,KAAK,IAAI;IACvB;IAEA,IAAI,QAAQ,IAAId,IAAI,EAAE;MACpB;AACN;AACA;AACA;MACM,IAAI,CAACe,MAAM,GAAG,IAAI,CAAChB,MAAM,CAACiB,KAAK,CAACC,IAAI,CAACjB,IAAI,CAACe,MAAM,EAAE,CAACf,IAAI,CAACkB,UAAU,CAAC;IACrE,CAAC,MAAM;MACL,IAAI,CAACH,MAAM,KAAK,IAAI;IACtB;IAEA,IAAI,QAAQ,IAAIf,IAAI,EAAE;MACpB;AACN;AACA;AACA;MACM,IAAI,CAACmB,MAAM,GAAGC,OAAO,CAACpB,IAAI,CAACmB,MAAM,CAAC;IACpC,CAAC,MAAM;MACL,IAAI,CAACA,MAAM,KAAK,IAAI;IACtB;IAEA,IAAI,KAAK,IAAInB,IAAI,EAAE;MACjB;AACN;AACA;AACA;MACM,IAAI,CAACqB,GAAG,GAAGrB,IAAI,CAACqB,GAAG;IACrB,CAAC,MAAM;MACL,IAAI,CAACA,GAAG,KAAK,IAAI;IACnB;IAEA,IAAI,OAAO,IAAIrB,IAAI,EAAE;MACnB;AACN;AACA;AACA;AACA;AACA;MACM,IAAI,CAACsB,KAAK,GAAGtB,IAAI,CAACsB,KAAK;IACzB,CAAC,MAAM;MACL,IAAI,CAACA,KAAK,KAAK,IAAI;IACrB;IAEA,IAAI,QAAQ,IAAItB,IAAI,EAAE;MACpB;AACN;AACA;AACA;AACA;AACA;MACM,IAAI,CAACuB,MAAM,GAAGvB,IAAI,CAACuB,MAAM,CAACC,GAAG,CAACC,CAAC,IAAI,IAAI7C,KAAK,CAAC6C,CAAC,CAAC,CAAC;IAClD,CAAC,MAAM;MACL,IAAI,CAACF,MAAM,GAAG,IAAI,CAACA,MAAM,EAAEG,KAAK,CAAC,CAAC,IAAI,EAAE;IAC1C;IAEA,IAAI,YAAY,IAAI1B,IAAI,EAAE;MACxB;AACN;AACA;AACA;AACA;AACA;MACM,IAAI,CAAC2B,UAAU,GAAG3B,IAAI,CAAC2B,UAAU,CAACH,GAAG,CAACI,CAAC,IAAIvC,eAAe,CAACuC,CAAC,CAAC,CAAC;IAChE,CAAC,MAAM;MACL,IAAI,CAACD,UAAU,GAAG,IAAI,CAACA,UAAU,EAAED,KAAK,CAAC,CAAC,IAAI,EAAE;IAClD;IAEA,IAAI,aAAa,IAAI1B,IAAI,EAAE;MACzB;AACN;AACA;AACA;AACA;AACA;MACM,IAAI,CAAC6B,WAAW,GAAG,IAAI3D,UAAU,CAAC,CAAC;MACnC,IAAI8B,IAAI,CAAC6B,WAAW,EAAE;QACpB,KAAK,MAAMC,UAAU,IAAI9B,IAAI,CAAC6B,WAAW,EAAE;UACzC,IAAI,CAACA,WAAW,CAACE,GAAG,CAACD,UAAU,CAACvB,EAAE,EAAE,IAAI9B,UAAU,CAACqD,UAAU,CAAC,CAAC;QACjE;MACF;IACF,CAAC,MAAM;MACL,IAAI,CAACD,WAAW,GAAG,IAAI3D,UAAU,CAAC,IAAI,CAAC2D,WAAW,CAAC;IACrD;IAEA,IAAI,eAAe,IAAI7B,IAAI,IAAI,UAAU,IAAIA,IAAI,EAAE;MACjD;AACN;AACA;AACA;MACM,IAAI,CAACgC,QAAQ,GAAG,IAAI9D,UAAU,CAC5B,CAAC8B,IAAI,CAACiC,aAAa,IAAIjC,IAAI,CAACgC,QAAQ,GAAGR,GAAG,CAACU,CAAC,IAAI,CAACA,CAAC,CAAC3B,EAAE,EAAE,IAAItB,OAAO,CAAC,IAAI,CAACc,MAAM,EAAEmC,CAAC,CAAC,CAAC,CACrF,CAAC;IACH,CAAC,MAAM;MACL,IAAI,CAACF,QAAQ,GAAG,IAAI9D,UAAU,CAAC,IAAI,CAAC8D,QAAQ,CAAC;IAC/C;IAEA,IAAI,UAAU,IAAIhC,IAAI,EAAE;MACtB;AACN;AACA;AACA;AACA;MACM,IAAI,CAACmC,QAAQ,GAAGnC,IAAI,CAACmC,QAAQ;IAC/B,CAAC,MAAM;MACL,IAAI,CAACA,QAAQ,KAAK,IAAI;IACxB;IAEA,IAAI,wBAAwB,IAAInC,IAAI,EAAE;MACpC;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;MAEM;AACN;AACA;AACA;AACA;MACM,IAAI,CAACoC,oBAAoB,GAAG;QAC1BC,yBAAyB,EAAErC,IAAI,CAACsC,sBAAsB,CAACC,4BAA4B;QACnFC,QAAQ,EAAExC,IAAI,CAACsC,sBAAsB,CAACG,SAAS;QAC/CC,qBAAqB,EAAE1C,IAAI,CAACsC,sBAAsB,CAACK,uBAAuB;QAC1EC,SAAS,EAAE5C,IAAI,CAACsC,sBAAsB,CAACO;MACzC,CAAC;IACH,CAAC,MAAM;MACL,IAAI,CAACT,oBAAoB,KAAK,IAAI;IACpC;;IAEA;IACA,IAAIpC,IAAI,CAAC8C,gBAAgB,EAAE;MACzB;AACN;AACA;AACA;MACM,IAAI,CAACC,eAAe,GAAGC,IAAI,CAACC,KAAK,CAACjD,IAAI,CAAC8C,gBAAgB,CAAC;IAC1D,CAAC,MAAM;MACL,IAAI,CAACC,eAAe,KAAK,IAAI;IAC/B;IAEA,IAAI,WAAW,IAAI/C,IAAI,EAAE;MACvB;AACN;AACA;AACA;MACM,IAAI,CAACkD,SAAS,GAAG,IAAI9D,eAAe,CAAC,IAAI,CAAC;MAC1C,IAAIY,IAAI,CAACkD,SAAS,EAAEC,MAAM,GAAG,CAAC,EAAE;QAC9B,KAAK,MAAMC,QAAQ,IAAIpD,IAAI,CAACkD,SAAS,EAAE;UACrC,IAAI,CAACA,SAAS,CAACjC,IAAI,CAACmC,QAAQ,CAAC;QAC/B;MACF;IACF,CAAC,MAAM;MACL,IAAI,CAACF,SAAS,KAAK,IAAI9D,eAAe,CAAC,IAAI,CAAC;IAC9C;IAEA,IAAI,CAAC,IAAI,CAACiE,QAAQ,EAAE;MAClB;AACN;AACA;AACA;MACM,IAAI,CAACA,QAAQ,GAAG,IAAIvE,QAAQ,CAC1B,IAAI,EACJkB,IAAI,CAACqD,QAAQ,EACbrD,IAAI,CAACsD,aAAa,EAClBtD,IAAI,CAACuD,gBAAgB,EACrBvD,IAAI,CAACwD,gBAAgB,EACrBxD,IAAI,CAACyD,kBAAkB,EAAE1C,MAC3B,CAAC;IACH,CAAC,MAAM;MACL,IAAI,CAACsC,QAAQ,GAAG,IAAIvE,QAAQ,CAC1B,IAAI,EACJkB,IAAI,CAACqD,QAAQ,IAAI,IAAI,CAACA,QAAQ,CAACrC,KAAK,EACpChB,IAAI,CAACsD,aAAa,IAAI,IAAI,CAACD,QAAQ,CAACK,KAAK,EACzC1D,IAAI,CAACuD,gBAAgB,IAAI,IAAI,CAACF,QAAQ,CAACM,QAAQ,EAC/C3D,IAAI,CAACwD,gBAAgB,IAAI,IAAI,CAACH,QAAQ,CAACO,mBAAmB,EAC1D5D,IAAI,CAACyD,kBAAkB,EAAE1C,MAAM,IAAI,IAAI,CAACsC,QAAQ,CAACQ,WACnD,CAAC;IACH;IAEA,IAAI,YAAY,IAAI7D,IAAI,EAAE;MACxB;AACN;AACA;AACA;MACM,IAAI,CAAC8D,SAAS,GAAG9D,IAAI,CAACkB,UAAU;IAClC,CAAC,MAAM;MACL,IAAI,CAAC4C,SAAS,KAAK,IAAI;IACzB;IAEA,IAAI,aAAa,IAAI9D,IAAI,EAAE;MACzB;AACN;AACA;AACA;MACM,IAAI,CAAC+D,wBAAwB,GAAG,IAAIpF,iBAAiB,CAAC,IAAI,CAACoB,MAAM,EAAEC,IAAI,CAACgE,WAAW,CAAC;IACtF,CAAC,MAAM;MACL,IAAI,CAACD,wBAAwB,KAAK,IAAI;IACxC;IAEA,IAAI,gBAAgB,IAAI/D,IAAI,EAAE;MAC5B;AACN;AACA;AACA;MACM,IAAI,CAACiE,aAAa,GAAGjE,IAAI,CAACkE,cAAc;IAC1C,CAAC,MAAM;MACL,IAAI,CAACD,aAAa,KAAK,IAAI;IAC7B;IAEA,IAAI,UAAU,IAAIjE,IAAI,EAAE;MACtB;AACN;AACA;AACA;MACM,IAAI,CAACmE,QAAQ,GAAG;QACdC,OAAO,EAAEpE,IAAI,CAACmE,QAAQ,CAACE,QAAQ;QAC/B1D,IAAI,EAAEX,IAAI,CAACmE,QAAQ,CAACxD;MACtB,CAAC;IACH,CAAC,MAAM;MACL,IAAI,CAACwD,QAAQ,KAAK,IAAI;IACxB;IAEA,IAAI,QAAQ,IAAInE,IAAI,EAAE;MACpB,IAAI,CAACD,MAAM,CAACuE,QAAQ,CAACrD,IAAI,CAACjB,IAAI,CAACuE,MAAM,EAAE,IAAI,CAACjE,KAAK,CAAC;IACpD;IAEA,IAAI,IAAI,CAACkE,MAAM,IAAIxE,IAAI,CAACwE,MAAM,EAAE;MAC9B,IAAI,CAACA,MAAM,CAAChE,MAAM,CAACR,IAAI,CAACwE,MAAM,CAAC;IACjC,CAAC,MAAM,IAAIxE,IAAI,CAACwE,MAAM,IAAI,IAAI,CAAClE,KAAK,IAAI,IAAI,CAACS,MAAM,EAAE;MACnD,IAAI,CAACT,KAAK,CAACmE,OAAO,CAACxD,IAAI,CAACyD,MAAM,CAACC,MAAM,CAAC3E,IAAI,CAACwE,MAAM,EAAE;QAAEI,IAAI,EAAE,IAAI,CAAC7D;MAAO,CAAC,CAAC,CAAC;IAC5E;IAEA,IAAI,OAAO,IAAIf,IAAI,EAAE;MACnB;AACN;AACA;AACA;MACM,IAAI,CAAC6E,KAAK,GAAG,IAAIpF,oBAAoB,CAACO,IAAI,CAAC6E,KAAK,CAAC,CAACC,MAAM,CAAC,CAAC;IAC5D,CAAC,MAAM;MACL,IAAI,CAACD,KAAK,GAAG,IAAIpF,oBAAoB,CAAC,IAAI,CAACoF,KAAK,CAAC,CAACC,MAAM,CAAC,CAAC;IAC5D;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAEI,IAAI,mBAAmB,IAAI9E,IAAI,EAAE;MAC/B;AACN;AACA;AACA;MACM,IAAI,CAAC+E,SAAS,GAAG;QACf9E,SAAS,EAAED,IAAI,CAACgF,iBAAiB,CAAC9E,UAAU;QAC5CC,OAAO,EAAEH,IAAI,CAACgF,iBAAiB,CAAC5E,QAAQ;QACxC6E,SAAS,EAAEjF,IAAI,CAACgF,iBAAiB,CAACE;MACpC,CAAC;IACH,CAAC,MAAM;MACL,IAAI,CAACH,SAAS,KAAK,IAAI;IACzB;IAEA,IAAI/E,IAAI,CAACyD,kBAAkB,EAAE;MAC3B,IAAI,CAACpD,OAAO,EAAE8E,QAAQ,CAAClE,IAAI,CAAC;QAAEb,QAAQ,EAAEJ,IAAI,CAACgF,iBAAiB,EAAE5E,QAAQ;QAAE,GAAGJ,IAAI,CAACyD;MAAmB,CAAC,CAAC;IACzG;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAEI,IAAIzD,IAAI,CAACoF,WAAW,EAAE;MACpB;AACN;AACA;AACA;MACM,IAAI,CAACA,WAAW,GAAG;QACjB7E,EAAE,EAAEP,IAAI,CAACoF,WAAW,CAAC7E,EAAE;QACvBI,IAAI,EAAEX,IAAI,CAACoF,WAAW,CAACzE,IAAI;QAC3B0E,WAAW,EAAErF,IAAI,CAACoF,WAAW,CAACE,IAAI;QAClCV,IAAI,EAAE,IAAI,CAAC7E,MAAM,CAACiB,KAAK,CAACC,IAAI,CAACjB,IAAI,CAACoF,WAAW,CAACR,IAAI;MACpD,CAAC;IACH,CAAC,MAAM;MACL,IAAI,CAACQ,WAAW,KAAK,IAAI;IAC3B;EACF;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAI/E,OAAOA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACN,MAAM,CAACuE,QAAQ,CAACiB,OAAO,CAAC,IAAI,CAACtF,SAAS,CAAC;EACrD;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIuF,OAAOA,CAAA,EAAG;IACZ,OAAO,OAAO,IAAI,CAAC1E,OAAO,KAAK,QAAQ,IAAI,CAAC,IAAI,CAACC,MAAM;EACzD;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,IAAIyD,MAAMA,CAAA,EAAG;IACX,OAAO,IAAI,CAAClE,KAAK,EAAEmE,OAAO,CAACc,OAAO,CAAC,IAAI,CAACxE,MAAM,CAAC,IAAI,IAAI;EACzD;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAI0E,SAASA,CAAA,EAAG;IACd,OAAO,IAAIzC,IAAI,CAAC,IAAI,CAACvC,gBAAgB,CAAC;EACxC;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIiF,QAAQA,CAAA,EAAG;IACb,OAAO,IAAI,CAAC3C,eAAe,IAAI,IAAIC,IAAI,CAAC,IAAI,CAACD,eAAe,CAAC;EAC/D;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIzC,KAAKA,CAAA,EAAG;IACV,OAAO,IAAI,CAACP,MAAM,CAAC4F,MAAM,CAACJ,OAAO,CAAC,IAAI,CAACpF,OAAO,CAAC,IAAI,IAAI,CAACE,OAAO,EAAEC,KAAK,IAAI,IAAI;EAChF;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIsF,SAASA,CAAA,EAAG;IACd,OAAO,IAAI,CAACf,KAAK,CAACgB,GAAG,CAACtH,YAAY,CAACuH,SAAS,CAAC;EAC/C;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAIvB,MAAMA,CAAA,EAAG;IACX,OAAO,IAAI,CAAClE,OAAO,EAAE0F,OAAO,EAAER,OAAO,CAAC,IAAI,CAAChF,EAAE,CAAC,IAAI,IAAI;EACxD;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIyF,GAAGA,CAAA,EAAG;IACR,OAAO,IAAI,CAACC,OAAO,CAAC,CAAC,GAAGjI,WAAW,CAAC,IAAI,CAACiC,SAAS,EAAE,IAAI,CAACM,EAAE,EAAE,IAAI,CAACJ,OAAO,CAAC,GAAGnC,WAAW,CAAC,IAAI,CAACiC,SAAS,EAAE,IAAI,CAACM,EAAE,CAAC;EACnH;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,IAAIZ,YAAYA,CAAA,EAAG;IACjB;IACA,OAAO,IAAI,CAACmB,OAAO,IAAI,IAAI,GAAGnB,YAAY,CAAC,IAAI,CAACmB,OAAO,EAAE,IAAI,CAACT,OAAO,CAAC,GAAG,IAAI;EAC/E;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE6F,uBAAuBA,CAACC,OAAO,GAAG,CAAC,CAAC,EAAE;IACpC,OAAO,IAAInH,iBAAiB,CAAC,IAAI,EAAEmH,OAAO,CAAC;EAC7C;;EAEA;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,cAAcA,CAACD,OAAO,GAAG,CAAC,CAAC,EAAE;IAC3B,OAAO,IAAIE,OAAO,CAAC,CAACd,OAAO,EAAEe,MAAM,KAAK;MACtC,MAAMC,SAAS,GAAG,IAAI,CAACL,uBAAuB,CAACC,OAAO,CAAC;MACvDI,SAAS,CAACC,IAAI,CAAC,KAAK,EAAE,CAACtD,SAAS,EAAEuD,MAAM,KAAK;QAC3C,IAAIN,OAAO,CAACO,MAAM,EAAE7F,QAAQ,CAAC4F,MAAM,CAAC,EAAEH,MAAM,CAACpD,SAAS,CAAC,CAAC,KACnDqC,OAAO,CAACrC,SAAS,CAAC;MACzB,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEyD,+BAA+BA,CAACR,OAAO,GAAG,CAAC,CAAC,EAAE;IAC5C,OAAO,IAAItH,oBAAoB,CAAC,IAAI,CAACkB,MAAM,EAAE;MAC3C,GAAGoG,OAAO;MACVS,eAAe,EAAExI,eAAe,CAACyI,gBAAgB;MACjDC,OAAO,EAAE;IACX,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,qBAAqBA,CAACZ,OAAO,GAAG,CAAC,CAAC,EAAE;IAClC,MAAMa,QAAQ,GAAG;MAAE,GAAGb,OAAO;MAAEc,GAAG,EAAE;IAAE,CAAC;IACvC,OAAO,IAAIZ,OAAO,CAAC,CAACd,OAAO,EAAEe,MAAM,KAAK;MACtC,MAAMC,SAAS,GAAG,IAAI,CAACI,+BAA+B,CAACK,QAAQ,CAAC;MAChET,SAAS,CAACC,IAAI,CAAC,KAAK,EAAE,CAACU,YAAY,EAAET,MAAM,KAAK;QAC9C,MAAMrB,WAAW,GAAG8B,YAAY,CAACC,KAAK,CAAC,CAAC;QACxC,IAAI/B,WAAW,EAAEG,OAAO,CAACH,WAAW,CAAC,CAAC,KACjCkB,MAAM,CAAC,IAAIpH,cAAc,CAACC,UAAU,CAACiI,yBAAyB,EAAEX,MAAM,CAAC,CAAC;MAC/E,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIY,QAAQA,CAAA,EAAG;IACb,MAAMC,QAAQ,GAAGlG,OAAO,CAAC,IAAI,CAACL,MAAM,CAACR,EAAE,KAAK,IAAI,CAACR,MAAM,CAAC6E,IAAI,CAACrE,EAAE,KAAK,CAAC,IAAI,CAACD,KAAK,IAAI,IAAI,CAACD,OAAO,EAAEkH,QAAQ,CAAC,CAAC;;IAE3G;IACA;IACA,IAAI,IAAI,CAAClH,OAAO,EAAEmH,QAAQ,CAAC,CAAC,EAAE;MAC5B,IAAI,IAAI,CAACnH,OAAO,CAACoH,QAAQ,EAAE,OAAO,KAAK;MACvC,IAAI,IAAI,CAACpH,OAAO,CAACqH,MAAM,EAAE;QACvB,MAAMC,WAAW,GAAG,IAAI,CAACtH,OAAO,CAACuH,cAAc,CAAC,IAAI,CAAC7H,MAAM,CAAC6E,IAAI,CAAC;QACjE,IAAI,CAAC+C,WAAW,EAAE9B,GAAG,CAACrH,mBAAmB,CAACqJ,aAAa,EAAE,IAAI,CAAC,EAAE,OAAO,KAAK;MAC9E;IACF;IAEA,OAAOP,QAAQ;EACjB;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIQ,SAASA,CAAA,EAAG;IACd,IAAI,CAACtI,qBAAqB,CAACqB,QAAQ,CAAC,IAAI,CAACF,IAAI,CAAC,EAAE,OAAO,KAAK;IAE5D,IAAI,CAAC,IAAI,CAACL,KAAK,EAAE;MACf,OAAO,IAAI,CAACS,MAAM,CAACR,EAAE,KAAK,IAAI,CAACR,MAAM,CAAC6E,IAAI,CAACrE,EAAE;IAC/C;IACA;IACA,IAAI,CAAC,IAAI,CAACF,OAAO,EAAEkH,QAAQ,EAAE;MAC3B,OAAO,KAAK;IACd;IAEA,MAAMI,WAAW,GAAG,IAAI,CAACtH,OAAO,EAAEuH,cAAc,CAAC,IAAI,CAAC7H,MAAM,CAAC6E,IAAI,CAAC;IAClE,IAAI,CAAC+C,WAAW,EAAE,OAAO,KAAK;IAC9B;IACA,IAAIA,WAAW,CAAC9B,GAAG,CAACrH,mBAAmB,CAACuJ,aAAa,EAAE,KAAK,CAAC,EAAE,OAAO,IAAI;;IAE1E;IACA,OACG,IAAI,CAACpH,IAAI,KAAKrC,WAAW,CAAC0J,oBAAoB,IAAI,IAAI,CAACjH,MAAM,CAACR,EAAE,KAAK,IAAI,CAACR,MAAM,CAAC6E,IAAI,CAACrE,EAAE,IACxFoH,WAAW,CAAC9B,GAAG,CAACrH,mBAAmB,CAACyJ,cAAc,EAAE,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC3H,KAAK,CAACmE,OAAO,CAACyD,EAAE,CAACC,uBAAuB,CAAC,CAAE;EAEpH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAIC,aAAaA,CAAA,EAAG;IAClB,OACE,CAAC,IAAI,CAACnC,OAAO,CAAC,CAAC,IACbjD,IAAI,CAACqF,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC5H,gBAAgB,GAAGlB,0BAA0B,IAC/D,IAAI,CAACuI,SAAS,IACd,IAAI,CAACzH,OAAO,EAAEuH,cAAc,CAAC,IAAI,CAAC7H,MAAM,CAAC6E,IAAI,CAAC,CAACiB,GAAG,CAACrH,mBAAmB,CAACyJ,cAAc,EAAE,KAAK,CAAC,KAC/F,KAAK;EAET;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIK,QAAQA,CAAA,EAAG;IACb,MAAM;MAAEjI;IAAQ,CAAC,GAAG,IAAI;IACxB,OAAOe,OAAO,CACZ,CAAC,IAAI,CAACR,MAAM,KACT,CAAC,IAAI,CAACN,KAAK,IACTD,OAAO,EAAEkH,QAAQ,IAChBlH,OAAO,EAAEuH,cAAc,CAAC,IAAI,CAAC7H,MAAM,CAAC6E,IAAI,CAAC,EAAEiB,GAAG,CAACrH,mBAAmB,CAACyJ,cAAc,EAAE,KAAK,CAAE,CAClG,CAAC;EACH;;EAEA;AACF;AACA;AACA;EACE,MAAMM,cAAcA,CAAA,EAAG;IACrB,IAAI,CAAC,IAAI,CAACxD,SAAS,EAAE,MAAM,IAAI7F,cAAc,CAACC,UAAU,CAACqJ,uBAAuB,CAAC;IACjF,MAAM;MAAEvI,SAAS;MAAEgF;IAAU,CAAC,GAAG,IAAI,CAACF,SAAS;IAC/C,MAAM1E,OAAO,GAAG,IAAI,CAACN,MAAM,CAACuE,QAAQ,CAACiB,OAAO,CAACtF,SAAS,CAAC;IACvD,IAAI,CAACI,OAAO,EAAE,MAAM,IAAInB,cAAc,CAACC,UAAU,CAACsJ,mBAAmB,CAAC;IACtE,MAAM3B,OAAO,GAAG,MAAMzG,OAAO,CAAC8E,QAAQ,CAACuD,KAAK,CAACzD,SAAS,CAAC;IACvD,OAAO6B,OAAO;EAChB;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAI6B,aAAaA,CAAA,EAAG;IAClB,MAAMC,QAAQ,GACZpK,mBAAmB,CAACqK,YAAY,IAC/B,IAAI,CAAC9H,MAAM,CAACR,EAAE,KAAK,IAAI,CAACR,MAAM,CAAC6E,IAAI,CAACrE,EAAE,GAAGb,mBAAmB,CAACoJ,UAAU,GAAGtK,mBAAmB,CAACyJ,cAAc,CAAC;IAChH,MAAM;MAAE5H;IAAQ,CAAC,GAAG,IAAI;IACxB,OAAOe,OAAO,CACZf,OAAO,EAAEM,IAAI,KAAKtC,WAAW,CAAC0K,iBAAiB,IAC7C,CAAC,IAAI,CAAClE,KAAK,CAACgB,GAAG,CAACtH,YAAY,CAACyK,WAAW,CAAC,IACzC,IAAI,CAACrI,IAAI,KAAKrC,WAAW,CAAC2K,OAAO,IACjC5I,OAAO,CAACkH,QAAQ,IAChBlH,OAAO,CAACuH,cAAc,CAAC,IAAI,CAAC7H,MAAM,CAAC6E,IAAI,CAAC,EAAEiB,GAAG,CAAC+C,QAAQ,EAAE,KAAK,CACjE,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEM,IAAIA,CAAC/C,OAAO,EAAE;IACZ,IAAI,CAAC,IAAI,CAAC9F,OAAO,EAAE,OAAOgG,OAAO,CAACC,MAAM,CAAC,IAAIpH,cAAc,CAACC,UAAU,CAACgK,gBAAgB,CAAC,CAAC;IACzF,OAAO,IAAI,CAAC9I,OAAO,CAAC8E,QAAQ,CAAC+D,IAAI,CAAC,IAAI,EAAE/C,OAAO,CAAC;EAClD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEiD,SAASA,CAAA,EAAG;IACV,IAAI,CAAC,IAAI,CAAC/I,OAAO,EAAE,OAAOgG,OAAO,CAACC,MAAM,CAAC,IAAIpH,cAAc,CAACC,UAAU,CAACgK,gBAAgB,CAAC,CAAC;IACzF,OAAO,IAAI,CAAC9I,OAAO,CAAC8E,QAAQ,CAACiE,SAAS,CAAC,IAAI,CAAC7I,EAAE,CAAC;EACjD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAM8I,GAAGA,CAAC5C,MAAM,EAAE;IAChB,IAAI,CAAC,IAAI,CAACpG,OAAO,EAAE,MAAM,IAAInB,cAAc,CAACC,UAAU,CAACgK,gBAAgB,CAAC;IACxE,MAAM,IAAI,CAAC9I,OAAO,CAAC8E,QAAQ,CAACkE,GAAG,CAAC,IAAI,CAAC9I,EAAE,EAAEkG,MAAM,CAAC;IAChD,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAM6C,KAAKA,CAAC7C,MAAM,EAAE;IAClB,IAAI,CAAC,IAAI,CAACpG,OAAO,EAAE,MAAM,IAAInB,cAAc,CAACC,UAAU,CAACgK,gBAAgB,CAAC;IACxE,MAAM,IAAI,CAAC9I,OAAO,CAAC8E,QAAQ,CAACmE,KAAK,CAAC,IAAI,CAAC/I,EAAE,EAAEkG,MAAM,CAAC;IAClD,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAM8C,KAAKA,CAACC,KAAK,EAAE;IACjB,IAAI,CAAC,IAAI,CAACnJ,OAAO,EAAE,MAAM,IAAInB,cAAc,CAACC,UAAU,CAACgK,gBAAgB,CAAC;IACxE,MAAM,IAAI,CAAC9I,OAAO,CAAC8E,QAAQ,CAACoE,KAAK,CAAC,IAAI,CAAChJ,EAAE,EAAEiJ,KAAK,CAAC;IAEjD,OAAO,IAAI,CAACzJ,MAAM,CAAC0J,OAAO,CAACC,kBAAkB,CAACC,MAAM,CAClD;MACE,CAAC,IAAI,CAAC5J,MAAM,CAAC0J,OAAO,CAACG,YAAY,GAAG,IAAI,CAAC7J,MAAM,CAAC6E,IAAI;MACpD,CAAC,IAAI,CAAC7E,MAAM,CAAC0J,OAAO,CAACI,eAAe,GAAG,IAAI,CAACxJ,OAAO;MACnD,CAAC,IAAI,CAACN,MAAM,CAAC0J,OAAO,CAACK,eAAe,GAAG,IAAI;MAC3CN,KAAK,EAAE5J,mBAAmB,CAAC4J,KAAK;IAClC,CAAC,EACD,IACF,CAAC,CAACpG,QAAQ;EACZ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAM2G,MAAMA,CAAA,EAAG;IACb,IAAI,CAAC,IAAI,CAAC1J,OAAO,EAAE,MAAM,IAAInB,cAAc,CAACC,UAAU,CAACgK,gBAAgB,CAAC;IACxE,MAAM,IAAI,CAAC9I,OAAO,CAAC8E,QAAQ,CAAC4E,MAAM,CAAC,IAAI,CAACxJ,EAAE,CAAC;IAC3C,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEyJ,KAAKA,CAAC7D,OAAO,EAAE;IACb,IAAI,CAAC,IAAI,CAAC9F,OAAO,EAAE,OAAOgG,OAAO,CAACC,MAAM,CAAC,IAAIpH,cAAc,CAACC,UAAU,CAACgK,gBAAgB,CAAC,CAAC;IACzF,IAAInJ,IAAI;IAER,IAAImG,OAAO,YAAYpH,cAAc,EAAE;MACrCiB,IAAI,GAAGmG,OAAO;IAChB,CAAC,MAAM;MACLnG,IAAI,GAAGjB,cAAc,CAACkL,MAAM,CAAC,IAAI,EAAE9D,OAAO,EAAE;QAC1C6D,KAAK,EAAE;UACLE,gBAAgB,EAAE,IAAI;UACtBC,eAAe,EAAEhE,OAAO,EAAEgE,eAAe,IAAI,IAAI,CAACpK,MAAM,CAACoG,OAAO,CAACgE;QACnE;MACF,CAAC,CAAC;IACJ;IACA,OAAO,IAAI,CAAC9J,OAAO,CAAC+J,IAAI,CAACpK,IAAI,CAAC;EAChC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;EACEqK,WAAWA,CAAClE,OAAO,GAAG,CAAC,CAAC,EAAE;IACxB,IAAI,CAAC,IAAI,CAAC9F,OAAO,EAAE,OAAOgG,OAAO,CAACC,MAAM,CAAC,IAAIpH,cAAc,CAACC,UAAU,CAACgK,gBAAgB,CAAC,CAAC;IACzF,IAAI,CAAC,CAAC9K,WAAW,CAACiM,SAAS,EAAEjM,WAAW,CAAC0K,iBAAiB,CAAC,CAAClI,QAAQ,CAAC,IAAI,CAACR,OAAO,CAACM,IAAI,CAAC,EAAE;MACvF,OAAO0F,OAAO,CAACC,MAAM,CAAC,IAAIpH,cAAc,CAACC,UAAU,CAACoL,mBAAmB,CAAC,CAAC;IAC3E;IACA,IAAI,IAAI,CAAC3E,SAAS,EAAE,OAAOS,OAAO,CAACC,MAAM,CAAC,IAAIpH,cAAc,CAACC,UAAU,CAACqL,qBAAqB,CAAC,CAAC;IAC/F,OAAO,IAAI,CAACnK,OAAO,CAAC0F,OAAO,CAACkE,MAAM,CAAC;MAAE,GAAG9D,OAAO;MAAEsE,YAAY,EAAE;IAAK,CAAC,CAAC;EACxE;;EAEA;AACF;AACA;AACA;AACA;EACE/B,KAAKA,CAACgC,KAAK,GAAG,IAAI,EAAE;IAClB,IAAI,CAAC,IAAI,CAACrK,OAAO,EAAE,OAAOgG,OAAO,CAACC,MAAM,CAAC,IAAIpH,cAAc,CAACC,UAAU,CAACgK,gBAAgB,CAAC,CAAC;IACzF,OAAO,IAAI,CAAC9I,OAAO,CAAC8E,QAAQ,CAACuD,KAAK,CAAC;MAAE5B,OAAO,EAAE,IAAI,CAACvG,EAAE;MAAEmK;IAAM,CAAC,CAAC;EACjE;;EAEA;AACF;AACA;AACA;EACEC,YAAYA,CAAA,EAAG;IACb,IAAI,CAAC,IAAI,CAAC7G,SAAS,EAAE,OAAOuC,OAAO,CAACC,MAAM,CAAC,IAAIpH,cAAc,CAACC,UAAU,CAACyL,cAAc,CAAC,CAAC;IACzF,IAAI,IAAI,CAAC9G,SAAS,KAAK,IAAI,CAACG,aAAa,EAAE,OAAOoC,OAAO,CAACC,MAAM,CAAC,IAAIpH,cAAc,CAACC,UAAU,CAAC0L,kBAAkB,CAAC,CAAC;IACnH,OAAO,IAAI,CAAC9K,MAAM,CAAC4K,YAAY,CAAC,IAAI,CAAC7G,SAAS,CAAC;EACjD;;EAEA;AACF;AACA;AACA;AACA;EACEgH,cAAcA,CAACC,QAAQ,GAAG,IAAI,EAAE;IAC9B,MAAMlG,KAAK,GAAG,IAAIpF,oBAAoB,CAAC,IAAI,CAACoF,KAAK,CAAC+D,QAAQ,CAAC;IAE3D,IAAImC,QAAQ,EAAE;MACZlG,KAAK,CAACmG,GAAG,CAACzM,YAAY,CAAC0M,cAAc,CAAC;IACxC,CAAC,MAAM;MACLpG,KAAK,CAACqG,MAAM,CAAC3M,YAAY,CAAC0M,cAAc,CAAC;IAC3C;IAEA,OAAO,IAAI,CAAC/B,IAAI,CAAC;MAAErE;IAAM,CAAC,CAAC;EAC7B;;EAEA;AACF;AACA;AACA;EACEsG,iBAAiBA,CAAA,EAAG;IAClB,OAAO,IAAI,CAACjC,IAAI,CAAC;MAAErH,WAAW,EAAE;IAAG,CAAC,CAAC;EACvC;;EAEA;AACF;AACA;AACA;AACA;EACEuJ,gBAAgBA,CAACC,QAAQ,EAAE;IACzB,OAAO,IAAI,CAAC1J,UAAU,CAAC2J,OAAO,CAACC,GAAG,IAAIA,GAAG,CAAC5J,UAAU,CAAC,CAAC6J,IAAI,CAACC,SAAS,IAAIA,SAAS,CAACJ,QAAQ,KAAKA,QAAQ,CAAC,IAAI,IAAI;EAClH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEK,MAAMA,CAAC5E,OAAO,EAAE6E,OAAO,EAAE;IACvB,IAAI,CAAC7E,OAAO,EAAE,OAAO,KAAK;IAC1B,MAAM8E,WAAW,GAAG,CAAC9E,OAAO,CAAC/F,MAAM,IAAI,CAAC+F,OAAO,CAACjF,WAAW;IAC3D,IAAI+J,WAAW,EAAE,OAAO,IAAI,CAACrL,EAAE,KAAKuG,OAAO,CAACvG,EAAE,IAAI,IAAI,CAACgB,MAAM,CAAC4B,MAAM,KAAK2D,OAAO,CAACvF,MAAM,CAAC4B,MAAM;IAE9F,IAAI0I,KAAK,GACP,IAAI,CAACtL,EAAE,KAAKuG,OAAO,CAACvG,EAAE,IACtB,IAAI,CAACQ,MAAM,CAACR,EAAE,KAAKuG,OAAO,CAAC/F,MAAM,CAACR,EAAE,IACpC,IAAI,CAACO,OAAO,KAAKgG,OAAO,CAAChG,OAAO,IAChC,IAAI,CAACO,GAAG,KAAKyF,OAAO,CAACzF,GAAG,IACxB,IAAI,CAACC,KAAK,KAAKwF,OAAO,CAACxF,KAAK,IAC5B,IAAI,CAACC,MAAM,CAAC4B,MAAM,KAAK2D,OAAO,CAACvF,MAAM,CAAC4B,MAAM,IAC5C,IAAI,CAACtB,WAAW,CAACsB,MAAM,KAAK2D,OAAO,CAACjF,WAAW,CAACsB,MAAM;IAExD,IAAI0I,KAAK,IAAIF,OAAO,EAAE;MACpBE,KAAK,GACH,IAAI,CAACxI,QAAQ,CAACM,QAAQ,KAAKmD,OAAO,CAACzD,QAAQ,CAACM,QAAQ,IACpD,IAAI,CAAClD,gBAAgB,KAAKuC,IAAI,CAACC,KAAK,CAAC0I,OAAO,CAACG,SAAS,CAAC,IACvD,IAAI,CAAC/I,eAAe,KAAKC,IAAI,CAACC,KAAK,CAAC0I,OAAO,CAAC7I,gBAAgB,CAAC;IACjE;IAEA,OAAO+I,KAAK;EACd;;EAEA;AACF;AACA;AACA;EACE5F,OAAOA,CAAA,EAAG;IACR,OAAO7E,OAAO,CAAC,IAAI,CAACjB,OAAO,CAAC;EAC9B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE4L,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI,CAACjL,OAAO;EACrB;EAEAkL,MAAMA,CAAA,EAAG;IACP,OAAO,KAAK,CAACA,MAAM,CAAC;MAClB3L,OAAO,EAAE,WAAW;MACpBU,MAAM,EAAE,UAAU;MAClBgD,wBAAwB,EAAE,4BAA4B;MACtDzD,KAAK,EAAE,SAAS;MAChBX,YAAY,EAAE,IAAI;MAClB6E,MAAM,EAAE,KAAK;MACbtB,SAAS,EAAE;IACb,CAAC,CAAC;EACJ;AACF;AAEA+I,OAAO,CAACpM,OAAO,GAAGA,OAAO","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}