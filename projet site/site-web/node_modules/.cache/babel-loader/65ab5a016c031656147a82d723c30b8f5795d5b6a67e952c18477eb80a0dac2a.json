{"ast":null,"code":"'use strict';\n\nconst GuildChannel = require('./GuildChannel');\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\nconst GuildMessageManager = require('../managers/GuildMessageManager');\nconst GuildTextThreadManager = require('../managers/GuildTextThreadManager');\n\n/**\n * Represents a text-based guild channel on Discord.\n * @extends {GuildChannel}\n * @implements {TextBasedChannel}\n */\nclass BaseGuildTextChannel extends GuildChannel {\n  constructor(guild, data, client) {\n    super(guild, data, client, false);\n\n    /**\n     * A manager of the messages sent to this channel\n     * @type {GuildMessageManager}\n     */\n    this.messages = new GuildMessageManager(this);\n\n    /**\n     * A manager of the threads belonging to this channel\n     * @type {GuildTextThreadManager}\n     */\n    this.threads = new GuildTextThreadManager(this);\n\n    /**\n     * If the guild considers this channel NSFW\n     * @type {boolean}\n     */\n    this.nsfw = Boolean(data.nsfw);\n    this._patch(data);\n  }\n  _patch(data) {\n    super._patch(data);\n    if ('topic' in data) {\n      /**\n       * The topic of the text channel\n       * @type {?string}\n       */\n      this.topic = data.topic;\n    }\n    if ('nsfw' in data) {\n      this.nsfw = Boolean(data.nsfw);\n    }\n    if ('last_message_id' in data) {\n      /**\n       * The last message id sent in the channel, if one was sent\n       * @type {?Snowflake}\n       */\n      this.lastMessageId = data.last_message_id;\n    }\n    if ('last_pin_timestamp' in data) {\n      /**\n       * The timestamp when the last pinned message was pinned, if there was one\n       * @type {?number}\n       */\n      this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;\n    }\n    if ('default_auto_archive_duration' in data) {\n      /**\n       * The default auto archive duration for newly created threads in this channel\n       * @type {?ThreadAutoArchiveDuration}\n       */\n      this.defaultAutoArchiveDuration = data.default_auto_archive_duration;\n    }\n    if ('messages' in data) {\n      for (const message of data.messages) this.messages._add(message);\n    }\n  }\n\n  /**\n   * Sets the default auto archive duration for all newly created threads in this channel.\n   * @param {ThreadAutoArchiveDuration} defaultAutoArchiveDuration The new default auto archive duration\n   * @param {string} [reason] Reason for changing the channel's default auto archive duration\n   * @returns {Promise<TextChannel>}\n   */\n  setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {\n    return this.edit({\n      defaultAutoArchiveDuration,\n      reason\n    });\n  }\n\n  /**\n   * Sets the type of this channel.\n   * <info>Only conversion between {@link TextChannel} and {@link NewsChannel} is supported.</info>\n   * @param {ChannelType.GuildText|ChannelType.GuildAnnouncement} type The new channel type\n   * @param {string} [reason] Reason for changing the channel's type\n   * @returns {Promise<GuildChannel>}\n   */\n  setType(type, reason) {\n    return this.edit({\n      type,\n      reason\n    });\n  }\n\n  /**\n   * Sets a new topic for the guild channel.\n   * @param {?string} topic The new topic for the guild channel\n   * @param {string} [reason] Reason for changing the guild channel's topic\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel topic\n   * channel.setTopic('needs more rate limiting')\n   *   .then(newChannel => console.log(`Channel's new topic is ${newChannel.topic}`))\n   *   .catch(console.error);\n   */\n  setTopic(topic, reason) {\n    return this.edit({\n      topic,\n      reason\n    });\n  }\n\n  /**\n   * Data that can be resolved to an Application. This can be:\n   * * An Application\n   * * An Activity with associated Application\n   * * A Snowflake\n   * @typedef {Application|Snowflake} ApplicationResolvable\n   */\n\n  /**\n   * Options used to create an invite to a guild channel.\n   * @typedef {Object} InviteCreateOptions\n   * @property {boolean} [temporary] Whether members that joined via the invite should be automatically\n   * kicked after 24 hours if they have not yet received a role\n   * @property {number} [maxAge] How long the invite should last (in seconds, 0 for forever)\n   * @property {number} [maxUses] Maximum number of uses\n   * @property {boolean} [unique] Create a unique invite, or use an existing one with similar settings\n   * @property {UserResolvable} [targetUser] The user whose stream to display for this invite,\n   * required if `targetType` is {@link InviteTargetType.Stream}, the user must be streaming in the channel\n   * @property {ApplicationResolvable} [targetApplication] The embedded application to open for this invite,\n   * required if `targetType` is {@link InviteTargetType.Stream}, the application must have the\n   * {@link InviteTargetType.EmbeddedApplication} flag\n   * @property {InviteTargetType} [targetType] The type of the target for this voice channel invite\n   * @property {string} [reason] The reason for creating the invite\n   */\n\n  /**\n   * Creates an invite to this guild channel.\n   * @param {InviteCreateOptions} [options={}] The options for creating the invite\n   * @returns {Promise<Invite>}\n   * @example\n   * // Create an invite to a channel\n   * channel.createInvite()\n   *   .then(invite => console.log(`Created an invite with a code of ${invite.code}`))\n   *   .catch(console.error);\n   */\n  createInvite(options) {\n    return this.guild.invites.create(this.id, options);\n  }\n\n  /**\n   * Fetches a collection of invites to this guild channel.\n   * Resolves with a collection mapping invites by their codes.\n   * @param {boolean} [cache=true] Whether or not to cache the fetched invites\n   * @returns {Promise<Collection<string, Invite>>}\n   */\n  fetchInvites(cache = true) {\n    return this.guild.invites.fetch({\n      channelId: this.id,\n      cache\n    });\n  }\n\n  // These are here only for documentation purposes - they are implemented by TextBasedChannel\n  /* eslint-disable no-empty-function */\n  get lastMessage() {}\n  get lastPinAt() {}\n  send() {}\n  sendTyping() {}\n  createMessageCollector() {}\n  awaitMessages() {}\n  createMessageComponentCollector() {}\n  awaitMessageComponent() {}\n  bulkDelete() {}\n  fetchWebhooks() {}\n  createWebhook() {}\n  setRateLimitPerUser() {}\n  setNSFW() {}\n}\nTextBasedChannel.applyToClass(BaseGuildTextChannel, true);\nmodule.exports = BaseGuildTextChannel;","map":{"version":3,"names":["GuildChannel","require","TextBasedChannel","GuildMessageManager","GuildTextThreadManager","BaseGuildTextChannel","constructor","guild","data","client","messages","threads","nsfw","Boolean","_patch","topic","lastMessageId","last_message_id","lastPinTimestamp","last_pin_timestamp","Date","parse","defaultAutoArchiveDuration","default_auto_archive_duration","message","_add","setDefaultAutoArchiveDuration","reason","edit","setType","type","setTopic","createInvite","options","invites","create","id","fetchInvites","cache","fetch","channelId","lastMessage","lastPinAt","send","sendTyping","createMessageCollector","awaitMessages","createMessageComponentCollector","awaitMessageComponent","bulkDelete","fetchWebhooks","createWebhook","setRateLimitPerUser","setNSFW","applyToClass","module","exports"],"sources":["C:/Users/hetit/node_modules/discord.js/src/structures/BaseGuildTextChannel.js"],"sourcesContent":["'use strict';\n\nconst GuildChannel = require('./GuildChannel');\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\nconst GuildMessageManager = require('../managers/GuildMessageManager');\nconst GuildTextThreadManager = require('../managers/GuildTextThreadManager');\n\n/**\n * Represents a text-based guild channel on Discord.\n * @extends {GuildChannel}\n * @implements {TextBasedChannel}\n */\nclass BaseGuildTextChannel extends GuildChannel {\n  constructor(guild, data, client) {\n    super(guild, data, client, false);\n\n    /**\n     * A manager of the messages sent to this channel\n     * @type {GuildMessageManager}\n     */\n    this.messages = new GuildMessageManager(this);\n\n    /**\n     * A manager of the threads belonging to this channel\n     * @type {GuildTextThreadManager}\n     */\n    this.threads = new GuildTextThreadManager(this);\n\n    /**\n     * If the guild considers this channel NSFW\n     * @type {boolean}\n     */\n    this.nsfw = Boolean(data.nsfw);\n\n    this._patch(data);\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if ('topic' in data) {\n      /**\n       * The topic of the text channel\n       * @type {?string}\n       */\n      this.topic = data.topic;\n    }\n\n    if ('nsfw' in data) {\n      this.nsfw = Boolean(data.nsfw);\n    }\n\n    if ('last_message_id' in data) {\n      /**\n       * The last message id sent in the channel, if one was sent\n       * @type {?Snowflake}\n       */\n      this.lastMessageId = data.last_message_id;\n    }\n\n    if ('last_pin_timestamp' in data) {\n      /**\n       * The timestamp when the last pinned message was pinned, if there was one\n       * @type {?number}\n       */\n      this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;\n    }\n\n    if ('default_auto_archive_duration' in data) {\n      /**\n       * The default auto archive duration for newly created threads in this channel\n       * @type {?ThreadAutoArchiveDuration}\n       */\n      this.defaultAutoArchiveDuration = data.default_auto_archive_duration;\n    }\n\n    if ('messages' in data) {\n      for (const message of data.messages) this.messages._add(message);\n    }\n  }\n\n  /**\n   * Sets the default auto archive duration for all newly created threads in this channel.\n   * @param {ThreadAutoArchiveDuration} defaultAutoArchiveDuration The new default auto archive duration\n   * @param {string} [reason] Reason for changing the channel's default auto archive duration\n   * @returns {Promise<TextChannel>}\n   */\n  setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {\n    return this.edit({ defaultAutoArchiveDuration, reason });\n  }\n\n  /**\n   * Sets the type of this channel.\n   * <info>Only conversion between {@link TextChannel} and {@link NewsChannel} is supported.</info>\n   * @param {ChannelType.GuildText|ChannelType.GuildAnnouncement} type The new channel type\n   * @param {string} [reason] Reason for changing the channel's type\n   * @returns {Promise<GuildChannel>}\n   */\n  setType(type, reason) {\n    return this.edit({ type, reason });\n  }\n\n  /**\n   * Sets a new topic for the guild channel.\n   * @param {?string} topic The new topic for the guild channel\n   * @param {string} [reason] Reason for changing the guild channel's topic\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel topic\n   * channel.setTopic('needs more rate limiting')\n   *   .then(newChannel => console.log(`Channel's new topic is ${newChannel.topic}`))\n   *   .catch(console.error);\n   */\n  setTopic(topic, reason) {\n    return this.edit({ topic, reason });\n  }\n\n  /**\n   * Data that can be resolved to an Application. This can be:\n   * * An Application\n   * * An Activity with associated Application\n   * * A Snowflake\n   * @typedef {Application|Snowflake} ApplicationResolvable\n   */\n\n  /**\n   * Options used to create an invite to a guild channel.\n   * @typedef {Object} InviteCreateOptions\n   * @property {boolean} [temporary] Whether members that joined via the invite should be automatically\n   * kicked after 24 hours if they have not yet received a role\n   * @property {number} [maxAge] How long the invite should last (in seconds, 0 for forever)\n   * @property {number} [maxUses] Maximum number of uses\n   * @property {boolean} [unique] Create a unique invite, or use an existing one with similar settings\n   * @property {UserResolvable} [targetUser] The user whose stream to display for this invite,\n   * required if `targetType` is {@link InviteTargetType.Stream}, the user must be streaming in the channel\n   * @property {ApplicationResolvable} [targetApplication] The embedded application to open for this invite,\n   * required if `targetType` is {@link InviteTargetType.Stream}, the application must have the\n   * {@link InviteTargetType.EmbeddedApplication} flag\n   * @property {InviteTargetType} [targetType] The type of the target for this voice channel invite\n   * @property {string} [reason] The reason for creating the invite\n   */\n\n  /**\n   * Creates an invite to this guild channel.\n   * @param {InviteCreateOptions} [options={}] The options for creating the invite\n   * @returns {Promise<Invite>}\n   * @example\n   * // Create an invite to a channel\n   * channel.createInvite()\n   *   .then(invite => console.log(`Created an invite with a code of ${invite.code}`))\n   *   .catch(console.error);\n   */\n  createInvite(options) {\n    return this.guild.invites.create(this.id, options);\n  }\n\n  /**\n   * Fetches a collection of invites to this guild channel.\n   * Resolves with a collection mapping invites by their codes.\n   * @param {boolean} [cache=true] Whether or not to cache the fetched invites\n   * @returns {Promise<Collection<string, Invite>>}\n   */\n  fetchInvites(cache = true) {\n    return this.guild.invites.fetch({ channelId: this.id, cache });\n  }\n\n  // These are here only for documentation purposes - they are implemented by TextBasedChannel\n  /* eslint-disable no-empty-function */\n  get lastMessage() {}\n  get lastPinAt() {}\n  send() {}\n  sendTyping() {}\n  createMessageCollector() {}\n  awaitMessages() {}\n  createMessageComponentCollector() {}\n  awaitMessageComponent() {}\n  bulkDelete() {}\n  fetchWebhooks() {}\n  createWebhook() {}\n  setRateLimitPerUser() {}\n  setNSFW() {}\n}\n\nTextBasedChannel.applyToClass(BaseGuildTextChannel, true);\n\nmodule.exports = BaseGuildTextChannel;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}