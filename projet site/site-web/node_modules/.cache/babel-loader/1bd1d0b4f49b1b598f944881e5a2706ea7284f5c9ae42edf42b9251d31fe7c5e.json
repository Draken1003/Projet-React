{"ast":null,"code":"'use strict';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __name = (target, value) => __defProp(target, \"name\", {\n  value,\n  configurable: true\n});\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// src/lib/Snowflake.ts\nvar IncrementSymbol = Symbol(\"@sapphire/snowflake.increment\");\nvar EpochSymbol = Symbol(\"@sapphire/snowflake.epoch\");\nvar ProcessIdSymbol = Symbol(\"@sapphire/snowflake.processId\");\nvar WorkerIdSymbol = Symbol(\"@sapphire/snowflake.workerId\");\nvar MaximumWorkerId = 0b11111n;\nvar MaximumProcessId = 0b11111n;\nvar MaximumIncrement = 0b111111111111n;\nvar _a, _b, _c, _d;\nvar Snowflake = class {\n  /**\n   * @param epoch the epoch to use\n   */\n  constructor(epoch) {\n    /**\n     * Alias for {@link deconstruct}\n     */\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    __publicField(this, \"decode\", this.deconstruct);\n    /**\n     * Internal reference of the epoch passed in the constructor\n     * @internal\n     */\n    __publicField(this, _a);\n    /**\n     * Internal incrementor for generating snowflakes\n     * @internal\n     */\n    __publicField(this, _b, 0n);\n    /**\n     * The process ID that will be used by default in the generate method\n     * @internal\n     */\n    __publicField(this, _c, 1n);\n    /**\n     * The worker ID that will be used by default in the generate method\n     * @internal\n     */\n    __publicField(this, _d, 0n);\n    this[EpochSymbol] = BigInt(epoch instanceof Date ? epoch.getTime() : epoch);\n  }\n  /**\n   * The epoch for this snowflake\n   */\n  get epoch() {\n    return this[EpochSymbol];\n  }\n  /**\n   * Gets the configured process ID\n   */\n  get processId() {\n    return this[ProcessIdSymbol];\n  }\n  /**\n   * Sets the process ID that will be used by default for the {@link generate} method\n   * @param value The new value, will be coerced to BigInt and masked with `0b11111n`\n   */\n  set processId(value) {\n    this[ProcessIdSymbol] = BigInt(value) & MaximumProcessId;\n  }\n  /**\n   * Gets the configured worker ID\n   */\n  get workerId() {\n    return this[WorkerIdSymbol];\n  }\n  /**\n   * Sets the worker ID that will be used by default for the {@link generate} method\n   * @param value The new value, will be coerced to BigInt and masked with `0b11111n`\n   */\n  set workerId(value) {\n    this[WorkerIdSymbol] = BigInt(value) & MaximumWorkerId;\n  }\n  /**\n   * Generates a snowflake given an epoch and optionally a timestamp\n   * @param options options to pass into the generator, see {@link SnowflakeGenerateOptions}\n   *\n   * **note** when `increment` is not provided it defaults to the private `increment` of the instance\n   * @example\n   * ```typescript\n   * const epoch = new Date('2000-01-01T00:00:00.000Z');\n   * const snowflake = new Snowflake(epoch).generate();\n   * ```\n   * @returns A unique snowflake\n   */\n  generate({\n    increment,\n    timestamp = Date.now(),\n    workerId = this[WorkerIdSymbol],\n    processId = this[ProcessIdSymbol]\n  } = {}) {\n    if (timestamp instanceof Date) timestamp = BigInt(timestamp.getTime());else if (typeof timestamp === \"number\") timestamp = BigInt(timestamp);else if (typeof timestamp !== \"bigint\") {\n      throw new TypeError(`\"timestamp\" argument must be a number, bigint, or Date (received ${typeof timestamp})`);\n    }\n    if (typeof increment !== \"bigint\") {\n      increment = this[IncrementSymbol];\n      this[IncrementSymbol] = increment + 1n & MaximumIncrement;\n    }\n    return timestamp - this[EpochSymbol] << 22n | (workerId & MaximumWorkerId) << 17n | (processId & MaximumProcessId) << 12n | increment & MaximumIncrement;\n  }\n  /**\n   * Deconstructs a snowflake given a snowflake ID\n   * @param id the snowflake to deconstruct\n   * @returns a deconstructed snowflake\n   * @example\n   * ```typescript\n   * const epoch = new Date('2000-01-01T00:00:00.000Z');\n   * const snowflake = new Snowflake(epoch).deconstruct('3971046231244935168');\n   * ```\n   */\n  deconstruct(id) {\n    const bigIntId = BigInt(id);\n    const epoch = this[EpochSymbol];\n    return {\n      id: bigIntId,\n      timestamp: (bigIntId >> 22n) + epoch,\n      workerId: bigIntId >> 17n & MaximumWorkerId,\n      processId: bigIntId >> 12n & MaximumProcessId,\n      increment: bigIntId & MaximumIncrement,\n      epoch\n    };\n  }\n  /**\n   * Retrieves the timestamp field's value from a snowflake.\n   * @param id The snowflake to get the timestamp value from.\n   * @returns The UNIX timestamp that is stored in `id`.\n   */\n  timestampFrom(id) {\n    return Number((BigInt(id) >> 22n) + this[EpochSymbol]);\n  }\n  /**\n   * Returns a number indicating whether a reference snowflake comes before, or after, or is same as the given\n   * snowflake in sort order.\n   * @param a The first snowflake to compare.\n   * @param b The second snowflake to compare.\n   * @returns `-1` if `a` is older than `b`, `0` if `a` and `b` are equals, `1` if `a` is newer than `b`.\n   * @example Sort snowflakes in ascending order\n   * ```typescript\n   * const ids = ['737141877803057244', '1056191128120082432', '254360814063058944'];\n   * console.log(ids.sort((a, b) => Snowflake.compare(a, b)));\n   * // → ['254360814063058944', '737141877803057244', '1056191128120082432'];\n   * ```\n   * @example Sort snowflakes in descending order\n   * ```typescript\n   * const ids = ['737141877803057244', '1056191128120082432', '254360814063058944'];\n   * console.log(ids.sort((a, b) => -Snowflake.compare(a, b)));\n   * // → ['1056191128120082432', '737141877803057244', '254360814063058944'];\n   * ```\n   */\n  static compare(a, b) {\n    const typeA = typeof a;\n    return typeA === typeof b ? typeA === \"string\" ? cmpString(a, b) : cmpBigInt(a, b) : cmpBigInt(BigInt(a), BigInt(b));\n  }\n};\n__name(Snowflake, \"Snowflake\");\n_a = EpochSymbol, _b = IncrementSymbol, _c = ProcessIdSymbol, _d = WorkerIdSymbol;\nfunction cmpBigInt(a, b) {\n  return a === b ? 0 : a < b ? -1 : 1;\n}\n__name(cmpBigInt, \"cmpBigInt\");\nfunction cmpString(a, b) {\n  return a === b ? 0 : a.length < b.length ? -1 : a.length > b.length ? 1 : a < b ? -1 : 1;\n}\n__name(cmpString, \"cmpString\");\n\n// src/lib/DiscordSnowflake.ts\nvar DiscordSnowflake = new Snowflake(1420070400000n);\n\n// src/lib/TwitterSnowflake.ts\nvar TwitterSnowflake = new Snowflake(1288834974657n);\nexports.DiscordSnowflake = DiscordSnowflake;\nexports.MaximumIncrement = MaximumIncrement;\nexports.MaximumProcessId = MaximumProcessId;\nexports.MaximumWorkerId = MaximumWorkerId;\nexports.Snowflake = Snowflake;\nexports.TwitterSnowflake = TwitterSnowflake;\n//# sourceMappingURL=out.js.map","map":{"version":3,"names":["IncrementSymbol","Symbol","EpochSymbol","ProcessIdSymbol","WorkerIdSymbol","MaximumWorkerId","MaximumProcessId","MaximumIncrement","_a","_b","_c","_d","Snowflake","constructor","epoch","__publicField","deconstruct","BigInt","Date","getTime","processId","value","workerId","generate","increment","timestamp","now","TypeError","id","bigIntId","timestampFrom","Number","compare","a","b","typeA","cmpString","cmpBigInt","__name","length"],"sources":["C:\\Users\\hetit\\node_modules\\@sapphire\\snowflake\\src\\lib\\Snowflake.ts","C:\\Users\\hetit\\node_modules\\@sapphire\\snowflake\\src\\lib\\DiscordSnowflake.ts","C:\\Users\\hetit\\node_modules\\@sapphire\\snowflake\\src\\lib\\TwitterSnowflake.ts"],"sourcesContent":["const IncrementSymbol = Symbol('@sapphire/snowflake.increment');\nconst EpochSymbol = Symbol('@sapphire/snowflake.epoch');\nconst ProcessIdSymbol = Symbol('@sapphire/snowflake.processId');\nconst WorkerIdSymbol = Symbol('@sapphire/snowflake.workerId');\n\n/**\n * The maximum value the `workerId` field accepts in snowflakes.\n */\nexport const MaximumWorkerId = 0b11111n;\n\n/**\n * The maximum value the `processId` field accepts in snowflakes.\n */\nexport const MaximumProcessId = 0b11111n;\n\n/**\n * The maximum value the `increment` field accepts in snowflakes.\n */\nexport const MaximumIncrement = 0b111111111111n;\n\n/**\n * A class for generating and deconstructing Twitter snowflakes.\n *\n * A {@link https://developer.twitter.com/en/docs/twitter-ids Twitter snowflake}\n * is a 64-bit unsigned integer with 4 fields that have a fixed epoch value.\n *\n * If we have a snowflake `266241948824764416` we can represent it as binary:\n * ```\n * 64                                          22     17     12          0\n *  000000111011000111100001101001000101000000  00001  00000  000000000000\n *           number of ms since epoch           worker  pid    increment\n * ```\n */\nexport class Snowflake {\n\t/**\n\t * Alias for {@link deconstruct}\n\t */\n\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\tpublic decode = this.deconstruct;\n\n\t/**\n\t * Internal reference of the epoch passed in the constructor\n\t * @internal\n\t */\n\tprivate readonly [EpochSymbol]: bigint;\n\n\t/**\n\t * Internal incrementor for generating snowflakes\n\t * @internal\n\t */\n\tprivate [IncrementSymbol] = 0n;\n\n\t/**\n\t * The process ID that will be used by default in the generate method\n\t * @internal\n\t */\n\tprivate [ProcessIdSymbol] = 1n;\n\n\t/**\n\t * The worker ID that will be used by default in the generate method\n\t * @internal\n\t */\n\tprivate [WorkerIdSymbol] = 0n;\n\n\t/**\n\t * @param epoch the epoch to use\n\t */\n\tpublic constructor(epoch: number | bigint | Date) {\n\t\tthis[EpochSymbol] = BigInt(epoch instanceof Date ? epoch.getTime() : epoch);\n\t}\n\n\t/**\n\t * The epoch for this snowflake\n\t */\n\tpublic get epoch(): bigint {\n\t\treturn this[EpochSymbol];\n\t}\n\n\t/**\n\t * Gets the configured process ID\n\t */\n\tpublic get processId(): bigint {\n\t\treturn this[ProcessIdSymbol];\n\t}\n\n\t/**\n\t * Sets the process ID that will be used by default for the {@link generate} method\n\t * @param value The new value, will be coerced to BigInt and masked with `0b11111n`\n\t */\n\tpublic set processId(value: number | bigint) {\n\t\tthis[ProcessIdSymbol] = BigInt(value) & MaximumProcessId;\n\t}\n\n\t/**\n\t * Gets the configured worker ID\n\t */\n\tpublic get workerId(): bigint {\n\t\treturn this[WorkerIdSymbol];\n\t}\n\n\t/**\n\t * Sets the worker ID that will be used by default for the {@link generate} method\n\t * @param value The new value, will be coerced to BigInt and masked with `0b11111n`\n\t */\n\tpublic set workerId(value: number | bigint) {\n\t\tthis[WorkerIdSymbol] = BigInt(value) & MaximumWorkerId;\n\t}\n\n\t/**\n\t * Generates a snowflake given an epoch and optionally a timestamp\n\t * @param options options to pass into the generator, see {@link SnowflakeGenerateOptions}\n\t *\n\t * **note** when `increment` is not provided it defaults to the private `increment` of the instance\n\t * @example\n\t * ```typescript\n\t * const epoch = new Date('2000-01-01T00:00:00.000Z');\n\t * const snowflake = new Snowflake(epoch).generate();\n\t * ```\n\t * @returns A unique snowflake\n\t */\n\tpublic generate({\n\t\tincrement,\n\t\ttimestamp = Date.now(),\n\t\tworkerId = this[WorkerIdSymbol],\n\t\tprocessId = this[ProcessIdSymbol]\n\t}: SnowflakeGenerateOptions = {}) {\n\t\tif (timestamp instanceof Date) timestamp = BigInt(timestamp.getTime());\n\t\telse if (typeof timestamp === 'number') timestamp = BigInt(timestamp);\n\t\telse if (typeof timestamp !== 'bigint') {\n\t\t\tthrow new TypeError(`\"timestamp\" argument must be a number, bigint, or Date (received ${typeof timestamp})`);\n\t\t}\n\n\t\tif (typeof increment !== 'bigint') {\n\t\t\tincrement = this[IncrementSymbol];\n\t\t\tthis[IncrementSymbol] = (increment + 1n) & MaximumIncrement;\n\t\t}\n\n\t\t// timestamp, workerId, processId, increment\n\t\treturn (\n\t\t\t((timestamp - this[EpochSymbol]) << 22n) |\n\t\t\t((workerId & MaximumWorkerId) << 17n) |\n\t\t\t((processId & MaximumProcessId) << 12n) |\n\t\t\t(increment & MaximumIncrement)\n\t\t);\n\t}\n\n\t/**\n\t * Deconstructs a snowflake given a snowflake ID\n\t * @param id the snowflake to deconstruct\n\t * @returns a deconstructed snowflake\n\t * @example\n\t * ```typescript\n\t * const epoch = new Date('2000-01-01T00:00:00.000Z');\n\t * const snowflake = new Snowflake(epoch).deconstruct('3971046231244935168');\n\t * ```\n\t */\n\tpublic deconstruct(id: string | bigint): DeconstructedSnowflake {\n\t\tconst bigIntId = BigInt(id);\n\t\tconst epoch = this[EpochSymbol];\n\t\treturn {\n\t\t\tid: bigIntId,\n\t\t\ttimestamp: (bigIntId >> 22n) + epoch,\n\t\t\tworkerId: (bigIntId >> 17n) & MaximumWorkerId,\n\t\t\tprocessId: (bigIntId >> 12n) & MaximumProcessId,\n\t\t\tincrement: bigIntId & MaximumIncrement,\n\t\t\tepoch\n\t\t};\n\t}\n\n\t/**\n\t * Retrieves the timestamp field's value from a snowflake.\n\t * @param id The snowflake to get the timestamp value from.\n\t * @returns The UNIX timestamp that is stored in `id`.\n\t */\n\tpublic timestampFrom(id: string | bigint): number {\n\t\treturn Number((BigInt(id) >> 22n) + this[EpochSymbol]);\n\t}\n\n\t/**\n\t * Returns a number indicating whether a reference snowflake comes before, or after, or is same as the given\n\t * snowflake in sort order.\n\t * @param a The first snowflake to compare.\n\t * @param b The second snowflake to compare.\n\t * @returns `-1` if `a` is older than `b`, `0` if `a` and `b` are equals, `1` if `a` is newer than `b`.\n\t * @example Sort snowflakes in ascending order\n\t * ```typescript\n\t * const ids = ['737141877803057244', '1056191128120082432', '254360814063058944'];\n\t * console.log(ids.sort((a, b) => Snowflake.compare(a, b)));\n\t * // → ['254360814063058944', '737141877803057244', '1056191128120082432'];\n\t * ```\n\t * @example Sort snowflakes in descending order\n\t * ```typescript\n\t * const ids = ['737141877803057244', '1056191128120082432', '254360814063058944'];\n\t * console.log(ids.sort((a, b) => -Snowflake.compare(a, b)));\n\t * // → ['1056191128120082432', '737141877803057244', '254360814063058944'];\n\t * ```\n\t */\n\tpublic static compare(a: string | bigint, b: string | bigint): -1 | 0 | 1 {\n\t\tconst typeA = typeof a;\n\t\treturn typeA === typeof b\n\t\t\t? typeA === 'string'\n\t\t\t\t? cmpString(a as string, b as string)\n\t\t\t\t: cmpBigInt(a as bigint, b as bigint)\n\t\t\t: cmpBigInt(BigInt(a), BigInt(b));\n\t}\n}\n\n/** @internal */\nfunction cmpBigInt(a: bigint, b: bigint) {\n\treturn a === b ? 0 : a < b ? -1 : 1;\n}\n\n/** @internal */\nfunction cmpString(a: string, b: string) {\n\treturn a === b ? 0 : a.length < b.length ? -1 : a.length > b.length ? 1 : a < b ? -1 : 1;\n}\n\n/**\n * Options for Snowflake#generate\n */\nexport interface SnowflakeGenerateOptions {\n\t/**\n\t * Timestamp or date of the snowflake to generate\n\t * @default Date.now()\n\t */\n\ttimestamp?: number | bigint | Date;\n\n\t/**\n\t * The increment to use\n\t * @default 0n\n\t * @remark keep in mind that this bigint is auto-incremented between generate calls\n\t */\n\tincrement?: bigint;\n\n\t/**\n\t * The worker ID to use, will be truncated to 5 bits (0-31)\n\t * @default 0n\n\t */\n\tworkerId?: bigint;\n\n\t/**\n\t * The process ID to use, will be truncated to 5 bits (0-31)\n\t * @default 1n\n\t */\n\tprocessId?: bigint;\n}\n\n/**\n * Object returned by Snowflake#deconstruct\n */\nexport interface DeconstructedSnowflake {\n\t/**\n\t * The id in BigInt form\n\t */\n\tid: bigint;\n\n\t/**\n\t * The timestamp stored in the snowflake\n\t */\n\ttimestamp: bigint;\n\n\t/**\n\t * The worker id stored in the snowflake\n\t */\n\tworkerId: bigint;\n\n\t/**\n\t * The process id stored in the snowflake\n\t */\n\tprocessId: bigint;\n\n\t/**\n\t * The increment stored in the snowflake\n\t */\n\tincrement: bigint;\n\n\t/**\n\t * The epoch to use in the snowflake\n\t */\n\tepoch: bigint;\n}\n","import { Snowflake } from './Snowflake';\n\n/**\n * A class for parsing snowflake ids using Discord's snowflake epoch\n *\n * Which is 2015-01-01 at 00:00:00.000 UTC+0, {@linkplain https://discord.com/developers/docs/reference#snowflakes}\n */\nexport const DiscordSnowflake = new Snowflake(1420070400000n);\n","import { Snowflake } from './Snowflake';\n\n/**\n * A class for parsing snowflake ids using Twitter's snowflake epoch\n *\n * Which is 2010-11-04 at 01:42:54.657 UTC+0, found in the archived snowflake repository {@linkplain https://github.com/twitter-archive/snowflake/blob/b3f6a3c6ca8e1b6847baa6ff42bf72201e2c2231/src/main/scala/com/twitter/service/snowflake/IdWorker.scala#L25}\n */\nexport const TwitterSnowflake = new Snowflake(1288834974657n);\n"],"mappings":";;;;;;;;;;;;;;;;;;AACA;AACA,IAAMA,eAAA,GAAkBC,MAAA,CAAO,+BAA+B;AAC9D,IAAMC,WAAA,GAAAD,MAAiB,4BAAO;AAKvB,IAAME,eAAA,GAAkBF,MAAA;AAKxB,IAAMG,cAAA,GAAAH,MAAmB;AAKzB,IAAMI,eAAA,WAAmB;AAlBhC,IAAAC,gBAAA;AAiCO,IAAMC,gBAAN,GAAgB;AAAA,IAAAC,EAAA,EAAAC,EAAA,EAAAC,EAAA,EAAAC,EAAA;AAAA,IAAAC,SAAA;EAAA;AAAA;AAKtB;EAAAC,YAAAC,KAAA;IAAA;AAAA;AAAA;IAMA;IAAAC,aAAA,sBAAAC,WAAA;IAAA;AAAA;AAAA;AAMA;IAAAD,aAAA,OAAAP,EAAA;IAAA;AAAA;AAAA;AAMA;IAAAO,aAAA,OAAAN,EAAA;IAAA;AAAA;AAAA;AAMA;IAAAM,aAAA,OAAAL,EAAA;IAAA;AAAA;AAAA;AAMC;IACDK,aAAA,OAAAJ,EAAA;IAAA,KAAAT,WAAA,IAAAe,MAAA,CAAAH,KAAA,YAAAI,IAAA,GAAAJ,KAAA,CAAAK,OAAA,KAAAL,KAAA;EAAA;EAAA;AAAA;AAMC;EACD,IAAAA,MAAA;IAAA,YAAAZ,WAAA;EAAA;EAAA;AAAA;AAMC;EACD,IAAAkB,UAAA;IAAA,YAAAjB,eAAA;EAAA;EAAA;AAAA;AAAA;AAOC;EACD,IAAAiB,UAAAC,KAAA;IAAA,KAAAlB,eAAA,IAAAc,MAAA,CAAAI,KAAA,IAAAf,gBAAA;EAAA;EAAA;AAAA;AAMC;EACD,IAAAgB,SAAA;IAAA,YAAAlB,cAAA;EAAA;EAAA;AAAA;AAAA;AAOC;EACD,IAAAkB,SAAAD,KAAA;IAAA,KAAAjB,cAAA,IAAAa,MAAA,CAAAI,KAAA,IAAAhB,eAAA;EAAA;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcgB;EACfkB,QACAA,CAAA;IACAC,SAAA;IACAC,SAAA,GAAYP,IAAA,CAAKQ,GAAA;IAClBJ,QAAkC,QAAAlB,cAAA;IACjCgB,SAAI,QAAAjB,eAAqB;EAAM;IAAsC,IAAAsB,SAC5D,YAAOP,IAAA,EAAwBO,SAAA,GAAYR,MAAA,CAAOQ,SAAS,CAAAN,OAAA,aAC3D,OAAOM,SAAA,KAAc,UAC7BA,SAAM,GAAIR,MAAA,CAAAQ,SAAU,OACrB,WAAAA,SAAA;MAEA,MAAI,IAAOE,SAAA,qEAAwB,OAAAF,SAAA;IAClC;IACA,WAAKD,SAAA,KAAe,QAAK;MAC1BA,SAAA,QAAAxB,eAAA;MAGA,KACGA,eAAY,IAAKwB,SAAW,KAAM,GAAAjB,gBACvB;IAIf;IAAA,OAAAkB,SAAA,QAAAvB,WAAA,YAAAoB,QAAA,GAAAjB,eAAA,YAAAe,SAAA,GAAAd,gBAAA,WAAAkB,SAAA,GAAAjB,gBAAA;EAAA;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaC;EACAS,WAAMA,CAAAY,EAAA,EAAQ;IACd,MAAAC,QAAO,GAAAZ,MAAA,CAAAW,EAAA;IAAA,MACFd,KAAA,QAAAZ,WAAA;IAAA,OACJ;MACA0B,EAAA,EAAAC,QAAW;MACXJ,SAAA,EAAY,CAAAI,QAAA,IAAY,OAAOf,KAAA;MAC/BQ,QAAA,EAAAO,QAAW,IAAW,MAAAxB,eAAA;MACtBe,SAAA,EAAAS,QAAA,UAAAvB,gBAAA;MACDkB,SAAA,EAAAK,QAAA,GAAAtB,gBAAA;MACDO;IAAA;EAAA;EAAA;AAAA;AAAA;AAAA;AAQC;EACDgB,cAAAF,EAAA;IAAA,OAAAG,MAAA,EAAAd,MAAA,CAAAW,EAAA,iBAAA1B,WAAA;EAAA;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsBC;EACA,OAAA8B,OAAOA,CAAAC,CAAA,EAAAC,CAAU;IAKlB,MAAAC,KAAA,UAAAF,CAAA;IACD,OAAAE,KAAA,YAAAD,CAAA,GAAAC,KAAA,gBAAAC,SAAA,CAAAH,CAAA,EAAAC,CAAA,IAAAG,SAAA,CAAAJ,CAAA,EAAAC,CAAA,IAAAG,SAAA,CAAApB,MAAA,CAAAgB,CAAA,GAAAhB,MAAA,CAAAiB,CAAA;EA5Ka;AAWM;AAoKnBI,MAAA,CAAA1B,SAAS,aAAgC;AACxCJ,EAAA,GAAAN,WAAa,EAAAO,EAAI,GAAIT,eAAa,EAAAU,EAAA,GAAAP,eAAA,EAAAQ,EAAA,GAAAP,cAAA;AACnC,SAAAiC,UAAAJ,CAAA,EAAAC,CAAA;EAFS,OAAAD,CAAA,KAAAC,CAAA,OAAAD,CAAA,GAAAC,CAAA;AAKT;AACCI,MAAA,CAAAD,SAAa,aAAU;AACxB,SAAAD,UAAAH,CAAA,EAAAC,CAAA;EAFS,OAAAD,CAAA,KAAAC,CAAA,OAAAD,CAAA,CAAAM,MAAA,GAAAL,CAAA,CAAAK,MAAA,QAAAN,CAAA,CAAAM,MAAA,GAAAL,CAAA,CAAAK,MAAA,OAAAN,CAAA,GAAAC,CAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}