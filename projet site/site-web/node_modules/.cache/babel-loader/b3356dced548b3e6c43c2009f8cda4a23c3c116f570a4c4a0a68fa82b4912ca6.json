{"ast":null,"code":"'use strict';\n\nconst process = require('node:process');\nconst {\n  setTimeout,\n  clearTimeout\n} = require('node:timers');\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  makeURLSearchParams\n} = require('@discordjs/rest');\nconst {\n  Routes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst {\n  Guild\n} = require('../structures/Guild');\nconst GuildChannel = require('../structures/GuildChannel');\nconst GuildEmoji = require('../structures/GuildEmoji');\nconst {\n  GuildMember\n} = require('../structures/GuildMember');\nconst Invite = require('../structures/Invite');\nconst OAuth2Guild = require('../structures/OAuth2Guild');\nconst {\n  Role\n} = require('../structures/Role');\nconst DataResolver = require('../util/DataResolver');\nconst Events = require('../util/Events');\nconst PermissionsBitField = require('../util/PermissionsBitField');\nconst SystemChannelFlagsBitField = require('../util/SystemChannelFlagsBitField');\nconst {\n  resolveColor\n} = require('../util/Util');\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for Guilds and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildManager extends CachedManager {\n  constructor(client, iterable) {\n    super(client, Guild, iterable);\n    if (!cacheWarningEmitted && this._cache.constructor.name !== 'Collection') {\n      cacheWarningEmitted = true;\n      process.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, 'UnsupportedCacheOverwriteWarning');\n    }\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, Guild>}\n   * @name GuildManager#cache\n   */\n\n  /**\n   * Data that resolves to give a Guild object. This can be:\n   * * A Guild object\n   * * A GuildChannel object\n   * * A GuildEmoji object\n   * * A Role object\n   * * A Snowflake\n   * * An Invite object\n   * @typedef {Guild|GuildChannel|GuildMember|GuildEmoji|Role|Snowflake|Invite} GuildResolvable\n   */\n\n  /**\n   * Partial data for a Role.\n   * @typedef {Object} PartialRoleData\n   * @property {Snowflake|number} [id] The role's id, used to set channel overrides.\n   * This is a placeholder and will be replaced by the API after consumption\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether the role should be mentionable\n   */\n\n  /**\n   * Partial overwrite data.\n   * @typedef {Object} PartialOverwriteData\n   * @property {Snowflake|number} id The id of the {@link Role} or {@link User} this overwrite belongs to\n   * @property {OverwriteType} [type] The type of this overwrite\n   * @property {PermissionResolvable} [allow] The permissions to allow\n   * @property {PermissionResolvable} [deny] The permissions to deny\n   */\n\n  /**\n   * Partial data for a Channel.\n   * @typedef {Object} PartialChannelData\n   * @property {Snowflake|number} [id] The channel's id, used to set its parent.\n   * This is a placeholder and will be replaced by the API after consumption\n   * @property {Snowflake|number} [parentId] The parent id for this channel\n   * @property {ChannelType.GuildText|ChannelType.GuildVoice|ChannelType.GuildCategory} [type] The type of the channel\n   * @property {string} name The name of the channel\n   * @property {?string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the channel\n   * @property {?string} [rtcRegion] The RTC region of the channel\n   * @property {VideoQualityMode} [videoQualityMode] The camera video quality mode of the channel\n   * @property {PartialOverwriteData[]} [permissionOverwrites]\n   * Overwrites of the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) of the channel in seconds\n   */\n\n  /**\n   * Resolves a GuildResolvable to a Guild object.\n   * @method resolve\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Guild}\n   */\n  resolve(guild) {\n    if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {\n      return super.resolve(guild.guild);\n    }\n    return super.resolve(guild);\n  }\n\n  /**\n   * Resolves a {@link GuildResolvable} to a {@link Guild} id string.\n   * @method resolveId\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Snowflake}\n   */\n  resolveId(guild) {\n    if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {\n      return super.resolveId(guild.guild.id);\n    }\n    return super.resolveId(guild);\n  }\n\n  /**\n   * Options used to create a guild.\n   * @typedef {Object} GuildCreateOptions\n   * @property {string} name The name of the guild\n   * @property {?(BufferResolvable|Base64Resolvable)} [icon=null] The icon for the guild\n   * @property {GuildVerificationLevel} [verificationLevel] The verification level for the guild\n   * @property {GuildDefaultMessageNotifications} [defaultMessageNotifications] The default message notifications\n   * for the guild\n   * @property {GuildExplicitContentFilter} [explicitContentFilter] The explicit content filter level for the guild\n   * @property {PartialRoleData[]} [roles=[]] The roles for this guild,\n   * @property {PartialChannelData[]} [channels=[]] The channels for this guild\n   * @property {Snowflake|number} [afkChannelId] The AFK channel's id\n   * @property {number} [afkTimeout] The AFK timeout in seconds\n   * the first element of this array is used to change properties of the guild's everyone role.\n   * @property {Snowflake|number} [systemChannelId] The system channel's id\n   * @property {SystemChannelFlagsResolvable} [systemChannelFlags] The flags of the system channel\n   */\n  /* eslint-enable max-len */\n\n  /**\n   * Creates a guild.\n   * <warn>This is only available to bots in fewer than 10 guilds.</warn>\n   * @param {GuildCreateOptions} options Options for creating the guild\n   * @returns {Promise<Guild>} The guild that was created\n   */\n  async create({\n    name,\n    icon = null,\n    verificationLevel,\n    defaultMessageNotifications,\n    explicitContentFilter,\n    roles = [],\n    channels = [],\n    afkChannelId,\n    afkTimeout,\n    systemChannelId,\n    systemChannelFlags\n  }) {\n    const data = await this.client.rest.post(Routes.guilds(), {\n      body: {\n        name,\n        icon: icon && (await DataResolver.resolveImage(icon)),\n        verification_level: verificationLevel,\n        default_message_notifications: defaultMessageNotifications,\n        explicit_content_filter: explicitContentFilter,\n        roles: roles.map(({\n          color,\n          permissions,\n          ...options\n        }) => ({\n          ...options,\n          color: color && resolveColor(color),\n          permissions: permissions === undefined ? undefined : PermissionsBitField.resolve(permissions).toString()\n        })),\n        channels: channels.map(({\n          parentId,\n          userLimit,\n          rtcRegion,\n          videoQualityMode,\n          permissionOverwrites,\n          rateLimitPerUser,\n          ...options\n        }) => ({\n          ...options,\n          parent_id: parentId,\n          user_limit: userLimit,\n          rtc_region: rtcRegion,\n          video_quality_mode: videoQualityMode,\n          permission_overwrites: permissionOverwrites?.map(({\n            allow,\n            deny,\n            ...permissionOverwriteOptions\n          }) => ({\n            ...permissionOverwriteOptions,\n            allow: allow === undefined ? undefined : PermissionsBitField.resolve(allow).toString(),\n            deny: deny === undefined ? undefined : PermissionsBitField.resolve(deny).toString()\n          })),\n          rate_limit_per_user: rateLimitPerUser\n        })),\n        afk_channel_id: afkChannelId,\n        afk_timeout: afkTimeout,\n        system_channel_id: systemChannelId,\n        system_channel_flags: systemChannelFlags === undefined ? undefined : SystemChannelFlagsBitField.resolve(systemChannelFlags)\n      }\n    });\n    return this.client.guilds.cache.get(data.id) ?? new Promise(resolve => {\n      const handleGuild = guild => {\n        if (guild.id === data.id) {\n          clearTimeout(timeout);\n          this.client.decrementMaxListeners();\n          resolve(guild);\n        }\n      };\n      this.client.incrementMaxListeners();\n      this.client.once(Events.GuildCreate, handleGuild);\n      const timeout = setTimeout(() => {\n        this.client.removeListener(Events.GuildCreate, handleGuild);\n        this.client.decrementMaxListeners();\n        resolve(this.client.guilds._add(data));\n      }, 10_000).unref();\n    });\n  }\n\n  /**\n   * Options used to fetch a single guild.\n   * @typedef {BaseFetchOptions} FetchGuildOptions\n   * @property {GuildResolvable} guild The guild to fetch\n   * @property {boolean} [withCounts=true] Whether the approximate member and presence counts should be returned\n   */\n\n  /**\n   * Options used to fetch multiple guilds.\n   * @typedef {Object} FetchGuildsOptions\n   * @property {Snowflake} [before] Get guilds before this guild id\n   * @property {Snowflake} [after] Get guilds after this guild id\n   * @property {number} [limit] Maximum number of guilds to request (1-200)\n   */\n\n  /**\n   * Obtains one or multiple guilds from Discord, or the guild cache if it's already available.\n   * @param {GuildResolvable|FetchGuildOptions|FetchGuildsOptions} [options] The guild's id or options\n   * @returns {Promise<Guild|Collection<Snowflake, OAuth2Guild>>}\n   */\n  async fetch(options = {}) {\n    const id = this.resolveId(options) ?? this.resolveId(options.guild);\n    if (id) {\n      if (!options.force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n      const data = await this.client.rest.get(Routes.guild(id), {\n        query: makeURLSearchParams({\n          with_counts: options.withCounts ?? true\n        })\n      });\n      return this._add(data, options.cache);\n    }\n    const data = await this.client.rest.get(Routes.userGuilds(), {\n      query: makeURLSearchParams(options)\n    });\n    return data.reduce((coll, guild) => coll.set(guild.id, new OAuth2Guild(this.client, guild)), new Collection());\n  }\n}\nmodule.exports = GuildManager;","map":{"version":3,"names":["process","require","setTimeout","clearTimeout","Collection","makeURLSearchParams","Routes","CachedManager","Guild","GuildChannel","GuildEmoji","GuildMember","Invite","OAuth2Guild","Role","DataResolver","Events","PermissionsBitField","SystemChannelFlagsBitField","resolveColor","cacheWarningEmitted","GuildManager","constructor","client","iterable","_cache","name","emitWarning","resolve","guild","resolveId","id","create","icon","verificationLevel","defaultMessageNotifications","explicitContentFilter","roles","channels","afkChannelId","afkTimeout","systemChannelId","systemChannelFlags","data","rest","post","guilds","body","resolveImage","verification_level","default_message_notifications","explicit_content_filter","map","color","permissions","options","undefined","toString","parentId","userLimit","rtcRegion","videoQualityMode","permissionOverwrites","rateLimitPerUser","parent_id","user_limit","rtc_region","video_quality_mode","permission_overwrites","allow","deny","permissionOverwriteOptions","rate_limit_per_user","afk_channel_id","afk_timeout","system_channel_id","system_channel_flags","cache","get","Promise","handleGuild","timeout","decrementMaxListeners","incrementMaxListeners","once","GuildCreate","removeListener","_add","unref","fetch","force","existing","query","with_counts","withCounts","userGuilds","reduce","coll","set","module","exports"],"sources":["C:/Users/hetit/node_modules/discord.js/src/managers/GuildManager.js"],"sourcesContent":["'use strict';\n\nconst process = require('node:process');\nconst { setTimeout, clearTimeout } = require('node:timers');\nconst { Collection } = require('@discordjs/collection');\nconst { makeURLSearchParams } = require('@discordjs/rest');\nconst { Routes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst { Guild } = require('../structures/Guild');\nconst GuildChannel = require('../structures/GuildChannel');\nconst GuildEmoji = require('../structures/GuildEmoji');\nconst { GuildMember } = require('../structures/GuildMember');\nconst Invite = require('../structures/Invite');\nconst OAuth2Guild = require('../structures/OAuth2Guild');\nconst { Role } = require('../structures/Role');\nconst DataResolver = require('../util/DataResolver');\nconst Events = require('../util/Events');\nconst PermissionsBitField = require('../util/PermissionsBitField');\nconst SystemChannelFlagsBitField = require('../util/SystemChannelFlagsBitField');\nconst { resolveColor } = require('../util/Util');\n\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for Guilds and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildManager extends CachedManager {\n  constructor(client, iterable) {\n    super(client, Guild, iterable);\n    if (!cacheWarningEmitted && this._cache.constructor.name !== 'Collection') {\n      cacheWarningEmitted = true;\n      process.emitWarning(\n        `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,\n        'UnsupportedCacheOverwriteWarning',\n      );\n    }\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, Guild>}\n   * @name GuildManager#cache\n   */\n\n  /**\n   * Data that resolves to give a Guild object. This can be:\n   * * A Guild object\n   * * A GuildChannel object\n   * * A GuildEmoji object\n   * * A Role object\n   * * A Snowflake\n   * * An Invite object\n   * @typedef {Guild|GuildChannel|GuildMember|GuildEmoji|Role|Snowflake|Invite} GuildResolvable\n   */\n\n  /**\n   * Partial data for a Role.\n   * @typedef {Object} PartialRoleData\n   * @property {Snowflake|number} [id] The role's id, used to set channel overrides.\n   * This is a placeholder and will be replaced by the API after consumption\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether the role should be mentionable\n   */\n\n  /**\n   * Partial overwrite data.\n   * @typedef {Object} PartialOverwriteData\n   * @property {Snowflake|number} id The id of the {@link Role} or {@link User} this overwrite belongs to\n   * @property {OverwriteType} [type] The type of this overwrite\n   * @property {PermissionResolvable} [allow] The permissions to allow\n   * @property {PermissionResolvable} [deny] The permissions to deny\n   */\n\n  /**\n   * Partial data for a Channel.\n   * @typedef {Object} PartialChannelData\n   * @property {Snowflake|number} [id] The channel's id, used to set its parent.\n   * This is a placeholder and will be replaced by the API after consumption\n   * @property {Snowflake|number} [parentId] The parent id for this channel\n   * @property {ChannelType.GuildText|ChannelType.GuildVoice|ChannelType.GuildCategory} [type] The type of the channel\n   * @property {string} name The name of the channel\n   * @property {?string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the channel\n   * @property {?string} [rtcRegion] The RTC region of the channel\n   * @property {VideoQualityMode} [videoQualityMode] The camera video quality mode of the channel\n   * @property {PartialOverwriteData[]} [permissionOverwrites]\n   * Overwrites of the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) of the channel in seconds\n   */\n\n  /**\n   * Resolves a GuildResolvable to a Guild object.\n   * @method resolve\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Guild}\n   */\n  resolve(guild) {\n    if (\n      guild instanceof GuildChannel ||\n      guild instanceof GuildMember ||\n      guild instanceof GuildEmoji ||\n      guild instanceof Role ||\n      (guild instanceof Invite && guild.guild)\n    ) {\n      return super.resolve(guild.guild);\n    }\n    return super.resolve(guild);\n  }\n\n  /**\n   * Resolves a {@link GuildResolvable} to a {@link Guild} id string.\n   * @method resolveId\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Snowflake}\n   */\n  resolveId(guild) {\n    if (\n      guild instanceof GuildChannel ||\n      guild instanceof GuildMember ||\n      guild instanceof GuildEmoji ||\n      guild instanceof Role ||\n      (guild instanceof Invite && guild.guild)\n    ) {\n      return super.resolveId(guild.guild.id);\n    }\n    return super.resolveId(guild);\n  }\n\n  /**\n   * Options used to create a guild.\n   * @typedef {Object} GuildCreateOptions\n   * @property {string} name The name of the guild\n   * @property {?(BufferResolvable|Base64Resolvable)} [icon=null] The icon for the guild\n   * @property {GuildVerificationLevel} [verificationLevel] The verification level for the guild\n   * @property {GuildDefaultMessageNotifications} [defaultMessageNotifications] The default message notifications\n   * for the guild\n   * @property {GuildExplicitContentFilter} [explicitContentFilter] The explicit content filter level for the guild\n   * @property {PartialRoleData[]} [roles=[]] The roles for this guild,\n   * @property {PartialChannelData[]} [channels=[]] The channels for this guild\n   * @property {Snowflake|number} [afkChannelId] The AFK channel's id\n   * @property {number} [afkTimeout] The AFK timeout in seconds\n   * the first element of this array is used to change properties of the guild's everyone role.\n   * @property {Snowflake|number} [systemChannelId] The system channel's id\n   * @property {SystemChannelFlagsResolvable} [systemChannelFlags] The flags of the system channel\n   */\n  /* eslint-enable max-len */\n\n  /**\n   * Creates a guild.\n   * <warn>This is only available to bots in fewer than 10 guilds.</warn>\n   * @param {GuildCreateOptions} options Options for creating the guild\n   * @returns {Promise<Guild>} The guild that was created\n   */\n  async create({\n    name,\n    icon = null,\n    verificationLevel,\n    defaultMessageNotifications,\n    explicitContentFilter,\n    roles = [],\n    channels = [],\n    afkChannelId,\n    afkTimeout,\n    systemChannelId,\n    systemChannelFlags,\n  }) {\n    const data = await this.client.rest.post(Routes.guilds(), {\n      body: {\n        name,\n        icon: icon && (await DataResolver.resolveImage(icon)),\n        verification_level: verificationLevel,\n        default_message_notifications: defaultMessageNotifications,\n        explicit_content_filter: explicitContentFilter,\n        roles: roles.map(({ color, permissions, ...options }) => ({\n          ...options,\n          color: color && resolveColor(color),\n          permissions: permissions === undefined ? undefined : PermissionsBitField.resolve(permissions).toString(),\n        })),\n        channels: channels.map(\n          ({\n            parentId,\n            userLimit,\n            rtcRegion,\n            videoQualityMode,\n            permissionOverwrites,\n            rateLimitPerUser,\n            ...options\n          }) => ({\n            ...options,\n            parent_id: parentId,\n            user_limit: userLimit,\n            rtc_region: rtcRegion,\n            video_quality_mode: videoQualityMode,\n            permission_overwrites: permissionOverwrites?.map(({ allow, deny, ...permissionOverwriteOptions }) => ({\n              ...permissionOverwriteOptions,\n              allow: allow === undefined ? undefined : PermissionsBitField.resolve(allow).toString(),\n              deny: deny === undefined ? undefined : PermissionsBitField.resolve(deny).toString(),\n            })),\n            rate_limit_per_user: rateLimitPerUser,\n          }),\n        ),\n        afk_channel_id: afkChannelId,\n        afk_timeout: afkTimeout,\n        system_channel_id: systemChannelId,\n        system_channel_flags:\n          systemChannelFlags === undefined ? undefined : SystemChannelFlagsBitField.resolve(systemChannelFlags),\n      },\n    });\n\n    return (\n      this.client.guilds.cache.get(data.id) ??\n      new Promise(resolve => {\n        const handleGuild = guild => {\n          if (guild.id === data.id) {\n            clearTimeout(timeout);\n            this.client.decrementMaxListeners();\n            resolve(guild);\n          }\n        };\n        this.client.incrementMaxListeners();\n        this.client.once(Events.GuildCreate, handleGuild);\n\n        const timeout = setTimeout(() => {\n          this.client.removeListener(Events.GuildCreate, handleGuild);\n          this.client.decrementMaxListeners();\n          resolve(this.client.guilds._add(data));\n        }, 10_000).unref();\n      })\n    );\n  }\n\n  /**\n   * Options used to fetch a single guild.\n   * @typedef {BaseFetchOptions} FetchGuildOptions\n   * @property {GuildResolvable} guild The guild to fetch\n   * @property {boolean} [withCounts=true] Whether the approximate member and presence counts should be returned\n   */\n\n  /**\n   * Options used to fetch multiple guilds.\n   * @typedef {Object} FetchGuildsOptions\n   * @property {Snowflake} [before] Get guilds before this guild id\n   * @property {Snowflake} [after] Get guilds after this guild id\n   * @property {number} [limit] Maximum number of guilds to request (1-200)\n   */\n\n  /**\n   * Obtains one or multiple guilds from Discord, or the guild cache if it's already available.\n   * @param {GuildResolvable|FetchGuildOptions|FetchGuildsOptions} [options] The guild's id or options\n   * @returns {Promise<Guild|Collection<Snowflake, OAuth2Guild>>}\n   */\n  async fetch(options = {}) {\n    const id = this.resolveId(options) ?? this.resolveId(options.guild);\n\n    if (id) {\n      if (!options.force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n\n      const data = await this.client.rest.get(Routes.guild(id), {\n        query: makeURLSearchParams({ with_counts: options.withCounts ?? true }),\n      });\n      return this._add(data, options.cache);\n    }\n\n    const data = await this.client.rest.get(Routes.userGuilds(), { query: makeURLSearchParams(options) });\n    return data.reduce((coll, guild) => coll.set(guild.id, new OAuth2Guild(this.client, guild)), new Collection());\n  }\n}\n\nmodule.exports = GuildManager;\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,OAAO,GAAGC,OAAO,CAAC,cAAc,CAAC;AACvC,MAAM;EAAEC,UAAU;EAAEC;AAAa,CAAC,GAAGF,OAAO,CAAC,aAAa,CAAC;AAC3D,MAAM;EAAEG;AAAW,CAAC,GAAGH,OAAO,CAAC,uBAAuB,CAAC;AACvD,MAAM;EAAEI;AAAoB,CAAC,GAAGJ,OAAO,CAAC,iBAAiB,CAAC;AAC1D,MAAM;EAAEK;AAAO,CAAC,GAAGL,OAAO,CAAC,uBAAuB,CAAC;AACnD,MAAMM,aAAa,GAAGN,OAAO,CAAC,iBAAiB,CAAC;AAChD,MAAM;EAAEO;AAAM,CAAC,GAAGP,OAAO,CAAC,qBAAqB,CAAC;AAChD,MAAMQ,YAAY,GAAGR,OAAO,CAAC,4BAA4B,CAAC;AAC1D,MAAMS,UAAU,GAAGT,OAAO,CAAC,0BAA0B,CAAC;AACtD,MAAM;EAAEU;AAAY,CAAC,GAAGV,OAAO,CAAC,2BAA2B,CAAC;AAC5D,MAAMW,MAAM,GAAGX,OAAO,CAAC,sBAAsB,CAAC;AAC9C,MAAMY,WAAW,GAAGZ,OAAO,CAAC,2BAA2B,CAAC;AACxD,MAAM;EAAEa;AAAK,CAAC,GAAGb,OAAO,CAAC,oBAAoB,CAAC;AAC9C,MAAMc,YAAY,GAAGd,OAAO,CAAC,sBAAsB,CAAC;AACpD,MAAMe,MAAM,GAAGf,OAAO,CAAC,gBAAgB,CAAC;AACxC,MAAMgB,mBAAmB,GAAGhB,OAAO,CAAC,6BAA6B,CAAC;AAClE,MAAMiB,0BAA0B,GAAGjB,OAAO,CAAC,oCAAoC,CAAC;AAChF,MAAM;EAAEkB;AAAa,CAAC,GAAGlB,OAAO,CAAC,cAAc,CAAC;AAEhD,IAAImB,mBAAmB,GAAG,KAAK;;AAE/B;AACA;AACA;AACA;AACA,MAAMC,YAAY,SAASd,aAAa,CAAC;EACvCe,WAAWA,CAACC,MAAM,EAAEC,QAAQ,EAAE;IAC5B,KAAK,CAACD,MAAM,EAAEf,KAAK,EAAEgB,QAAQ,CAAC;IAC9B,IAAI,CAACJ,mBAAmB,IAAI,IAAI,CAACK,MAAM,CAACH,WAAW,CAACI,IAAI,KAAK,YAAY,EAAE;MACzEN,mBAAmB,GAAG,IAAI;MAC1BpB,OAAO,CAAC2B,WAAW,CACjB,qCAAqC,IAAI,CAACL,WAAW,CAACI,IAAI,2CAA2C,EACrG,kCACF,CAAC;IACH;EACF;;EAEA;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEE,OAAOA,CAACC,KAAK,EAAE;IACb,IACEA,KAAK,YAAYpB,YAAY,IAC7BoB,KAAK,YAAYlB,WAAW,IAC5BkB,KAAK,YAAYnB,UAAU,IAC3BmB,KAAK,YAAYf,IAAI,IACpBe,KAAK,YAAYjB,MAAM,IAAIiB,KAAK,CAACA,KAAM,EACxC;MACA,OAAO,KAAK,CAACD,OAAO,CAACC,KAAK,CAACA,KAAK,CAAC;IACnC;IACA,OAAO,KAAK,CAACD,OAAO,CAACC,KAAK,CAAC;EAC7B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,SAASA,CAACD,KAAK,EAAE;IACf,IACEA,KAAK,YAAYpB,YAAY,IAC7BoB,KAAK,YAAYlB,WAAW,IAC5BkB,KAAK,YAAYnB,UAAU,IAC3BmB,KAAK,YAAYf,IAAI,IACpBe,KAAK,YAAYjB,MAAM,IAAIiB,KAAK,CAACA,KAAM,EACxC;MACA,OAAO,KAAK,CAACC,SAAS,CAACD,KAAK,CAACA,KAAK,CAACE,EAAE,CAAC;IACxC;IACA,OAAO,KAAK,CAACD,SAAS,CAACD,KAAK,CAAC;EAC/B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMG,MAAMA,CAAC;IACXN,IAAI;IACJO,I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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}