{"ast":null,"code":"'use strict';\n\nconst {\n  DiscordjsRangeError,\n  ErrorCodes\n} = require('../errors');\n\n/**\n * Data structure that makes it easy to interact with a bitfield.\n */\nclass BitField {\n  /**\n   * Numeric bitfield flags.\n   * <info>Defined in extension classes</info>\n   * @type {Object}\n   * @memberof BitField\n   * @abstract\n   */\n  static Flags = {};\n\n  /**\n   * @type {number|bigint}\n   * @memberof BitField\n   * @private\n   */\n  static DefaultBit = 0;\n\n  /**\n   * @param {BitFieldResolvable} [bits=this.constructor.DefaultBit] Bit(s) to read from\n   */\n  constructor(bits = this.constructor.DefaultBit) {\n    /**\n     * Bitfield of the packed bits\n     * @type {number|bigint}\n     */\n    this.bitfield = this.constructor.resolve(bits);\n  }\n\n  /**\n   * Checks whether the bitfield has a bit, or any of multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  any(bit) {\n    return (this.bitfield & this.constructor.resolve(bit)) !== this.constructor.DefaultBit;\n  }\n\n  /**\n   * Checks if this bitfield equals another\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  equals(bit) {\n    return this.bitfield === this.constructor.resolve(bit);\n  }\n\n  /**\n   * Checks whether the bitfield has a bit, or multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  has(bit) {\n    bit = this.constructor.resolve(bit);\n    return (this.bitfield & bit) === bit;\n  }\n\n  /**\n   * Gets all given bits that are missing from the bitfield.\n   * @param {BitFieldResolvable} bits Bit(s) to check for\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {string[]}\n   */\n  missing(bits, ...hasParams) {\n    return new this.constructor(bits).remove(this).toArray(...hasParams);\n  }\n\n  /**\n   * Freezes these bits, making them immutable.\n   * @returns {Readonly<BitField>}\n   */\n  freeze() {\n    return Object.freeze(this);\n  }\n\n  /**\n   * Adds bits to these ones.\n   * @param {...BitFieldResolvable} [bits] Bits to add\n   * @returns {BitField} These bits or new BitField if the instance is frozen.\n   */\n  add(...bits) {\n    let total = this.constructor.DefaultBit;\n    for (const bit of bits) {\n      total |= this.constructor.resolve(bit);\n    }\n    if (Object.isFrozen(this)) return new this.constructor(this.bitfield | total);\n    this.bitfield |= total;\n    return this;\n  }\n\n  /**\n   * Removes bits from these.\n   * @param {...BitFieldResolvable} [bits] Bits to remove\n   * @returns {BitField} These bits or new BitField if the instance is frozen.\n   */\n  remove(...bits) {\n    let total = this.constructor.DefaultBit;\n    for (const bit of bits) {\n      total |= this.constructor.resolve(bit);\n    }\n    if (Object.isFrozen(this)) return new this.constructor(this.bitfield & ~total);\n    this.bitfield &= ~total;\n    return this;\n  }\n\n  /**\n   * Gets an object mapping field names to a {@link boolean} indicating whether the\n   * bit is available.\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {Object}\n   */\n  serialize(...hasParams) {\n    const serialized = {};\n    for (const [flag, bit] of Object.entries(this.constructor.Flags)) {\n      if (isNaN(flag)) serialized[flag] = this.has(bit, ...hasParams);\n    }\n    return serialized;\n  }\n\n  /**\n   * Gets an {@link Array} of bitfield names based on the bits available.\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {string[]}\n   */\n  toArray(...hasParams) {\n    return [...this[Symbol.iterator](...hasParams)];\n  }\n  toJSON() {\n    return typeof this.bitfield === 'number' ? this.bitfield : this.bitfield.toString();\n  }\n  valueOf() {\n    return this.bitfield;\n  }\n  *[Symbol.iterator](...hasParams) {\n    for (const bitName of Object.keys(this.constructor.Flags)) {\n      if (isNaN(bitName) && this.has(bitName, ...hasParams)) yield bitName;\n    }\n  }\n\n  /**\n   * Data that can be resolved to give a bitfield. This can be:\n   * * A bit number (this can be a number literal or a value taken from {@link BitField.Flags})\n   * * A string bit number\n   * * An instance of BitField\n   * * An Array of BitFieldResolvable\n   * @typedef {number|string|bigint|BitField|BitFieldResolvable[]} BitFieldResolvable\n   */\n\n  /**\n   * Resolves bitfields to their numeric form.\n   * @param {BitFieldResolvable} [bit] bit(s) to resolve\n   * @returns {number|bigint}\n   */\n  static resolve(bit) {\n    const {\n      DefaultBit\n    } = this;\n    if (typeof DefaultBit === typeof bit && bit >= DefaultBit) return bit;\n    if (bit instanceof BitField) return bit.bitfield;\n    if (Array.isArray(bit)) return bit.map(p => this.resolve(p)).reduce((prev, p) => prev | p, DefaultBit);\n    if (typeof bit === 'string') {\n      if (!isNaN(bit)) return typeof DefaultBit === 'bigint' ? BigInt(bit) : Number(bit);\n      if (this.Flags[bit] !== undefined) return this.Flags[bit];\n    }\n    throw new DiscordjsRangeError(ErrorCodes.BitFieldInvalid, bit);\n  }\n}\nmodule.exports = BitField;","map":{"version":3,"names":["DiscordjsRangeError","ErrorCodes","require","BitField","Flags","DefaultBit","constructor","bits","bitfield","resolve","any","bit","equals","has","missing","hasParams","remove","toArray","freeze","Object","add","total","isFrozen","serialize","serialized","flag","entries","isNaN","Symbol","iterator","toJSON","toString","valueOf","bitName","keys","Array","isArray","map","p","reduce","prev","BigInt","Number","undefined","BitFieldInvalid","module","exports"],"sources":["C:/Users/hetit/node_modules/discord.js/src/util/BitField.js"],"sourcesContent":["'use strict';\n\nconst { DiscordjsRangeError, ErrorCodes } = require('../errors');\n\n/**\n * Data structure that makes it easy to interact with a bitfield.\n */\nclass BitField {\n  /**\n   * Numeric bitfield flags.\n   * <info>Defined in extension classes</info>\n   * @type {Object}\n   * @memberof BitField\n   * @abstract\n   */\n  static Flags = {};\n\n  /**\n   * @type {number|bigint}\n   * @memberof BitField\n   * @private\n   */\n  static DefaultBit = 0;\n\n  /**\n   * @param {BitFieldResolvable} [bits=this.constructor.DefaultBit] Bit(s) to read from\n   */\n  constructor(bits = this.constructor.DefaultBit) {\n    /**\n     * Bitfield of the packed bits\n     * @type {number|bigint}\n     */\n    this.bitfield = this.constructor.resolve(bits);\n  }\n\n  /**\n   * Checks whether the bitfield has a bit, or any of multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  any(bit) {\n    return (this.bitfield & this.constructor.resolve(bit)) !== this.constructor.DefaultBit;\n  }\n\n  /**\n   * Checks if this bitfield equals another\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  equals(bit) {\n    return this.bitfield === this.constructor.resolve(bit);\n  }\n\n  /**\n   * Checks whether the bitfield has a bit, or multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  has(bit) {\n    bit = this.constructor.resolve(bit);\n    return (this.bitfield & bit) === bit;\n  }\n\n  /**\n   * Gets all given bits that are missing from the bitfield.\n   * @param {BitFieldResolvable} bits Bit(s) to check for\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {string[]}\n   */\n  missing(bits, ...hasParams) {\n    return new this.constructor(bits).remove(this).toArray(...hasParams);\n  }\n\n  /**\n   * Freezes these bits, making them immutable.\n   * @returns {Readonly<BitField>}\n   */\n  freeze() {\n    return Object.freeze(this);\n  }\n\n  /**\n   * Adds bits to these ones.\n   * @param {...BitFieldResolvable} [bits] Bits to add\n   * @returns {BitField} These bits or new BitField if the instance is frozen.\n   */\n  add(...bits) {\n    let total = this.constructor.DefaultBit;\n    for (const bit of bits) {\n      total |= this.constructor.resolve(bit);\n    }\n    if (Object.isFrozen(this)) return new this.constructor(this.bitfield | total);\n    this.bitfield |= total;\n    return this;\n  }\n\n  /**\n   * Removes bits from these.\n   * @param {...BitFieldResolvable} [bits] Bits to remove\n   * @returns {BitField} These bits or new BitField if the instance is frozen.\n   */\n  remove(...bits) {\n    let total = this.constructor.DefaultBit;\n    for (const bit of bits) {\n      total |= this.constructor.resolve(bit);\n    }\n    if (Object.isFrozen(this)) return new this.constructor(this.bitfield & ~total);\n    this.bitfield &= ~total;\n    return this;\n  }\n\n  /**\n   * Gets an object mapping field names to a {@link boolean} indicating whether the\n   * bit is available.\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {Object}\n   */\n  serialize(...hasParams) {\n    const serialized = {};\n    for (const [flag, bit] of Object.entries(this.constructor.Flags)) {\n      if (isNaN(flag)) serialized[flag] = this.has(bit, ...hasParams);\n    }\n    return serialized;\n  }\n\n  /**\n   * Gets an {@link Array} of bitfield names based on the bits available.\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {string[]}\n   */\n  toArray(...hasParams) {\n    return [...this[Symbol.iterator](...hasParams)];\n  }\n\n  toJSON() {\n    return typeof this.bitfield === 'number' ? this.bitfield : this.bitfield.toString();\n  }\n\n  valueOf() {\n    return this.bitfield;\n  }\n\n  *[Symbol.iterator](...hasParams) {\n    for (const bitName of Object.keys(this.constructor.Flags)) {\n      if (isNaN(bitName) && this.has(bitName, ...hasParams)) yield bitName;\n    }\n  }\n\n  /**\n   * Data that can be resolved to give a bitfield. This can be:\n   * * A bit number (this can be a number literal or a value taken from {@link BitField.Flags})\n   * * A string bit number\n   * * An instance of BitField\n   * * An Array of BitFieldResolvable\n   * @typedef {number|string|bigint|BitField|BitFieldResolvable[]} BitFieldResolvable\n   */\n\n  /**\n   * Resolves bitfields to their numeric form.\n   * @param {BitFieldResolvable} [bit] bit(s) to resolve\n   * @returns {number|bigint}\n   */\n  static resolve(bit) {\n    const { DefaultBit } = this;\n    if (typeof DefaultBit === typeof bit && bit >= DefaultBit) return bit;\n    if (bit instanceof BitField) return bit.bitfield;\n    if (Array.isArray(bit)) return bit.map(p => this.resolve(p)).reduce((prev, p) => prev | p, DefaultBit);\n    if (typeof bit === 'string') {\n      if (!isNaN(bit)) return typeof DefaultBit === 'bigint' ? BigInt(bit) : Number(bit);\n      if (this.Flags[bit] !== undefined) return this.Flags[bit];\n    }\n    throw new DiscordjsRangeError(ErrorCodes.BitFieldInvalid, bit);\n  }\n}\n\nmodule.exports = BitField;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}