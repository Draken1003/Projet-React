{"ast":null,"code":"'use strict';\n\nconst process = require('node:process');\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  Routes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst {\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../errors');\nconst {\n  Role\n} = require('../structures/Role');\nconst DataResolver = require('../util/DataResolver');\nconst PermissionsBitField = require('../util/PermissionsBitField');\nconst {\n  setPosition,\n  resolveColor\n} = require('../util/Util');\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for roles and stores their cache.\n * @extends {CachedManager}\n */\nclass RoleManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, Role, iterable);\n    if (!cacheWarningEmitted && this._cache.constructor.name !== 'Collection') {\n      cacheWarningEmitted = true;\n      process.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, 'UnsupportedCacheOverwriteWarning');\n    }\n\n    /**\n     * The guild belonging to this manager\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The role cache of this manager\n   * @type {Collection<Snowflake, Role>}\n   * @name RoleManager#cache\n   */\n\n  _add(data, cache) {\n    return super._add(data, cache, {\n      extras: [this.guild]\n    });\n  }\n\n  /**\n   * Obtains a role from Discord, or the role cache if they're already available.\n   * @param {Snowflake} [id] The role's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<?Role|Collection<Snowflake, Role>>}\n   * @example\n   * // Fetch all roles from the guild\n   * message.guild.roles.fetch()\n   *   .then(roles => console.log(`There are ${roles.size} roles.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single role\n   * message.guild.roles.fetch('222078108977594368')\n   *   .then(role => console.log(`The role color is: ${role.color}`))\n   *   .catch(console.error);\n   */\n  async fetch(id, {\n    cache = true,\n    force = false\n  } = {}) {\n    if (id && !force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    }\n\n    // We cannot fetch a single role, as of this commit's date, Discord API throws with 405\n    const data = await this.client.rest.get(Routes.guildRoles(this.guild.id));\n    const roles = new Collection();\n    for (const role of data) roles.set(role.id, this._add(role, cache));\n    return id ? roles.get(id) ?? null : roles;\n  }\n\n  /**\n   * Data that can be resolved to a Role object. This can be:\n   * * A Role\n   * * A Snowflake\n   * @typedef {Role|Snowflake} RoleResolvable\n   */\n\n  /**\n   * Resolves a {@link RoleResolvable} to a {@link Role} object.\n   * @method resolve\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Role}\n   */\n\n  /**\n   * Resolves a {@link RoleResolvable} to a {@link Role} id.\n   * @method resolveId\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Options used to create a new role.\n   * @typedef {Object} RoleCreateOptions\n   * @property {string} [name] The name of the new role\n   * @property {ColorResolvable} [color] The data to create the role with\n   * @property {boolean} [hoist] Whether or not the new role should be hoisted\n   * @property {PermissionResolvable} [permissions] The permissions for the new role\n   * @property {number} [position] The position of the new role\n   * @property {boolean} [mentionable] Whether or not the new role should be mentionable\n   * @property {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} [icon] The icon for the role\n   * <warn>The `EmojiResolvable` should belong to the same guild as the role.\n   * If not, pass the emoji's URL directly</warn>\n   * @property {?string} [unicodeEmoji] The unicode emoji for the role\n   * @property {string} [reason] The reason for creating this role\n   */\n\n  /**\n   * Creates a new role in the guild with given information.\n   * <warn>The position will silently reset to 1 if an invalid one is provided, or none.</warn>\n   * @param {RoleCreateOptions} [options] Options for creating the new role\n   * @returns {Promise<Role>}\n   * @example\n   * // Create a new role\n   * guild.roles.create()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Create a new role with data and a reason\n   * guild.roles.create({\n   *   name: 'Super Cool Blue People',\n   *   color: Colors.Blue,\n   *   reason: 'we needed a role for Super Cool People',\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async create(options = {}) {\n    let {\n      name,\n      color,\n      hoist,\n      permissions,\n      position,\n      mentionable,\n      reason,\n      icon,\n      unicodeEmoji\n    } = options;\n    color &&= resolveColor(color);\n    if (permissions !== undefined) permissions = new PermissionsBitField(permissions);\n    if (icon) {\n      const guildEmojiURL = this.guild.emojis.resolve(icon)?.url;\n      icon = guildEmojiURL ? await DataResolver.resolveImage(guildEmojiURL) : await DataResolver.resolveImage(icon);\n      if (typeof icon !== 'string') icon = undefined;\n    }\n    const data = await this.client.rest.post(Routes.guildRoles(this.guild.id), {\n      body: {\n        name,\n        color,\n        hoist,\n        permissions,\n        mentionable,\n        icon,\n        unicode_emoji: unicodeEmoji\n      },\n      reason\n    });\n    const {\n      role\n    } = this.client.actions.GuildRoleCreate.handle({\n      guild_id: this.guild.id,\n      role: data\n    });\n    if (position) return this.setPosition(role, position, {\n      reason\n    });\n    return role;\n  }\n\n  /**\n   * Options for editing a role\n   * @typedef {RoleData} RoleEditOptions\n   * @property {string} [reason] The reason for editing this role\n   */\n\n  /**\n   * Edits a role of the guild.\n   * @param {RoleResolvable} role The role to edit\n   * @param {RoleEditOptions} options The options to provide\n   * @returns {Promise<Role>}\n   * @example\n   * // Edit a role\n   * guild.roles.edit('222079219327434752', { name: 'buddies' })\n   *   .then(updated => console.log(`Edited role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n  async edit(role, options) {\n    role = this.resolve(role);\n    if (!role) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'role', 'RoleResolvable');\n    if (typeof options.position === 'number') {\n      await this.setPosition(role, options.position, {\n        reason: options.reason\n      });\n    }\n    let icon = options.icon;\n    if (icon) {\n      const guildEmojiURL = this.guild.emojis.resolve(icon)?.url;\n      icon = guildEmojiURL ? await DataResolver.resolveImage(guildEmojiURL) : await DataResolver.resolveImage(icon);\n      if (typeof icon !== 'string') icon = undefined;\n    }\n    const body = {\n      name: options.name,\n      color: options.color === undefined ? undefined : resolveColor(options.color),\n      hoist: options.hoist,\n      permissions: options.permissions === undefined ? undefined : new PermissionsBitField(options.permissions),\n      mentionable: options.mentionable,\n      icon,\n      unicode_emoji: options.unicodeEmoji\n    };\n    const d = await this.client.rest.patch(Routes.guildRole(this.guild.id, role.id), {\n      body,\n      reason: options.reason\n    });\n    const clone = role._clone();\n    clone._patch(d);\n    return clone;\n  }\n\n  /**\n   * Deletes a role.\n   * @param {RoleResolvable} role The role to delete\n   * @param {string} [reason] Reason for deleting the role\n   * @returns {Promise<void>}\n   * @example\n   * // Delete a role\n   * guild.roles.delete('222079219327434752', 'The role needed to go')\n   *   .then(() => console.log('Deleted the role'))\n   *   .catch(console.error);\n   */\n  async delete(role, reason) {\n    const id = this.resolveId(role);\n    await this.client.rest.delete(Routes.guildRole(this.guild.id, id), {\n      reason\n    });\n    this.client.actions.GuildRoleDelete.handle({\n      guild_id: this.guild.id,\n      role_id: id\n    });\n  }\n\n  /**\n   * Sets the new position of the role.\n   * @param {RoleResolvable} role The role to change the position of\n   * @param {number} position The new position for the role\n   * @param {SetRolePositionOptions} [options] Options for setting the position\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the position of the role\n   * guild.roles.setPosition('222197033908436994', 1)\n   *   .then(updated => console.log(`Role position: ${updated.position}`))\n   *   .catch(console.error);\n   */\n  async setPosition(role, position, {\n    relative,\n    reason\n  } = {}) {\n    role = this.resolve(role);\n    if (!role) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'role', 'RoleResolvable');\n    const updatedRoles = await setPosition(role, position, relative, this.guild._sortedRoles(), this.client, Routes.guildRoles(this.guild.id), reason);\n    this.client.actions.GuildRolesPositionUpdate.handle({\n      guild_id: this.guild.id,\n      roles: updatedRoles\n    });\n    return role;\n  }\n\n  /**\n   * The data needed for updating a guild role's position\n   * @typedef {Object} GuildRolePosition\n   * @property {RoleResolvable} role The role's id\n   * @property {number} position The position to update\n   */\n\n  /**\n   * Batch-updates the guild's role positions\n   * @param {GuildRolePosition[]} rolePositions Role positions to update\n   * @returns {Promise<Guild>}\n   * @example\n   * guild.roles.setPositions([{ role: roleId, position: updatedRoleIndex }])\n   *  .then(guild => console.log(`Role positions updated for ${guild}`))\n   *  .catch(console.error);\n   */\n  async setPositions(rolePositions) {\n    // Make sure rolePositions are prepared for API\n    rolePositions = rolePositions.map(o => ({\n      id: this.resolveId(o.role),\n      position: o.position\n    }));\n\n    // Call the API to update role positions\n    await this.client.rest.patch(Routes.guildRoles(this.guild.id), {\n      body: rolePositions\n    });\n    return this.client.actions.GuildRolesPositionUpdate.handle({\n      guild_id: this.guild.id,\n      roles: rolePositions\n    }).guild;\n  }\n\n  /**\n   * Compares the positions of two roles.\n   * @param {RoleResolvable} role1 First role to compare\n   * @param {RoleResolvable} role2 Second role to compare\n   * @returns {number} Negative number if the first role's position is lower (second role's is higher),\n   * positive number if the first's is higher (second's is lower), 0 if equal\n   */\n  comparePositions(role1, role2) {\n    const resolvedRole1 = this.resolve(role1);\n    const resolvedRole2 = this.resolve(role2);\n    if (!resolvedRole1 || !resolvedRole2) {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'role', 'Role nor a Snowflake');\n    }\n    const role1Position = resolvedRole1.position;\n    const role2Position = resolvedRole2.position;\n    if (role1Position === role2Position) {\n      return Number(BigInt(resolvedRole2.id) - BigInt(resolvedRole1.id));\n    }\n    return role1Position - role2Position;\n  }\n\n  /**\n   * Gets the managed role a user created when joining the guild, if any\n   * <info>Only ever available for bots</info>\n   * @param {UserResolvable} user The user to access the bot role for\n   * @returns {?Role}\n   */\n  botRoleFor(user) {\n    const userId = this.client.users.resolveId(user);\n    if (!userId) return null;\n    return this.cache.find(role => role.tags?.botId === userId) ?? null;\n  }\n\n  /**\n   * The `@everyone` role of the guild\n   * @type {Role}\n   * @readonly\n   */\n  get everyone() {\n    return this.cache.get(this.guild.id);\n  }\n\n  /**\n   * The premium subscriber role of the guild, if any\n   * @type {?Role}\n   * @readonly\n   */\n  get premiumSubscriberRole() {\n    return this.cache.find(role => role.tags?.premiumSubscriberRole) ?? null;\n  }\n\n  /**\n   * The role with the highest position in the cache\n   * @type {Role}\n   * @readonly\n   */\n  get highest() {\n    return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());\n  }\n}\nmodule.exports = RoleManager;","map":{"version":3,"names":["process","require","Collection","Routes","CachedManager","DiscordjsTypeError","ErrorCodes","Role","DataResolver","PermissionsBitField","setPosition","resolveColor","cacheWarningEmitted","RoleManager","constructor","guild","iterable","client","_cache","name","emitWarning","_add","data","cache","extras","fetch","id","force","existing","get","rest","guildRoles","roles","role","set","create","options","color","hoist","permissions","position","mentionable","reason","icon","unicodeEmoji","undefined","guildEmojiURL","emojis","resolve","url","resolveImage","post","body","unicode_emoji","actions","GuildRoleCreate","handle","guild_id","edit","InvalidType","d","patch","guildRole","clone","_clone","_patch","delete","resolveId","GuildRoleDelete","role_id","relative","updatedRoles","_sortedRoles","GuildRolesPositionUpdate","setPositions","rolePositions","map","o","comparePositions","role1","role2","resolvedRole1","resolvedRole2","role1Position","role2Position","Number","BigInt","botRoleFor","user","userId","users","find","tags","botId","everyone","premiumSubscriberRole","highest","reduce","prev","comparePositionTo","first","module","exports"],"sources":["C:/Users/hetit/node_modules/discord.js/src/managers/RoleManager.js"],"sourcesContent":["'use strict';\n\nconst process = require('node:process');\nconst { Collection } = require('@discordjs/collection');\nconst { Routes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst { DiscordjsTypeError, ErrorCodes } = require('../errors');\nconst { Role } = require('../structures/Role');\nconst DataResolver = require('../util/DataResolver');\nconst PermissionsBitField = require('../util/PermissionsBitField');\nconst { setPosition, resolveColor } = require('../util/Util');\n\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for roles and stores their cache.\n * @extends {CachedManager}\n */\nclass RoleManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, Role, iterable);\n    if (!cacheWarningEmitted && this._cache.constructor.name !== 'Collection') {\n      cacheWarningEmitted = true;\n      process.emitWarning(\n        `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,\n        'UnsupportedCacheOverwriteWarning',\n      );\n    }\n\n    /**\n     * The guild belonging to this manager\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The role cache of this manager\n   * @type {Collection<Snowflake, Role>}\n   * @name RoleManager#cache\n   */\n\n  _add(data, cache) {\n    return super._add(data, cache, { extras: [this.guild] });\n  }\n\n  /**\n   * Obtains a role from Discord, or the role cache if they're already available.\n   * @param {Snowflake} [id] The role's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<?Role|Collection<Snowflake, Role>>}\n   * @example\n   * // Fetch all roles from the guild\n   * message.guild.roles.fetch()\n   *   .then(roles => console.log(`There are ${roles.size} roles.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single role\n   * message.guild.roles.fetch('222078108977594368')\n   *   .then(role => console.log(`The role color is: ${role.color}`))\n   *   .catch(console.error);\n   */\n  async fetch(id, { cache = true, force = false } = {}) {\n    if (id && !force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    }\n\n    // We cannot fetch a single role, as of this commit's date, Discord API throws with 405\n    const data = await this.client.rest.get(Routes.guildRoles(this.guild.id));\n    const roles = new Collection();\n    for (const role of data) roles.set(role.id, this._add(role, cache));\n    return id ? roles.get(id) ?? null : roles;\n  }\n\n  /**\n   * Data that can be resolved to a Role object. This can be:\n   * * A Role\n   * * A Snowflake\n   * @typedef {Role|Snowflake} RoleResolvable\n   */\n\n  /**\n   * Resolves a {@link RoleResolvable} to a {@link Role} object.\n   * @method resolve\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Role}\n   */\n\n  /**\n   * Resolves a {@link RoleResolvable} to a {@link Role} id.\n   * @method resolveId\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Options used to create a new role.\n   * @typedef {Object} RoleCreateOptions\n   * @property {string} [name] The name of the new role\n   * @property {ColorResolvable} [color] The data to create the role with\n   * @property {boolean} [hoist] Whether or not the new role should be hoisted\n   * @property {PermissionResolvable} [permissions] The permissions for the new role\n   * @property {number} [position] The position of the new role\n   * @property {boolean} [mentionable] Whether or not the new role should be mentionable\n   * @property {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} [icon] The icon for the role\n   * <warn>The `EmojiResolvable` should belong to the same guild as the role.\n   * If not, pass the emoji's URL directly</warn>\n   * @property {?string} [unicodeEmoji] The unicode emoji for the role\n   * @property {string} [reason] The reason for creating this role\n   */\n\n  /**\n   * Creates a new role in the guild with given information.\n   * <warn>The position will silently reset to 1 if an invalid one is provided, or none.</warn>\n   * @param {RoleCreateOptions} [options] Options for creating the new role\n   * @returns {Promise<Role>}\n   * @example\n   * // Create a new role\n   * guild.roles.create()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Create a new role with data and a reason\n   * guild.roles.create({\n   *   name: 'Super Cool Blue People',\n   *   color: Colors.Blue,\n   *   reason: 'we needed a role for Super Cool People',\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async create(options = {}) {\n    let { name, color, hoist, permissions, position, mentionable, reason, icon, unicodeEmoji } = options;\n    color &&= resolveColor(color);\n    if (permissions !== undefined) permissions = new PermissionsBitField(permissions);\n    if (icon) {\n      const guildEmojiURL = this.guild.emojis.resolve(icon)?.url;\n      icon = guildEmojiURL ? await DataResolver.resolveImage(guildEmojiURL) : await DataResolver.resolveImage(icon);\n      if (typeof icon !== 'string') icon = undefined;\n    }\n\n    const data = await this.client.rest.post(Routes.guildRoles(this.guild.id), {\n      body: {\n        name,\n        color,\n        hoist,\n        permissions,\n        mentionable,\n        icon,\n        unicode_emoji: unicodeEmoji,\n      },\n      reason,\n    });\n    const { role } = this.client.actions.GuildRoleCreate.handle({\n      guild_id: this.guild.id,\n      role: data,\n    });\n    if (position) return this.setPosition(role, position, { reason });\n    return role;\n  }\n\n  /**\n   * Options for editing a role\n   * @typedef {RoleData} RoleEditOptions\n   * @property {string} [reason] The reason for editing this role\n   */\n\n  /**\n   * Edits a role of the guild.\n   * @param {RoleResolvable} role The role to edit\n   * @param {RoleEditOptions} options The options to provide\n   * @returns {Promise<Role>}\n   * @example\n   * // Edit a role\n   * guild.roles.edit('222079219327434752', { name: 'buddies' })\n   *   .then(updated => console.log(`Edited role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n  async edit(role, options) {\n    role = this.resolve(role);\n    if (!role) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'role', 'RoleResolvable');\n\n    if (typeof options.position === 'number') {\n      await this.setPosition(role, options.position, { reason: options.reason });\n    }\n\n    let icon = options.icon;\n    if (icon) {\n      const guildEmojiURL = this.guild.emojis.resolve(icon)?.url;\n      icon = guildEmojiURL ? await DataResolver.resolveImage(guildEmojiURL) : await DataResolver.resolveImage(icon);\n      if (typeof icon !== 'string') icon = undefined;\n    }\n\n    const body = {\n      name: options.name,\n      color: options.color === undefined ? undefined : resolveColor(options.color),\n      hoist: options.hoist,\n      permissions: options.permissions === undefined ? undefined : new PermissionsBitField(options.permissions),\n      mentionable: options.mentionable,\n      icon,\n      unicode_emoji: options.unicodeEmoji,\n    };\n\n    const d = await this.client.rest.patch(Routes.guildRole(this.guild.id, role.id), { body, reason: options.reason });\n\n    const clone = role._clone();\n    clone._patch(d);\n    return clone;\n  }\n\n  /**\n   * Deletes a role.\n   * @param {RoleResolvable} role The role to delete\n   * @param {string} [reason] Reason for deleting the role\n   * @returns {Promise<void>}\n   * @example\n   * // Delete a role\n   * guild.roles.delete('222079219327434752', 'The role needed to go')\n   *   .then(() => console.log('Deleted the role'))\n   *   .catch(console.error);\n   */\n  async delete(role, reason) {\n    const id = this.resolveId(role);\n    await this.client.rest.delete(Routes.guildRole(this.guild.id, id), { reason });\n    this.client.actions.GuildRoleDelete.handle({ guild_id: this.guild.id, role_id: id });\n  }\n\n  /**\n   * Sets the new position of the role.\n   * @param {RoleResolvable} role The role to change the position of\n   * @param {number} position The new position for the role\n   * @param {SetRolePositionOptions} [options] Options for setting the position\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the position of the role\n   * guild.roles.setPosition('222197033908436994', 1)\n   *   .then(updated => console.log(`Role position: ${updated.position}`))\n   *   .catch(console.error);\n   */\n  async setPosition(role, position, { relative, reason } = {}) {\n    role = this.resolve(role);\n    if (!role) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'role', 'RoleResolvable');\n    const updatedRoles = await setPosition(\n      role,\n      position,\n      relative,\n      this.guild._sortedRoles(),\n      this.client,\n      Routes.guildRoles(this.guild.id),\n      reason,\n    );\n\n    this.client.actions.GuildRolesPositionUpdate.handle({\n      guild_id: this.guild.id,\n      roles: updatedRoles,\n    });\n    return role;\n  }\n\n  /**\n   * The data needed for updating a guild role's position\n   * @typedef {Object} GuildRolePosition\n   * @property {RoleResolvable} role The role's id\n   * @property {number} position The position to update\n   */\n\n  /**\n   * Batch-updates the guild's role positions\n   * @param {GuildRolePosition[]} rolePositions Role positions to update\n   * @returns {Promise<Guild>}\n   * @example\n   * guild.roles.setPositions([{ role: roleId, position: updatedRoleIndex }])\n   *  .then(guild => console.log(`Role positions updated for ${guild}`))\n   *  .catch(console.error);\n   */\n  async setPositions(rolePositions) {\n    // Make sure rolePositions are prepared for API\n    rolePositions = rolePositions.map(o => ({\n      id: this.resolveId(o.role),\n      position: o.position,\n    }));\n\n    // Call the API to update role positions\n    await this.client.rest.patch(Routes.guildRoles(this.guild.id), { body: rolePositions });\n    return this.client.actions.GuildRolesPositionUpdate.handle({\n      guild_id: this.guild.id,\n      roles: rolePositions,\n    }).guild;\n  }\n\n  /**\n   * Compares the positions of two roles.\n   * @param {RoleResolvable} role1 First role to compare\n   * @param {RoleResolvable} role2 Second role to compare\n   * @returns {number} Negative number if the first role's position is lower (second role's is higher),\n   * positive number if the first's is higher (second's is lower), 0 if equal\n   */\n  comparePositions(role1, role2) {\n    const resolvedRole1 = this.resolve(role1);\n    const resolvedRole2 = this.resolve(role2);\n    if (!resolvedRole1 || !resolvedRole2) {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'role', 'Role nor a Snowflake');\n    }\n\n    const role1Position = resolvedRole1.position;\n    const role2Position = resolvedRole2.position;\n\n    if (role1Position === role2Position) {\n      return Number(BigInt(resolvedRole2.id) - BigInt(resolvedRole1.id));\n    }\n\n    return role1Position - role2Position;\n  }\n\n  /**\n   * Gets the managed role a user created when joining the guild, if any\n   * <info>Only ever available for bots</info>\n   * @param {UserResolvable} user The user to access the bot role for\n   * @returns {?Role}\n   */\n  botRoleFor(user) {\n    const userId = this.client.users.resolveId(user);\n    if (!userId) return null;\n    return this.cache.find(role => role.tags?.botId === userId) ?? null;\n  }\n\n  /**\n   * The `@everyone` role of the guild\n   * @type {Role}\n   * @readonly\n   */\n  get everyone() {\n    return this.cache.get(this.guild.id);\n  }\n\n  /**\n   * The premium subscriber role of the guild, if any\n   * @type {?Role}\n   * @readonly\n   */\n  get premiumSubscriberRole() {\n    return this.cache.find(role => role.tags?.premiumSubscriberRole) ?? null;\n  }\n\n  /**\n   * The role with the highest position in the cache\n   * @type {Role}\n   * @readonly\n   */\n  get highest() {\n    return this.cache.reduce((prev, role) => (role.comparePositionTo(prev) > 0 ? role : prev), this.cache.first());\n  }\n}\n\nmodule.exports = RoleManager;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}