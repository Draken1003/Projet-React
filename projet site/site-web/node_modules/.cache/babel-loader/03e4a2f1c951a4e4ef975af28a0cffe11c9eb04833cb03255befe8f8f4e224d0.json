{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('node:events');\nconst path = require('node:path');\nconst process = require('node:process');\nconst {\n  setTimeout,\n  clearTimeout\n} = require('node:timers');\nconst {\n  setTimeout: sleep\n} = require('node:timers/promises');\nconst {\n  DiscordjsError,\n  ErrorCodes\n} = require('../errors');\nconst ShardEvents = require('../util/ShardEvents');\nconst {\n  makeError,\n  makePlainError\n} = require('../util/Util');\nlet childProcess = null;\nlet Worker = null;\n\n/**\n * A self-contained shard created by the {@link ShardingManager}. Each one has a {@link ChildProcess} that contains\n * an instance of the bot and its {@link Client}. When its child process/worker exits for any reason, the shard will\n * spawn a new one to replace it as necessary.\n * @extends {EventEmitter}\n */\nclass Shard extends EventEmitter {\n  constructor(manager, id) {\n    super();\n    switch (manager.mode) {\n      case 'process':\n        childProcess = require('node:child_process');\n        break;\n      case 'worker':\n        Worker = require('node:worker_threads').Worker;\n        break;\n    }\n\n    /**\n     * Manager that created the shard\n     * @type {ShardingManager}\n     */\n    this.manager = manager;\n\n    /**\n     * The shard's id in the manager\n     * @type {number}\n     */\n    this.id = id;\n\n    /**\n     * Whether to pass silent flag to the shard's process (only when {@link ShardingManager#mode} is `process`)\n     * @type {boolean}\n     */\n    this.silent = manager.silent;\n\n    /**\n     * Arguments for the shard's process (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n    this.args = manager.shardArgs ?? [];\n\n    /**\n     * Arguments for the shard's process executable (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n    this.execArgv = manager.execArgv;\n\n    /**\n     * Environment variables for the shard's process, or workerData for the shard's worker\n     * @type {Object}\n     */\n    this.env = Object.assign({}, process.env, {\n      SHARDING_MANAGER: true,\n      SHARDS: this.id,\n      SHARD_COUNT: this.manager.totalShards,\n      DISCORD_TOKEN: this.manager.token\n    });\n\n    /**\n     * Whether the shard's {@link Client} is ready\n     * @type {boolean}\n     */\n    this.ready = false;\n\n    /**\n     * Process of the shard (if {@link ShardingManager#mode} is `process`)\n     * @type {?ChildProcess}\n     */\n    this.process = null;\n\n    /**\n     * Worker of the shard (if {@link ShardingManager#mode} is `worker`)\n     * @type {?Worker}\n     */\n    this.worker = null;\n\n    /**\n     * Ongoing promises for calls to {@link Shard#eval}, mapped by the `script` they were called with\n     * @type {Map<string, Promise>}\n     * @private\n     */\n    this._evals = new Map();\n\n    /**\n     * Ongoing promises for calls to {@link Shard#fetchClientValue}, mapped by the `prop` they were called with\n     * @type {Map<string, Promise>}\n     * @private\n     */\n    this._fetches = new Map();\n\n    /**\n     * Listener function for the {@link ChildProcess}' `exit` event\n     * @type {Function}\n     * @private\n     */\n    this._exitListener = null;\n  }\n\n  /**\n   * Forks a child process or creates a worker thread for the shard.\n   * <warn>You should not need to call this manually.</warn>\n   * @param {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client} has become ready\n   * before resolving (`-1` or `Infinity` for no wait)\n   * @returns {Promise<ChildProcess>}\n   */\n  spawn(timeout = 30_000) {\n    if (this.process) throw new DiscordjsError(ErrorCodes.ShardingProcessExists, this.id);\n    if (this.worker) throw new DiscordjsError(ErrorCodes.ShardingWorkerExists, this.id);\n    this._exitListener = this._handleExit.bind(this, undefined, timeout);\n    switch (this.manager.mode) {\n      case 'process':\n        this.process = childProcess.fork(path.resolve(this.manager.file), this.args, {\n          env: this.env,\n          execArgv: this.execArgv,\n          silent: this.silent\n        }).on('message', this._handleMessage.bind(this)).on('exit', this._exitListener);\n        break;\n      case 'worker':\n        this.worker = new Worker(path.resolve(this.manager.file), {\n          workerData: this.env\n        }).on('message', this._handleMessage.bind(this)).on('exit', this._exitListener);\n        break;\n    }\n    this._evals.clear();\n    this._fetches.clear();\n    const child = this.process ?? this.worker;\n\n    /**\n     * Emitted upon the creation of the shard's child process/worker.\n     * @event Shard#spawn\n     * @param {ChildProcess|Worker} process Child process/worker that was created\n     */\n    this.emit(ShardEvents.Spawn, child);\n    if (timeout === -1 || timeout === Infinity) return Promise.resolve(child);\n    return new Promise((resolve, reject) => {\n      const cleanup = () => {\n        clearTimeout(spawnTimeoutTimer);\n        this.off('ready', onReady);\n        this.off('disconnect', onDisconnect);\n        this.off('death', onDeath);\n      };\n      const onReady = () => {\n        cleanup();\n        resolve(child);\n      };\n      const onDisconnect = () => {\n        cleanup();\n        reject(new DiscordjsError(ErrorCodes.ShardingReadyDisconnected, this.id));\n      };\n      const onDeath = () => {\n        cleanup();\n        reject(new DiscordjsError(ErrorCodes.ShardingReadyDied, this.id));\n      };\n      const onTimeout = () => {\n        cleanup();\n        reject(new DiscordjsError(ErrorCodes.ShardingReadyTimeout, this.id));\n      };\n      const spawnTimeoutTimer = setTimeout(onTimeout, timeout);\n      this.once('ready', onReady);\n      this.once('disconnect', onDisconnect);\n      this.once('death', onDeath);\n    });\n  }\n\n  /**\n   * Immediately kills the shard's process/worker and does not restart it.\n   */\n  kill() {\n    if (this.process) {\n      this.process.removeListener('exit', this._exitListener);\n      this.process.kill();\n    } else {\n      this.worker.removeListener('exit', this._exitListener);\n      this.worker.terminate();\n    }\n    this._handleExit(false);\n  }\n\n  /**\n   * Options used to respawn a shard.\n   * @typedef {Object} ShardRespawnOptions\n   * @property {number} [delay=500] How long to wait between killing the process/worker and\n   * restarting it (in milliseconds)\n   * @property {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client}\n   * has become ready before resolving (`-1` or `Infinity` for no wait)\n   */\n\n  /**\n   * Kills and restarts the shard's process/worker.\n   * @param {ShardRespawnOptions} [options] Options for respawning the shard\n   * @returns {Promise<ChildProcess>}\n   */\n  async respawn({\n    delay = 500,\n    timeout = 30_000\n  } = {}) {\n    this.kill();\n    if (delay > 0) await sleep(delay);\n    return this.spawn(timeout);\n  }\n\n  /**\n   * Sends a message to the shard's process/worker.\n   * @param {*} message Message to send to the shard\n   * @returns {Promise<Shard>}\n   */\n  send(message) {\n    return new Promise((resolve, reject) => {\n      if (this.process) {\n        this.process.send(message, err => {\n          if (err) reject(err);else resolve(this);\n        });\n      } else {\n        this.worker.postMessage(message);\n        resolve(this);\n      }\n    });\n  }\n\n  /**\n   * Fetches a client property value of the shard.\n   * @param {string} prop Name of the client property to get, using periods for nesting\n   * @returns {Promise<*>}\n   * @example\n   * shard.fetchClientValue('guilds.cache.size')\n   *   .then(count => console.log(`${count} guilds in shard ${shard.id}`))\n   *   .catch(console.error);\n   */\n  fetchClientValue(prop) {\n    // Shard is dead (maybe respawning), don't cache anything and error immediately\n    if (!this.process && !this.worker) {\n      return Promise.reject(new DiscordjsError(ErrorCodes.ShardingNoChildExists, this.id));\n    }\n\n    // Cached promise from previous call\n    if (this._fetches.has(prop)) return this._fetches.get(prop);\n    const promise = new Promise((resolve, reject) => {\n      const child = this.process ?? this.worker;\n      const listener = message => {\n        if (message?._fetchProp !== prop) return;\n        child.removeListener('message', listener);\n        this.decrementMaxListeners(child);\n        this._fetches.delete(prop);\n        if (!message._error) resolve(message._result);else reject(makeError(message._error));\n      };\n      this.incrementMaxListeners(child);\n      child.on('message', listener);\n      this.send({\n        _fetchProp: prop\n      }).catch(err => {\n        child.removeListener('message', listener);\n        this.decrementMaxListeners(child);\n        this._fetches.delete(prop);\n        reject(err);\n      });\n    });\n    this._fetches.set(prop, promise);\n    return promise;\n  }\n\n  /**\n   * Evaluates a script or function on the shard, in the context of the {@link Client}.\n   * @param {string|Function} script JavaScript to run on the shard\n   * @param {*} [context] The context for the eval\n   * @returns {Promise<*>} Result of the script execution\n   */\n  eval(script, context) {\n    // Stringify the script if it's a Function\n    const _eval = typeof script === 'function' ? `(${script})(this, ${JSON.stringify(context)})` : script;\n\n    // Shard is dead (maybe respawning), don't cache anything and error immediately\n    if (!this.process && !this.worker) {\n      return Promise.reject(new DiscordjsError(ErrorCodes.ShardingNoChildExists, this.id));\n    }\n\n    // Cached promise from previous call\n    if (this._evals.has(_eval)) return this._evals.get(_eval);\n    const promise = new Promise((resolve, reject) => {\n      const child = this.process ?? this.worker;\n      const listener = message => {\n        if (message?._eval !== _eval) return;\n        child.removeListener('message', listener);\n        this.decrementMaxListeners(child);\n        this._evals.delete(_eval);\n        if (!message._error) resolve(message._result);else reject(makeError(message._error));\n      };\n      this.incrementMaxListeners(child);\n      child.on('message', listener);\n      this.send({\n        _eval\n      }).catch(err => {\n        child.removeListener('message', listener);\n        this.decrementMaxListeners(child);\n        this._evals.delete(_eval);\n        reject(err);\n      });\n    });\n    this._evals.set(_eval, promise);\n    return promise;\n  }\n\n  /**\n   * Handles a message received from the child process/worker.\n   * @param {*} message Message received\n   * @private\n   */\n  _handleMessage(message) {\n    if (message) {\n      // Shard is ready\n      if (message._ready) {\n        this.ready = true;\n        /**\n         * Emitted upon the shard's {@link Client#event:shardReady} event.\n         * @event Shard#ready\n         */\n        this.emit(ShardEvents.Ready);\n        return;\n      }\n\n      // Shard has disconnected\n      if (message._disconnect) {\n        this.ready = false;\n        /**\n         * Emitted upon the shard's {@link Client#event:shardDisconnect} event.\n         * @event Shard#disconnect\n         */\n        this.emit(ShardEvents.Disconnect);\n        return;\n      }\n\n      // Shard is attempting to reconnect\n      if (message._reconnecting) {\n        this.ready = false;\n        /**\n         * Emitted upon the shard's {@link Client#event:shardReconnecting} event.\n         * @event Shard#reconnecting\n         */\n        this.emit(ShardEvents.Reconnecting);\n        return;\n      }\n\n      // Shard has resumed\n      if (message._resume) {\n        this.ready = true;\n        /**\n         * Emitted upon the shard's {@link Client#event:shardResume} event.\n         * @event Shard#resume\n         */\n        this.emit(ShardEvents.Resume);\n        return;\n      }\n\n      // Shard is requesting a property fetch\n      if (message._sFetchProp) {\n        const resp = {\n          _sFetchProp: message._sFetchProp,\n          _sFetchPropShard: message._sFetchPropShard\n        };\n        this.manager.fetchClientValues(message._sFetchProp, message._sFetchPropShard).then(results => this.send({\n          ...resp,\n          _result: results\n        }), err => this.send({\n          ...resp,\n          _error: makePlainError(err)\n        }));\n        return;\n      }\n\n      // Shard is requesting an eval broadcast\n      if (message._sEval) {\n        const resp = {\n          _sEval: message._sEval,\n          _sEvalShard: message._sEvalShard\n        };\n        this.manager._performOnShards('eval', [message._sEval], message._sEvalShard).then(results => this.send({\n          ...resp,\n          _result: results\n        }), err => this.send({\n          ...resp,\n          _error: makePlainError(err)\n        }));\n        return;\n      }\n\n      // Shard is requesting a respawn of all shards\n      if (message._sRespawnAll) {\n        const {\n          shardDelay,\n          respawnDelay,\n          timeout\n        } = message._sRespawnAll;\n        this.manager.respawnAll({\n          shardDelay,\n          respawnDelay,\n          timeout\n        }).catch(() => {\n          // Do nothing\n        });\n        return;\n      }\n    }\n\n    /**\n     * Emitted upon receiving a message from the child process/worker.\n     * @event Shard#message\n     * @param {*} message Message that was received\n     */\n    this.emit(ShardEvents.Message, message);\n  }\n\n  /**\n   * Handles the shard's process/worker exiting.\n   * @param {boolean} [respawn=this.manager.respawn] Whether to spawn the shard again\n   * @param {number} [timeout] The amount in milliseconds to wait until the {@link Client}\n   * has become ready (`-1` or `Infinity` for no wait)\n   * @private\n   */\n  _handleExit(respawn = this.manager.respawn, timeout) {\n    /**\n     * Emitted upon the shard's child process/worker exiting.\n     * @event Shard#death\n     * @param {ChildProcess|Worker} process Child process/worker that exited\n     */\n    this.emit(ShardEvents.Death, this.process ?? this.worker);\n    this.ready = false;\n    this.process = null;\n    this.worker = null;\n    this._evals.clear();\n    this._fetches.clear();\n    if (respawn) this.spawn(timeout).catch(err => this.emit(ShardEvents.Error, err));\n  }\n\n  /**\n   * Increments max listeners by one for a given emitter, if they are not zero.\n   * @param {EventEmitter|process} emitter The emitter that emits the events.\n   * @private\n   */\n  incrementMaxListeners(emitter) {\n    const maxListeners = emitter.getMaxListeners();\n    if (maxListeners !== 0) {\n      emitter.setMaxListeners(maxListeners + 1);\n    }\n  }\n\n  /**\n   * Decrements max listeners by one for a given emitter, if they are not zero.\n   * @param {EventEmitter|process} emitter The emitter that emits the events.\n   * @private\n   */\n  decrementMaxListeners(emitter) {\n    const maxListeners = emitter.getMaxListeners();\n    if (maxListeners !== 0) {\n      emitter.setMaxListeners(maxListeners - 1);\n    }\n  }\n}\nmodule.exports = Shard;","map":{"version":3,"names":["EventEmitter","require","path","process","setTimeout","clearTimeout","sleep","DiscordjsError","ErrorCodes","ShardEvents","makeError","makePlainError","childProcess","Worker","Shard","constructor","manager","id","mode","silent","args","shardArgs","execArgv","env","Object","assign","SHARDING_MANAGER","SHARDS","SHARD_COUNT","totalShards","DISCORD_TOKEN","token","ready","worker","_evals","Map","_fetches","_exitListener","spawn","timeout","ShardingProcessExists","ShardingWorkerExists","_handleExit","bind","undefined","fork","resolve","file","on","_handleMessage","workerData","clear","child","emit","Spawn","Infinity","Promise","reject","cleanup","spawnTimeoutTimer","off","onReady","onDisconnect","onDeath","ShardingReadyDisconnected","ShardingReadyDied","onTimeout","ShardingReadyTimeout","once","kill","removeListener","terminate","respawn","delay","send","message","err","postMessage","fetchClientValue","prop","ShardingNoChildExists","has","get","promise","listener","_fetchProp","decrementMaxListeners","delete","_error","_result","incrementMaxListeners","catch","set","eval","script","context","_eval","JSON","stringify","_ready","Ready","_disconnect","Disconnect","_reconnecting","Reconnecting","_resume","Resume","_sFetchProp","resp","_sFetchPropShard","fetchClientValues","then","results","_sEval","_sEvalShard","_performOnShards","_sRespawnAll","shardDelay","respawnDelay","respawnAll","Message","Death","Error","emitter","maxListeners","getMaxListeners","setMaxListeners","module","exports"],"sources":["C:/Users/hetit/node_modules/discord.js/src/sharding/Shard.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('node:events');\nconst path = require('node:path');\nconst process = require('node:process');\nconst { setTimeout, clearTimeout } = require('node:timers');\nconst { setTimeout: sleep } = require('node:timers/promises');\nconst { DiscordjsError, ErrorCodes } = require('../errors');\nconst ShardEvents = require('../util/ShardEvents');\nconst { makeError, makePlainError } = require('../util/Util');\nlet childProcess = null;\nlet Worker = null;\n\n/**\n * A self-contained shard created by the {@link ShardingManager}. Each one has a {@link ChildProcess} that contains\n * an instance of the bot and its {@link Client}. When its child process/worker exits for any reason, the shard will\n * spawn a new one to replace it as necessary.\n * @extends {EventEmitter}\n */\nclass Shard extends EventEmitter {\n  constructor(manager, id) {\n    super();\n\n    switch (manager.mode) {\n      case 'process':\n        childProcess = require('node:child_process');\n        break;\n      case 'worker':\n        Worker = require('node:worker_threads').Worker;\n        break;\n    }\n\n    /**\n     * Manager that created the shard\n     * @type {ShardingManager}\n     */\n    this.manager = manager;\n\n    /**\n     * The shard's id in the manager\n     * @type {number}\n     */\n    this.id = id;\n\n    /**\n     * Whether to pass silent flag to the shard's process (only when {@link ShardingManager#mode} is `process`)\n     * @type {boolean}\n     */\n    this.silent = manager.silent;\n\n    /**\n     * Arguments for the shard's process (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n    this.args = manager.shardArgs ?? [];\n\n    /**\n     * Arguments for the shard's process executable (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n    this.execArgv = manager.execArgv;\n\n    /**\n     * Environment variables for the shard's process, or workerData for the shard's worker\n     * @type {Object}\n     */\n    this.env = Object.assign({}, process.env, {\n      SHARDING_MANAGER: true,\n      SHARDS: this.id,\n      SHARD_COUNT: this.manager.totalShards,\n      DISCORD_TOKEN: this.manager.token,\n    });\n\n    /**\n     * Whether the shard's {@link Client} is ready\n     * @type {boolean}\n     */\n    this.ready = false;\n\n    /**\n     * Process of the shard (if {@link ShardingManager#mode} is `process`)\n     * @type {?ChildProcess}\n     */\n    this.process = null;\n\n    /**\n     * Worker of the shard (if {@link ShardingManager#mode} is `worker`)\n     * @type {?Worker}\n     */\n    this.worker = null;\n\n    /**\n     * Ongoing promises for calls to {@link Shard#eval}, mapped by the `script` they were called with\n     * @type {Map<string, Promise>}\n     * @private\n     */\n    this._evals = new Map();\n\n    /**\n     * Ongoing promises for calls to {@link Shard#fetchClientValue}, mapped by the `prop` they were called with\n     * @type {Map<string, Promise>}\n     * @private\n     */\n    this._fetches = new Map();\n\n    /**\n     * Listener function for the {@link ChildProcess}' `exit` event\n     * @type {Function}\n     * @private\n     */\n    this._exitListener = null;\n  }\n\n  /**\n   * Forks a child process or creates a worker thread for the shard.\n   * <warn>You should not need to call this manually.</warn>\n   * @param {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client} has become ready\n   * before resolving (`-1` or `Infinity` for no wait)\n   * @returns {Promise<ChildProcess>}\n   */\n  spawn(timeout = 30_000) {\n    if (this.process) throw new DiscordjsError(ErrorCodes.ShardingProcessExists, this.id);\n    if (this.worker) throw new DiscordjsError(ErrorCodes.ShardingWorkerExists, this.id);\n\n    this._exitListener = this._handleExit.bind(this, undefined, timeout);\n\n    switch (this.manager.mode) {\n      case 'process':\n        this.process = childProcess\n          .fork(path.resolve(this.manager.file), this.args, {\n            env: this.env,\n            execArgv: this.execArgv,\n            silent: this.silent,\n          })\n          .on('message', this._handleMessage.bind(this))\n          .on('exit', this._exitListener);\n        break;\n      case 'worker':\n        this.worker = new Worker(path.resolve(this.manager.file), { workerData: this.env })\n          .on('message', this._handleMessage.bind(this))\n          .on('exit', this._exitListener);\n        break;\n    }\n\n    this._evals.clear();\n    this._fetches.clear();\n\n    const child = this.process ?? this.worker;\n\n    /**\n     * Emitted upon the creation of the shard's child process/worker.\n     * @event Shard#spawn\n     * @param {ChildProcess|Worker} process Child process/worker that was created\n     */\n    this.emit(ShardEvents.Spawn, child);\n\n    if (timeout === -1 || timeout === Infinity) return Promise.resolve(child);\n    return new Promise((resolve, reject) => {\n      const cleanup = () => {\n        clearTimeout(spawnTimeoutTimer);\n        this.off('ready', onReady);\n        this.off('disconnect', onDisconnect);\n        this.off('death', onDeath);\n      };\n\n      const onReady = () => {\n        cleanup();\n        resolve(child);\n      };\n\n      const onDisconnect = () => {\n        cleanup();\n        reject(new DiscordjsError(ErrorCodes.ShardingReadyDisconnected, this.id));\n      };\n\n      const onDeath = () => {\n        cleanup();\n        reject(new DiscordjsError(ErrorCodes.ShardingReadyDied, this.id));\n      };\n\n      const onTimeout = () => {\n        cleanup();\n        reject(new DiscordjsError(ErrorCodes.ShardingReadyTimeout, this.id));\n      };\n\n      const spawnTimeoutTimer = setTimeout(onTimeout, timeout);\n      this.once('ready', onReady);\n      this.once('disconnect', onDisconnect);\n      this.once('death', onDeath);\n    });\n  }\n\n  /**\n   * Immediately kills the shard's process/worker and does not restart it.\n   */\n  kill() {\n    if (this.process) {\n      this.process.removeListener('exit', this._exitListener);\n      this.process.kill();\n    } else {\n      this.worker.removeListener('exit', this._exitListener);\n      this.worker.terminate();\n    }\n\n    this._handleExit(false);\n  }\n\n  /**\n   * Options used to respawn a shard.\n   * @typedef {Object} ShardRespawnOptions\n   * @property {number} [delay=500] How long to wait between killing the process/worker and\n   * restarting it (in milliseconds)\n   * @property {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client}\n   * has become ready before resolving (`-1` or `Infinity` for no wait)\n   */\n\n  /**\n   * Kills and restarts the shard's process/worker.\n   * @param {ShardRespawnOptions} [options] Options for respawning the shard\n   * @returns {Promise<ChildProcess>}\n   */\n  async respawn({ delay = 500, timeout = 30_000 } = {}) {\n    this.kill();\n    if (delay > 0) await sleep(delay);\n    return this.spawn(timeout);\n  }\n\n  /**\n   * Sends a message to the shard's process/worker.\n   * @param {*} message Message to send to the shard\n   * @returns {Promise<Shard>}\n   */\n  send(message) {\n    return new Promise((resolve, reject) => {\n      if (this.process) {\n        this.process.send(message, err => {\n          if (err) reject(err);\n          else resolve(this);\n        });\n      } else {\n        this.worker.postMessage(message);\n        resolve(this);\n      }\n    });\n  }\n\n  /**\n   * Fetches a client property value of the shard.\n   * @param {string} prop Name of the client property to get, using periods for nesting\n   * @returns {Promise<*>}\n   * @example\n   * shard.fetchClientValue('guilds.cache.size')\n   *   .then(count => console.log(`${count} guilds in shard ${shard.id}`))\n   *   .catch(console.error);\n   */\n  fetchClientValue(prop) {\n    // Shard is dead (maybe respawning), don't cache anything and error immediately\n    if (!this.process && !this.worker) {\n      return Promise.reject(new DiscordjsError(ErrorCodes.ShardingNoChildExists, this.id));\n    }\n\n    // Cached promise from previous call\n    if (this._fetches.has(prop)) return this._fetches.get(prop);\n\n    const promise = new Promise((resolve, reject) => {\n      const child = this.process ?? this.worker;\n\n      const listener = message => {\n        if (message?._fetchProp !== prop) return;\n        child.removeListener('message', listener);\n        this.decrementMaxListeners(child);\n        this._fetches.delete(prop);\n        if (!message._error) resolve(message._result);\n        else reject(makeError(message._error));\n      };\n\n      this.incrementMaxListeners(child);\n      child.on('message', listener);\n\n      this.send({ _fetchProp: prop }).catch(err => {\n        child.removeListener('message', listener);\n        this.decrementMaxListeners(child);\n        this._fetches.delete(prop);\n        reject(err);\n      });\n    });\n\n    this._fetches.set(prop, promise);\n    return promise;\n  }\n\n  /**\n   * Evaluates a script or function on the shard, in the context of the {@link Client}.\n   * @param {string|Function} script JavaScript to run on the shard\n   * @param {*} [context] The context for the eval\n   * @returns {Promise<*>} Result of the script execution\n   */\n  eval(script, context) {\n    // Stringify the script if it's a Function\n    const _eval = typeof script === 'function' ? `(${script})(this, ${JSON.stringify(context)})` : script;\n\n    // Shard is dead (maybe respawning), don't cache anything and error immediately\n    if (!this.process && !this.worker) {\n      return Promise.reject(new DiscordjsError(ErrorCodes.ShardingNoChildExists, this.id));\n    }\n\n    // Cached promise from previous call\n    if (this._evals.has(_eval)) return this._evals.get(_eval);\n\n    const promise = new Promise((resolve, reject) => {\n      const child = this.process ?? this.worker;\n\n      const listener = message => {\n        if (message?._eval !== _eval) return;\n        child.removeListener('message', listener);\n        this.decrementMaxListeners(child);\n        this._evals.delete(_eval);\n        if (!message._error) resolve(message._result);\n        else reject(makeError(message._error));\n      };\n\n      this.incrementMaxListeners(child);\n      child.on('message', listener);\n\n      this.send({ _eval }).catch(err => {\n        child.removeListener('message', listener);\n        this.decrementMaxListeners(child);\n        this._evals.delete(_eval);\n        reject(err);\n      });\n    });\n\n    this._evals.set(_eval, promise);\n    return promise;\n  }\n\n  /**\n   * Handles a message received from the child process/worker.\n   * @param {*} message Message received\n   * @private\n   */\n  _handleMessage(message) {\n    if (message) {\n      // Shard is ready\n      if (message._ready) {\n        this.ready = true;\n        /**\n         * Emitted upon the shard's {@link Client#event:shardReady} event.\n         * @event Shard#ready\n         */\n        this.emit(ShardEvents.Ready);\n        return;\n      }\n\n      // Shard has disconnected\n      if (message._disconnect) {\n        this.ready = false;\n        /**\n         * Emitted upon the shard's {@link Client#event:shardDisconnect} event.\n         * @event Shard#disconnect\n         */\n        this.emit(ShardEvents.Disconnect);\n        return;\n      }\n\n      // Shard is attempting to reconnect\n      if (message._reconnecting) {\n        this.ready = false;\n        /**\n         * Emitted upon the shard's {@link Client#event:shardReconnecting} event.\n         * @event Shard#reconnecting\n         */\n        this.emit(ShardEvents.Reconnecting);\n        return;\n      }\n\n      // Shard has resumed\n      if (message._resume) {\n        this.ready = true;\n        /**\n         * Emitted upon the shard's {@link Client#event:shardResume} event.\n         * @event Shard#resume\n         */\n        this.emit(ShardEvents.Resume);\n        return;\n      }\n\n      // Shard is requesting a property fetch\n      if (message._sFetchProp) {\n        const resp = { _sFetchProp: message._sFetchProp, _sFetchPropShard: message._sFetchPropShard };\n        this.manager.fetchClientValues(message._sFetchProp, message._sFetchPropShard).then(\n          results => this.send({ ...resp, _result: results }),\n          err => this.send({ ...resp, _error: makePlainError(err) }),\n        );\n        return;\n      }\n\n      // Shard is requesting an eval broadcast\n      if (message._sEval) {\n        const resp = { _sEval: message._sEval, _sEvalShard: message._sEvalShard };\n        this.manager._performOnShards('eval', [message._sEval], message._sEvalShard).then(\n          results => this.send({ ...resp, _result: results }),\n          err => this.send({ ...resp, _error: makePlainError(err) }),\n        );\n        return;\n      }\n\n      // Shard is requesting a respawn of all shards\n      if (message._sRespawnAll) {\n        const { shardDelay, respawnDelay, timeout } = message._sRespawnAll;\n        this.manager.respawnAll({ shardDelay, respawnDelay, timeout }).catch(() => {\n          // Do nothing\n        });\n        return;\n      }\n    }\n\n    /**\n     * Emitted upon receiving a message from the child process/worker.\n     * @event Shard#message\n     * @param {*} message Message that was received\n     */\n    this.emit(ShardEvents.Message, message);\n  }\n\n  /**\n   * Handles the shard's process/worker exiting.\n   * @param {boolean} [respawn=this.manager.respawn] Whether to spawn the shard again\n   * @param {number} [timeout] The amount in milliseconds to wait until the {@link Client}\n   * has become ready (`-1` or `Infinity` for no wait)\n   * @private\n   */\n  _handleExit(respawn = this.manager.respawn, timeout) {\n    /**\n     * Emitted upon the shard's child process/worker exiting.\n     * @event Shard#death\n     * @param {ChildProcess|Worker} process Child process/worker that exited\n     */\n    this.emit(ShardEvents.Death, this.process ?? this.worker);\n\n    this.ready = false;\n    this.process = null;\n    this.worker = null;\n    this._evals.clear();\n    this._fetches.clear();\n\n    if (respawn) this.spawn(timeout).catch(err => this.emit(ShardEvents.Error, err));\n  }\n\n  /**\n   * Increments max listeners by one for a given emitter, if they are not zero.\n   * @param {EventEmitter|process} emitter The emitter that emits the events.\n   * @private\n   */\n  incrementMaxListeners(emitter) {\n    const maxListeners = emitter.getMaxListeners();\n    if (maxListeners !== 0) {\n      emitter.setMaxListeners(maxListeners + 1);\n    }\n  }\n\n  /**\n   * Decrements max listeners by one for a given emitter, if they are not zero.\n   * @param {EventEmitter|process} emitter The emitter that emits the events.\n   * @private\n   */\n  decrementMaxListeners(emitter) {\n    const maxListeners = emitter.getMaxListeners();\n    if (maxListeners !== 0) {\n      emitter.setMaxListeners(maxListeners - 1);\n    }\n  }\n}\n\nmodule.exports = Shard;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}